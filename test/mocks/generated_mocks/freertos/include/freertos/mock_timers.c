/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_timers.h"

static const char* CMockString_pcTimerGetName = "pcTimerGetName";
static const char* CMockString_pcTimerName = "pcTimerName";
static const char* CMockString_ppxTimerTaskStackBuffer = "ppxTimerTaskStackBuffer";
static const char* CMockString_ppxTimerTaskTCBBuffer = "ppxTimerTaskTCBBuffer";
static const char* CMockString_pulTimerTaskStackSize = "pulTimerTaskStackSize";
static const char* CMockString_pvNewID = "pvNewID";
static const char* CMockString_pvParameter1 = "pvParameter1";
static const char* CMockString_pvTimerGetTimerID = "pvTimerGetTimerID";
static const char* CMockString_pvTimerID = "pvTimerID";
static const char* CMockString_pxCallbackFunction = "pxCallbackFunction";
static const char* CMockString_pxHigherPriorityTaskWoken = "pxHigherPriorityTaskWoken";
static const char* CMockString_pxTimerBuffer = "pxTimerBuffer";
static const char* CMockString_ulParameter2 = "ulParameter2";
static const char* CMockString_uxAutoReload = "uxAutoReload";
static const char* CMockString_uxTimerGetReloadMode = "uxTimerGetReloadMode";
static const char* CMockString_uxTimerGetTimerNumber = "uxTimerGetTimerNumber";
static const char* CMockString_uxTimerNumber = "uxTimerNumber";
static const char* CMockString_vApplicationGetTimerTaskMemory = "vApplicationGetTimerTaskMemory";
static const char* CMockString_vTimerSetReloadMode = "vTimerSetReloadMode";
static const char* CMockString_vTimerSetTimerID = "vTimerSetTimerID";
static const char* CMockString_vTimerSetTimerNumber = "vTimerSetTimerNumber";
static const char* CMockString_xCommandID = "xCommandID";
static const char* CMockString_xFunctionToPend = "xFunctionToPend";
static const char* CMockString_xOptionalValue = "xOptionalValue";
static const char* CMockString_xTicksToWait = "xTicksToWait";
static const char* CMockString_xTimer = "xTimer";
static const char* CMockString_xTimerCreate = "xTimerCreate";
static const char* CMockString_xTimerCreateStatic = "xTimerCreateStatic";
static const char* CMockString_xTimerCreateTimerTask = "xTimerCreateTimerTask";
static const char* CMockString_xTimerGenericCommand = "xTimerGenericCommand";
static const char* CMockString_xTimerGetExpiryTime = "xTimerGetExpiryTime";
static const char* CMockString_xTimerGetPeriod = "xTimerGetPeriod";
static const char* CMockString_xTimerGetTimerDaemonTaskHandle = "xTimerGetTimerDaemonTaskHandle";
static const char* CMockString_xTimerIsTimerActive = "xTimerIsTimerActive";
static const char* CMockString_xTimerPendFunctionCall = "xTimerPendFunctionCall";
static const char* CMockString_xTimerPendFunctionCallFromISR = "xTimerPendFunctionCallFromISR";
static const char* CMockString_xTimerPeriodInTicks = "xTimerPeriodInTicks";

typedef struct _CMOCK_xTimerCreate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TimerHandle_t ReturnVal;
  int CallOrder;
  const char* Expected_pcTimerName;
  TickType_t Expected_xTimerPeriodInTicks;
  UBaseType_t Expected_uxAutoReload;
  void* Expected_pvTimerID;
  TimerCallbackFunction_t Expected_pxCallbackFunction;
  int Expected_pvTimerID_Depth;
  char ReturnThruPtr_pvTimerID_Used;
  void* ReturnThruPtr_pvTimerID_Val;
  size_t ReturnThruPtr_pvTimerID_Size;
  char IgnoreArg_pcTimerName;
  char IgnoreArg_xTimerPeriodInTicks;
  char IgnoreArg_uxAutoReload;
  char IgnoreArg_pvTimerID;
  char IgnoreArg_pxCallbackFunction;

} CMOCK_xTimerCreate_CALL_INSTANCE;

typedef struct _CMOCK_xTimerCreateStatic_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TimerHandle_t ReturnVal;
  int CallOrder;
  const char* Expected_pcTimerName;
  TickType_t Expected_xTimerPeriodInTicks;
  UBaseType_t Expected_uxAutoReload;
  void* Expected_pvTimerID;
  TimerCallbackFunction_t Expected_pxCallbackFunction;
  StaticTimer_t* Expected_pxTimerBuffer;
  int Expected_pvTimerID_Depth;
  int Expected_pxTimerBuffer_Depth;
  char ReturnThruPtr_pvTimerID_Used;
  void* ReturnThruPtr_pvTimerID_Val;
  size_t ReturnThruPtr_pvTimerID_Size;
  char ReturnThruPtr_pxTimerBuffer_Used;
  StaticTimer_t* ReturnThruPtr_pxTimerBuffer_Val;
  size_t ReturnThruPtr_pxTimerBuffer_Size;
  char IgnoreArg_pcTimerName;
  char IgnoreArg_xTimerPeriodInTicks;
  char IgnoreArg_uxAutoReload;
  char IgnoreArg_pvTimerID;
  char IgnoreArg_pxCallbackFunction;
  char IgnoreArg_pxTimerBuffer;

} CMOCK_xTimerCreateStatic_CALL_INSTANCE;

typedef struct _CMOCK_pvTimerGetTimerID_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  void* ReturnVal;
  int CallOrder;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_pvTimerGetTimerID_CALL_INSTANCE;

typedef struct _CMOCK_vTimerSetTimerID_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  TimerHandle_t Expected_xTimer;
  void* Expected_pvNewID;
  int Expected_pvNewID_Depth;
  char ReturnThruPtr_pvNewID_Used;
  void* ReturnThruPtr_pvNewID_Val;
  size_t ReturnThruPtr_pvNewID_Size;
  char IgnoreArg_xTimer;
  char IgnoreArg_pvNewID;

} CMOCK_vTimerSetTimerID_CALL_INSTANCE;

typedef struct _CMOCK_xTimerIsTimerActive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_xTimerIsTimerActive_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TaskHandle_t ReturnVal;
  int CallOrder;

} CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE;

typedef struct _CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;
  PendedFunction_t Expected_xFunctionToPend;
  void* Expected_pvParameter1;
  uint32_t Expected_ulParameter2;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  int Expected_pvParameter1_Depth;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char ReturnThruPtr_pvParameter1_Used;
  void* ReturnThruPtr_pvParameter1_Val;
  size_t ReturnThruPtr_pvParameter1_Size;
  char ReturnThruPtr_pxHigherPriorityTaskWoken_Used;
  BaseType_t* ReturnThruPtr_pxHigherPriorityTaskWoken_Val;
  size_t ReturnThruPtr_pxHigherPriorityTaskWoken_Size;
  char IgnoreArg_xFunctionToPend;
  char IgnoreArg_pvParameter1;
  char IgnoreArg_ulParameter2;
  char IgnoreArg_pxHigherPriorityTaskWoken;

} CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE;

typedef struct _CMOCK_xTimerPendFunctionCall_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;
  PendedFunction_t Expected_xFunctionToPend;
  void* Expected_pvParameter1;
  uint32_t Expected_ulParameter2;
  TickType_t Expected_xTicksToWait;
  int Expected_pvParameter1_Depth;
  char ReturnThruPtr_pvParameter1_Used;
  void* ReturnThruPtr_pvParameter1_Val;
  size_t ReturnThruPtr_pvParameter1_Size;
  char IgnoreArg_xFunctionToPend;
  char IgnoreArg_pvParameter1;
  char IgnoreArg_ulParameter2;
  char IgnoreArg_xTicksToWait;

} CMOCK_xTimerPendFunctionCall_CALL_INSTANCE;

typedef struct _CMOCK_pcTimerGetName_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const char* ReturnVal;
  int CallOrder;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_pcTimerGetName_CALL_INSTANCE;

typedef struct _CMOCK_vTimerSetReloadMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  TimerHandle_t Expected_xTimer;
  UBaseType_t Expected_uxAutoReload;
  char IgnoreArg_xTimer;
  char IgnoreArg_uxAutoReload;

} CMOCK_vTimerSetReloadMode_CALL_INSTANCE;

typedef struct _CMOCK_uxTimerGetReloadMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  int CallOrder;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_uxTimerGetReloadMode_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGetPeriod_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TickType_t ReturnVal;
  int CallOrder;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_xTimerGetPeriod_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGetExpiryTime_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  TickType_t ReturnVal;
  int CallOrder;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_xTimerGetExpiryTime_CALL_INSTANCE;

typedef struct _CMOCK_xTimerCreateTimerTask_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;

} CMOCK_xTimerCreateTimerTask_CALL_INSTANCE;

typedef struct _CMOCK_xTimerGenericCommand_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  BaseType_t ReturnVal;
  int CallOrder;
  TimerHandle_t Expected_xTimer;
  BaseType_t Expected_xCommandID;
  TickType_t Expected_xOptionalValue;
  BaseType_t* Expected_pxHigherPriorityTaskWoken;
  TickType_t Expected_xTicksToWait;
  int Expected_pxHigherPriorityTaskWoken_Depth;
  char ReturnThruPtr_pxHigherPriorityTaskWoken_Used;
  BaseType_t* ReturnThruPtr_pxHigherPriorityTaskWoken_Val;
  size_t ReturnThruPtr_pxHigherPriorityTaskWoken_Size;
  char IgnoreArg_xTimer;
  char IgnoreArg_xCommandID;
  char IgnoreArg_xOptionalValue;
  char IgnoreArg_pxHigherPriorityTaskWoken;
  char IgnoreArg_xTicksToWait;

} CMOCK_xTimerGenericCommand_CALL_INSTANCE;

typedef struct _CMOCK_vTimerSetTimerNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  TimerHandle_t Expected_xTimer;
  UBaseType_t Expected_uxTimerNumber;
  char IgnoreArg_xTimer;
  char IgnoreArg_uxTimerNumber;

} CMOCK_vTimerSetTimerNumber_CALL_INSTANCE;

typedef struct _CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  UBaseType_t ReturnVal;
  int CallOrder;
  TimerHandle_t Expected_xTimer;
  char IgnoreArg_xTimer;

} CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE;

typedef struct _CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  StaticTask_t** Expected_ppxTimerTaskTCBBuffer;
  StackType_t** Expected_ppxTimerTaskStackBuffer;
  uint32_t* Expected_pulTimerTaskStackSize;
  int Expected_ppxTimerTaskTCBBuffer_Depth;
  int Expected_ppxTimerTaskStackBuffer_Depth;
  int Expected_pulTimerTaskStackSize_Depth;
  char ReturnThruPtr_ppxTimerTaskTCBBuffer_Used;
  StaticTask_t** ReturnThruPtr_ppxTimerTaskTCBBuffer_Val;
  size_t ReturnThruPtr_ppxTimerTaskTCBBuffer_Size;
  char ReturnThruPtr_ppxTimerTaskStackBuffer_Used;
  StackType_t** ReturnThruPtr_ppxTimerTaskStackBuffer_Val;
  size_t ReturnThruPtr_ppxTimerTaskStackBuffer_Size;
  char ReturnThruPtr_pulTimerTaskStackSize_Used;
  uint32_t* ReturnThruPtr_pulTimerTaskStackSize_Val;
  size_t ReturnThruPtr_pulTimerTaskStackSize_Size;
  char IgnoreArg_ppxTimerTaskTCBBuffer;
  char IgnoreArg_ppxTimerTaskStackBuffer;
  char IgnoreArg_pulTimerTaskStackSize;

} CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE;

static struct mock_timersInstance
{
  char xTimerCreate_IgnoreBool;
  TimerHandle_t xTimerCreate_FinalReturn;
  char xTimerCreate_CallbackBool;
  CMOCK_xTimerCreate_CALLBACK xTimerCreate_CallbackFunctionPointer;
  int xTimerCreate_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTimerCreate_CallInstance;
  char xTimerCreateStatic_IgnoreBool;
  TimerHandle_t xTimerCreateStatic_FinalReturn;
  char xTimerCreateStatic_CallbackBool;
  CMOCK_xTimerCreateStatic_CALLBACK xTimerCreateStatic_CallbackFunctionPointer;
  int xTimerCreateStatic_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTimerCreateStatic_CallInstance;
  char pvTimerGetTimerID_IgnoreBool;
  void* pvTimerGetTimerID_FinalReturn;
  char pvTimerGetTimerID_CallbackBool;
  CMOCK_pvTimerGetTimerID_CALLBACK pvTimerGetTimerID_CallbackFunctionPointer;
  int pvTimerGetTimerID_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pvTimerGetTimerID_CallInstance;
  char vTimerSetTimerID_IgnoreBool;
  char vTimerSetTimerID_CallbackBool;
  CMOCK_vTimerSetTimerID_CALLBACK vTimerSetTimerID_CallbackFunctionPointer;
  int vTimerSetTimerID_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vTimerSetTimerID_CallInstance;
  char xTimerIsTimerActive_IgnoreBool;
  BaseType_t xTimerIsTimerActive_FinalReturn;
  char xTimerIsTimerActive_CallbackBool;
  CMOCK_xTimerIsTimerActive_CALLBACK xTimerIsTimerActive_CallbackFunctionPointer;
  int xTimerIsTimerActive_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTimerIsTimerActive_CallInstance;
  char xTimerGetTimerDaemonTaskHandle_IgnoreBool;
  TaskHandle_t xTimerGetTimerDaemonTaskHandle_FinalReturn;
  char xTimerGetTimerDaemonTaskHandle_CallbackBool;
  CMOCK_xTimerGetTimerDaemonTaskHandle_CALLBACK xTimerGetTimerDaemonTaskHandle_CallbackFunctionPointer;
  int xTimerGetTimerDaemonTaskHandle_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTimerGetTimerDaemonTaskHandle_CallInstance;
  char xTimerPendFunctionCallFromISR_IgnoreBool;
  BaseType_t xTimerPendFunctionCallFromISR_FinalReturn;
  char xTimerPendFunctionCallFromISR_CallbackBool;
  CMOCK_xTimerPendFunctionCallFromISR_CALLBACK xTimerPendFunctionCallFromISR_CallbackFunctionPointer;
  int xTimerPendFunctionCallFromISR_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTimerPendFunctionCallFromISR_CallInstance;
  char xTimerPendFunctionCall_IgnoreBool;
  BaseType_t xTimerPendFunctionCall_FinalReturn;
  char xTimerPendFunctionCall_CallbackBool;
  CMOCK_xTimerPendFunctionCall_CALLBACK xTimerPendFunctionCall_CallbackFunctionPointer;
  int xTimerPendFunctionCall_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTimerPendFunctionCall_CallInstance;
  char pcTimerGetName_IgnoreBool;
  const char* pcTimerGetName_FinalReturn;
  char pcTimerGetName_CallbackBool;
  CMOCK_pcTimerGetName_CALLBACK pcTimerGetName_CallbackFunctionPointer;
  int pcTimerGetName_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE pcTimerGetName_CallInstance;
  char vTimerSetReloadMode_IgnoreBool;
  char vTimerSetReloadMode_CallbackBool;
  CMOCK_vTimerSetReloadMode_CALLBACK vTimerSetReloadMode_CallbackFunctionPointer;
  int vTimerSetReloadMode_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vTimerSetReloadMode_CallInstance;
  char uxTimerGetReloadMode_IgnoreBool;
  UBaseType_t uxTimerGetReloadMode_FinalReturn;
  char uxTimerGetReloadMode_CallbackBool;
  CMOCK_uxTimerGetReloadMode_CALLBACK uxTimerGetReloadMode_CallbackFunctionPointer;
  int uxTimerGetReloadMode_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxTimerGetReloadMode_CallInstance;
  char xTimerGetPeriod_IgnoreBool;
  TickType_t xTimerGetPeriod_FinalReturn;
  char xTimerGetPeriod_CallbackBool;
  CMOCK_xTimerGetPeriod_CALLBACK xTimerGetPeriod_CallbackFunctionPointer;
  int xTimerGetPeriod_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTimerGetPeriod_CallInstance;
  char xTimerGetExpiryTime_IgnoreBool;
  TickType_t xTimerGetExpiryTime_FinalReturn;
  char xTimerGetExpiryTime_CallbackBool;
  CMOCK_xTimerGetExpiryTime_CALLBACK xTimerGetExpiryTime_CallbackFunctionPointer;
  int xTimerGetExpiryTime_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTimerGetExpiryTime_CallInstance;
  char xTimerCreateTimerTask_IgnoreBool;
  BaseType_t xTimerCreateTimerTask_FinalReturn;
  char xTimerCreateTimerTask_CallbackBool;
  CMOCK_xTimerCreateTimerTask_CALLBACK xTimerCreateTimerTask_CallbackFunctionPointer;
  int xTimerCreateTimerTask_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTimerCreateTimerTask_CallInstance;
  char xTimerGenericCommand_IgnoreBool;
  BaseType_t xTimerGenericCommand_FinalReturn;
  char xTimerGenericCommand_CallbackBool;
  CMOCK_xTimerGenericCommand_CALLBACK xTimerGenericCommand_CallbackFunctionPointer;
  int xTimerGenericCommand_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE xTimerGenericCommand_CallInstance;
  char vTimerSetTimerNumber_IgnoreBool;
  char vTimerSetTimerNumber_CallbackBool;
  CMOCK_vTimerSetTimerNumber_CALLBACK vTimerSetTimerNumber_CallbackFunctionPointer;
  int vTimerSetTimerNumber_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vTimerSetTimerNumber_CallInstance;
  char uxTimerGetTimerNumber_IgnoreBool;
  UBaseType_t uxTimerGetTimerNumber_FinalReturn;
  char uxTimerGetTimerNumber_CallbackBool;
  CMOCK_uxTimerGetTimerNumber_CALLBACK uxTimerGetTimerNumber_CallbackFunctionPointer;
  int uxTimerGetTimerNumber_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE uxTimerGetTimerNumber_CallInstance;
  char vApplicationGetTimerTaskMemory_IgnoreBool;
  char vApplicationGetTimerTaskMemory_CallbackBool;
  CMOCK_vApplicationGetTimerTaskMemory_CALLBACK vApplicationGetTimerTaskMemory_CallbackFunctionPointer;
  int vApplicationGetTimerTaskMemory_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE vApplicationGetTimerTaskMemory_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_timers_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.xTimerCreate_CallInstance;
  if (Mock.xTimerCreate_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerCreate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xTimerCreate_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xTimerCreateStatic_CallInstance;
  if (Mock.xTimerCreateStatic_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerCreateStatic);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xTimerCreateStatic_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.pvTimerGetTimerID_CallInstance;
  if (Mock.pvTimerGetTimerID_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pvTimerGetTimerID);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.pvTimerGetTimerID_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vTimerSetTimerID_CallInstance;
  if (Mock.vTimerSetTimerID_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTimerSetTimerID);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vTimerSetTimerID_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xTimerIsTimerActive_CallInstance;
  if (Mock.xTimerIsTimerActive_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerIsTimerActive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xTimerIsTimerActive_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xTimerGetTimerDaemonTaskHandle_CallInstance;
  if (Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGetTimerDaemonTaskHandle);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xTimerGetTimerDaemonTaskHandle_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xTimerPendFunctionCallFromISR_CallInstance;
  if (Mock.xTimerPendFunctionCallFromISR_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCallFromISR);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xTimerPendFunctionCallFromISR_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xTimerPendFunctionCall_CallInstance;
  if (Mock.xTimerPendFunctionCall_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCall);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xTimerPendFunctionCall_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.pcTimerGetName_CallInstance;
  if (Mock.pcTimerGetName_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pcTimerGetName);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.pcTimerGetName_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vTimerSetReloadMode_CallInstance;
  if (Mock.vTimerSetReloadMode_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTimerSetReloadMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vTimerSetReloadMode_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxTimerGetReloadMode_CallInstance;
  if (Mock.uxTimerGetReloadMode_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTimerGetReloadMode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxTimerGetReloadMode_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xTimerGetPeriod_CallInstance;
  if (Mock.xTimerGetPeriod_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGetPeriod);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xTimerGetPeriod_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xTimerGetExpiryTime_CallInstance;
  if (Mock.xTimerGetExpiryTime_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGetExpiryTime);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xTimerGetExpiryTime_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xTimerCreateTimerTask_CallInstance;
  if (Mock.xTimerCreateTimerTask_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerCreateTimerTask);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xTimerCreateTimerTask_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.xTimerGenericCommand_CallInstance;
  if (Mock.xTimerGenericCommand_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_xTimerGenericCommand);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.xTimerGenericCommand_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vTimerSetTimerNumber_CallInstance;
  if (Mock.vTimerSetTimerNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vTimerSetTimerNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vTimerSetTimerNumber_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.uxTimerGetTimerNumber_CallInstance;
  if (Mock.uxTimerGetTimerNumber_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_uxTimerGetTimerNumber);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.uxTimerGetTimerNumber_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.vApplicationGetTimerTaskMemory_CallInstance;
  if (Mock.vApplicationGetTimerTaskMemory_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_vApplicationGetTimerTaskMemory);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.vApplicationGetTimerTaskMemory_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_timers_Init(void)
{
  mock_timers_Destroy();
}

void mock_timers_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

TimerHandle_t xTimerCreate(const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerCreate);
  cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerCreate_CallInstance);
  Mock.xTimerCreate_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreate_CallInstance);
  if (Mock.xTimerCreate_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerCreate_FinalReturn;
    memcpy((void*)(&Mock.xTimerCreate_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TimerHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTimerCreate_CallbackBool &&
      Mock.xTimerCreate_CallbackFunctionPointer != NULL)
  {
    TimerHandle_t cmock_cb_ret = Mock.xTimerCreate_CallbackFunctionPointer(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, Mock.xTimerCreate_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_pcTimerName)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_pcTimerName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcTimerName, pcTimerName, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTimerPeriodInTicks)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_xTimerPeriodInTicks);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxAutoReload)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_uxAutoReload);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvTimerID)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_pvTimerID);
    if (cmock_call_instance->Expected_pvTimerID == NULL)
      { UNITY_TEST_ASSERT_NULL(pvTimerID, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvTimerID, pvTimerID, cmock_call_instance->Expected_pvTimerID_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pxCallbackFunction)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreate,CMockString_pxCallbackFunction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction), sizeof(TimerCallbackFunction_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.xTimerCreate_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTimerCreate_CallbackFunctionPointer(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, Mock.xTimerCreate_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvTimerID_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvTimerID, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvTimerID, (void*)cmock_call_instance->ReturnThruPtr_pvTimerID_Val,
      cmock_call_instance->ReturnThruPtr_pvTimerID_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerCreate(CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, int pvTimerID_Depth, TimerCallbackFunction_t pxCallbackFunction);
void CMockExpectParameters_xTimerCreate(CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, int pvTimerID_Depth, TimerCallbackFunction_t pxCallbackFunction)
{
  cmock_call_instance->Expected_pcTimerName = pcTimerName;
  cmock_call_instance->IgnoreArg_pcTimerName = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks),
         sizeof(TickType_t[sizeof(xTimerPeriodInTicks) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimerPeriodInTicks = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload),
         sizeof(UBaseType_t[sizeof(uxAutoReload) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxAutoReload = 0;
  cmock_call_instance->Expected_pvTimerID = pvTimerID;
  cmock_call_instance->Expected_pvTimerID_Depth = pvTimerID_Depth;
  cmock_call_instance->IgnoreArg_pvTimerID = 0;
  cmock_call_instance->ReturnThruPtr_pvTimerID_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction),
         sizeof(TimerCallbackFunction_t[sizeof(pxCallbackFunction) == sizeof(TimerCallbackFunction_t) ? 1 : -1])); /* add TimerCallbackFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxCallbackFunction = 0;
}

void xTimerCreate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreate_CALL_INSTANCE));
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreate_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreate_CallInstance, cmock_guts_index);
  Mock.xTimerCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerCreate_IgnoreBool = (char)1;
}

void xTimerCreate_CMockStopIgnore(void)
{
  if(Mock.xTimerCreate_IgnoreBool)
    Mock.xTimerCreate_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreate_CallInstance);
  Mock.xTimerCreate_IgnoreBool = (char)0;
}

void xTimerCreate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreate_CALL_INSTANCE));
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreate_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreate_CallInstance, cmock_guts_index);
  Mock.xTimerCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerCreate(cmock_call_instance, pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, 1, pxCallbackFunction);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TimerHandle_t[sizeof(cmock_to_return) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

void xTimerCreate_AddCallback(CMOCK_xTimerCreate_CALLBACK Callback)
{
  Mock.xTimerCreate_IgnoreBool = (char)0;
  Mock.xTimerCreate_CallbackBool = (char)1;
  Mock.xTimerCreate_CallbackFunctionPointer = Callback;
}

void xTimerCreate_Stub(CMOCK_xTimerCreate_CALLBACK Callback)
{
  Mock.xTimerCreate_IgnoreBool = (char)0;
  Mock.xTimerCreate_CallbackBool = (char)0;
  Mock.xTimerCreate_CallbackFunctionPointer = Callback;
}

void xTimerCreate_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, int pvTimerID_Depth, TimerCallbackFunction_t pxCallbackFunction, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreate_CALL_INSTANCE));
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreate_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreate_CallInstance, cmock_guts_index);
  Mock.xTimerCreate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerCreate(cmock_call_instance, pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pvTimerID_Depth, pxCallbackFunction);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTimerCreate_CMockReturnMemThruPtr_pvTimerID(UNITY_LINE_TYPE cmock_line, void* pvTimerID, size_t cmock_size)
{
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvTimerID_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvTimerID_Val = pvTimerID;
  cmock_call_instance->ReturnThruPtr_pvTimerID_Size = cmock_size;
}

void xTimerCreate_CMockIgnoreArg_pcTimerName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcTimerName = 1;
}

void xTimerCreate_CMockIgnoreArg_xTimerPeriodInTicks(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimerPeriodInTicks = 1;
}

void xTimerCreate_CMockIgnoreArg_uxAutoReload(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxAutoReload = 1;
}

void xTimerCreate_CMockIgnoreArg_pvTimerID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvTimerID = 1;
}

void xTimerCreate_CMockIgnoreArg_pxCallbackFunction(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreate_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreate_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxCallbackFunction = 1;
}

TimerHandle_t xTimerCreateStatic(const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerCreateStatic);
  cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerCreateStatic_CallInstance);
  Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreateStatic_CallInstance);
  if (Mock.xTimerCreateStatic_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerCreateStatic_FinalReturn;
    memcpy((void*)(&Mock.xTimerCreateStatic_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TimerHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTimerCreateStatic_CallbackBool &&
      Mock.xTimerCreateStatic_CallbackFunctionPointer != NULL)
  {
    TimerHandle_t cmock_cb_ret = Mock.xTimerCreateStatic_CallbackFunctionPointer(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxTimerBuffer, Mock.xTimerCreateStatic_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_pcTimerName)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pcTimerName);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_pcTimerName, pcTimerName, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTimerPeriodInTicks)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_xTimerPeriodInTicks);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxAutoReload)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_uxAutoReload);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvTimerID)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pvTimerID);
    if (cmock_call_instance->Expected_pvTimerID == NULL)
      { UNITY_TEST_ASSERT_NULL(pvTimerID, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvTimerID, pvTimerID, cmock_call_instance->Expected_pvTimerID_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_pxCallbackFunction)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pxCallbackFunction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction), sizeof(TimerCallbackFunction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxTimerBuffer)
  {
    UNITY_SET_DETAILS(CMockString_xTimerCreateStatic,CMockString_pxTimerBuffer);
    if (cmock_call_instance->Expected_pxTimerBuffer == NULL)
      { UNITY_TEST_ASSERT_NULL(pxTimerBuffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxTimerBuffer), (void*)(pxTimerBuffer), sizeof(StaticTimer_t), cmock_call_instance->Expected_pxTimerBuffer_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.xTimerCreateStatic_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTimerCreateStatic_CallbackFunctionPointer(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxTimerBuffer, Mock.xTimerCreateStatic_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvTimerID_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvTimerID, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvTimerID, (void*)cmock_call_instance->ReturnThruPtr_pvTimerID_Val,
      cmock_call_instance->ReturnThruPtr_pvTimerID_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxTimerBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxTimerBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxTimerBuffer, (void*)cmock_call_instance->ReturnThruPtr_pxTimerBuffer_Val,
      cmock_call_instance->ReturnThruPtr_pxTimerBuffer_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerCreateStatic(CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, int pvTimerID_Depth, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer, int pxTimerBuffer_Depth);
void CMockExpectParameters_xTimerCreateStatic(CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, int pvTimerID_Depth, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer, int pxTimerBuffer_Depth)
{
  cmock_call_instance->Expected_pcTimerName = pcTimerName;
  cmock_call_instance->IgnoreArg_pcTimerName = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTimerPeriodInTicks), (void*)(&xTimerPeriodInTicks),
         sizeof(TickType_t[sizeof(xTimerPeriodInTicks) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimerPeriodInTicks = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload),
         sizeof(UBaseType_t[sizeof(uxAutoReload) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxAutoReload = 0;
  cmock_call_instance->Expected_pvTimerID = pvTimerID;
  cmock_call_instance->Expected_pvTimerID_Depth = pvTimerID_Depth;
  cmock_call_instance->IgnoreArg_pvTimerID = 0;
  cmock_call_instance->ReturnThruPtr_pvTimerID_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_pxCallbackFunction), (void*)(&pxCallbackFunction),
         sizeof(TimerCallbackFunction_t[sizeof(pxCallbackFunction) == sizeof(TimerCallbackFunction_t) ? 1 : -1])); /* add TimerCallbackFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pxCallbackFunction = 0;
  cmock_call_instance->Expected_pxTimerBuffer = pxTimerBuffer;
  cmock_call_instance->Expected_pxTimerBuffer_Depth = pxTimerBuffer_Depth;
  cmock_call_instance->IgnoreArg_pxTimerBuffer = 0;
  cmock_call_instance->ReturnThruPtr_pxTimerBuffer_Used = 0;
}

void xTimerCreateStatic_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateStatic_CALL_INSTANCE));
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateStatic_CallInstance, cmock_guts_index);
  Mock.xTimerCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerCreateStatic_IgnoreBool = (char)1;
}

void xTimerCreateStatic_CMockStopIgnore(void)
{
  if(Mock.xTimerCreateStatic_IgnoreBool)
    Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreateStatic_CallInstance);
  Mock.xTimerCreateStatic_IgnoreBool = (char)0;
}

void xTimerCreateStatic_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateStatic_CALL_INSTANCE));
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateStatic_CallInstance, cmock_guts_index);
  Mock.xTimerCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerCreateStatic(cmock_call_instance, pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, 1, pxCallbackFunction, pxTimerBuffer, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TimerHandle_t[sizeof(cmock_to_return) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
}

void xTimerCreateStatic_AddCallback(CMOCK_xTimerCreateStatic_CALLBACK Callback)
{
  Mock.xTimerCreateStatic_IgnoreBool = (char)0;
  Mock.xTimerCreateStatic_CallbackBool = (char)1;
  Mock.xTimerCreateStatic_CallbackFunctionPointer = Callback;
}

void xTimerCreateStatic_Stub(CMOCK_xTimerCreateStatic_CALLBACK Callback)
{
  Mock.xTimerCreateStatic_IgnoreBool = (char)0;
  Mock.xTimerCreateStatic_CallbackBool = (char)0;
  Mock.xTimerCreateStatic_CallbackFunctionPointer = Callback;
}

void xTimerCreateStatic_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const char* const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void* const pvTimerID, int pvTimerID_Depth, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t* pxTimerBuffer, int pxTimerBuffer_Depth, TimerHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateStatic_CALL_INSTANCE));
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateStatic_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateStatic_CallInstance, cmock_guts_index);
  Mock.xTimerCreateStatic_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerCreateStatic(cmock_call_instance, pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pvTimerID_Depth, pxCallbackFunction, pxTimerBuffer, pxTimerBuffer_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTimerCreateStatic_CMockReturnMemThruPtr_pvTimerID(UNITY_LINE_TYPE cmock_line, void* pvTimerID, size_t cmock_size)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvTimerID_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvTimerID_Val = pvTimerID;
  cmock_call_instance->ReturnThruPtr_pvTimerID_Size = cmock_size;
}

void xTimerCreateStatic_CMockReturnMemThruPtr_pxTimerBuffer(UNITY_LINE_TYPE cmock_line, StaticTimer_t* pxTimerBuffer, size_t cmock_size)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxTimerBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxTimerBuffer_Val = pxTimerBuffer;
  cmock_call_instance->ReturnThruPtr_pxTimerBuffer_Size = cmock_size;
}

void xTimerCreateStatic_CMockIgnoreArg_pcTimerName(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pcTimerName = 1;
}

void xTimerCreateStatic_CMockIgnoreArg_xTimerPeriodInTicks(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimerPeriodInTicks = 1;
}

void xTimerCreateStatic_CMockIgnoreArg_uxAutoReload(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxAutoReload = 1;
}

void xTimerCreateStatic_CMockIgnoreArg_pvTimerID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvTimerID = 1;
}

void xTimerCreateStatic_CMockIgnoreArg_pxCallbackFunction(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxCallbackFunction = 1;
}

void xTimerCreateStatic_CMockIgnoreArg_pxTimerBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerCreateStatic_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateStatic_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerCreateStatic_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxTimerBuffer = 1;
}

void* pvTimerGetTimerID(const TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pvTimerGetTimerID);
  cmock_call_instance = (CMOCK_pvTimerGetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pvTimerGetTimerID_CallInstance);
  Mock.pvTimerGetTimerID_CallInstance = CMock_Guts_MemNext(Mock.pvTimerGetTimerID_CallInstance);
  if (Mock.pvTimerGetTimerID_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.pvTimerGetTimerID_FinalReturn;
    Mock.pvTimerGetTimerID_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.pvTimerGetTimerID_CallbackBool &&
      Mock.pvTimerGetTimerID_CallbackFunctionPointer != NULL)
  {
    void* cmock_cb_ret = Mock.pvTimerGetTimerID_CallbackFunctionPointer(xTimer, Mock.pvTimerGetTimerID_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_pvTimerGetTimerID,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.pvTimerGetTimerID_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.pvTimerGetTimerID_CallbackFunctionPointer(xTimer, Mock.pvTimerGetTimerID_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pvTimerGetTimerID(CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance, const TimerHandle_t xTimer);
void CMockExpectParameters_pvTimerGetTimerID(CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance, const TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void pvTimerGetTimerID_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, void* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pvTimerGetTimerID_CALL_INSTANCE));
  CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTimerGetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pvTimerGetTimerID_CallInstance = CMock_Guts_MemChain(Mock.pvTimerGetTimerID_CallInstance, cmock_guts_index);
  Mock.pvTimerGetTimerID_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pvTimerGetTimerID_IgnoreBool = (char)1;
}

void pvTimerGetTimerID_CMockStopIgnore(void)
{
  if(Mock.pvTimerGetTimerID_IgnoreBool)
    Mock.pvTimerGetTimerID_CallInstance = CMock_Guts_MemNext(Mock.pvTimerGetTimerID_CallInstance);
  Mock.pvTimerGetTimerID_IgnoreBool = (char)0;
}

void pvTimerGetTimerID_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const TimerHandle_t xTimer, void* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pvTimerGetTimerID_CALL_INSTANCE));
  CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTimerGetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pvTimerGetTimerID_CallInstance = CMock_Guts_MemChain(Mock.pvTimerGetTimerID_CallInstance, cmock_guts_index);
  Mock.pvTimerGetTimerID_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_pvTimerGetTimerID(cmock_call_instance, xTimer);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pvTimerGetTimerID_AddCallback(CMOCK_pvTimerGetTimerID_CALLBACK Callback)
{
  Mock.pvTimerGetTimerID_IgnoreBool = (char)0;
  Mock.pvTimerGetTimerID_CallbackBool = (char)1;
  Mock.pvTimerGetTimerID_CallbackFunctionPointer = Callback;
}

void pvTimerGetTimerID_Stub(CMOCK_pvTimerGetTimerID_CALLBACK Callback)
{
  Mock.pvTimerGetTimerID_IgnoreBool = (char)0;
  Mock.pvTimerGetTimerID_CallbackBool = (char)0;
  Mock.pvTimerGetTimerID_CallbackFunctionPointer = Callback;
}

void pvTimerGetTimerID_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_pvTimerGetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_pvTimerGetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.pvTimerGetTimerID_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void vTimerSetTimerID(TimerHandle_t xTimer, void* pvNewID)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTimerSetTimerID);
  cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTimerSetTimerID_CallInstance);
  Mock.vTimerSetTimerID_CallInstance = CMock_Guts_MemNext(Mock.vTimerSetTimerID_CallInstance);
  if (Mock.vTimerSetTimerID_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vTimerSetTimerID_CallbackBool &&
      Mock.vTimerSetTimerID_CallbackFunctionPointer != NULL)
  {
    Mock.vTimerSetTimerID_CallbackFunctionPointer(xTimer, pvNewID, Mock.vTimerSetTimerID_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerID,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvNewID)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerID,CMockString_pvNewID);
    if (cmock_call_instance->Expected_pvNewID == NULL)
      { UNITY_TEST_ASSERT_NULL(pvNewID, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvNewID, pvNewID, cmock_call_instance->Expected_pvNewID_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.vTimerSetTimerID_CallbackFunctionPointer != NULL)
  {
    Mock.vTimerSetTimerID_CallbackFunctionPointer(xTimer, pvNewID, Mock.vTimerSetTimerID_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvNewID_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvNewID, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvNewID, (void*)cmock_call_instance->ReturnThruPtr_pvNewID_Val,
      cmock_call_instance->ReturnThruPtr_pvNewID_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTimerSetTimerID(CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, void* pvNewID, int pvNewID_Depth);
void CMockExpectParameters_vTimerSetTimerID(CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, void* pvNewID, int pvNewID_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
  cmock_call_instance->Expected_pvNewID = pvNewID;
  cmock_call_instance->Expected_pvNewID_Depth = pvNewID_Depth;
  cmock_call_instance->IgnoreArg_pvNewID = 0;
  cmock_call_instance->ReturnThruPtr_pvNewID_Used = 0;
}

void vTimerSetTimerID_CMockIgnore(void)
{
  Mock.vTimerSetTimerID_IgnoreBool = (char)1;
}

void vTimerSetTimerID_CMockStopIgnore(void)
{
  Mock.vTimerSetTimerID_IgnoreBool = (char)0;
}

void vTimerSetTimerID_CMockExpect(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, void* pvNewID)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetTimerID_CALL_INSTANCE));
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetTimerID_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetTimerID_CallInstance, cmock_guts_index);
  Mock.vTimerSetTimerID_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_vTimerSetTimerID(cmock_call_instance, xTimer, pvNewID, 1);
}

void vTimerSetTimerID_AddCallback(CMOCK_vTimerSetTimerID_CALLBACK Callback)
{
  Mock.vTimerSetTimerID_IgnoreBool = (char)0;
  Mock.vTimerSetTimerID_CallbackBool = (char)1;
  Mock.vTimerSetTimerID_CallbackFunctionPointer = Callback;
}

void vTimerSetTimerID_Stub(CMOCK_vTimerSetTimerID_CALLBACK Callback)
{
  Mock.vTimerSetTimerID_IgnoreBool = (char)0;
  Mock.vTimerSetTimerID_CallbackBool = (char)0;
  Mock.vTimerSetTimerID_CallbackFunctionPointer = Callback;
}

void vTimerSetTimerID_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, void* pvNewID, int pvNewID_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetTimerID_CALL_INSTANCE));
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetTimerID_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetTimerID_CallInstance, cmock_guts_index);
  Mock.vTimerSetTimerID_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_vTimerSetTimerID(cmock_call_instance, xTimer, pvNewID, pvNewID_Depth);
}

void vTimerSetTimerID_CMockReturnMemThruPtr_pvNewID(UNITY_LINE_TYPE cmock_line, void* pvNewID, size_t cmock_size)
{
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetTimerID_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvNewID_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvNewID_Val = pvNewID;
  cmock_call_instance->ReturnThruPtr_pvNewID_Size = cmock_size;
}

void vTimerSetTimerID_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetTimerID_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void vTimerSetTimerID_CMockIgnoreArg_pvNewID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetTimerID_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerID_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetTimerID_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvNewID = 1;
}

BaseType_t xTimerIsTimerActive(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerIsTimerActive);
  cmock_call_instance = (CMOCK_xTimerIsTimerActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerIsTimerActive_CallInstance);
  Mock.xTimerIsTimerActive_CallInstance = CMock_Guts_MemNext(Mock.xTimerIsTimerActive_CallInstance);
  if (Mock.xTimerIsTimerActive_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerIsTimerActive_FinalReturn;
    memcpy((void*)(&Mock.xTimerIsTimerActive_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTimerIsTimerActive_CallbackBool &&
      Mock.xTimerIsTimerActive_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xTimerIsTimerActive_CallbackFunctionPointer(xTimer, Mock.xTimerIsTimerActive_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_xTimerIsTimerActive,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.xTimerIsTimerActive_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTimerIsTimerActive_CallbackFunctionPointer(xTimer, Mock.xTimerIsTimerActive_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerIsTimerActive(CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer);
void CMockExpectParameters_xTimerIsTimerActive(CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void xTimerIsTimerActive_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerIsTimerActive_CALL_INSTANCE));
  CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerIsTimerActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerIsTimerActive_CallInstance = CMock_Guts_MemChain(Mock.xTimerIsTimerActive_CallInstance, cmock_guts_index);
  Mock.xTimerIsTimerActive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerIsTimerActive_IgnoreBool = (char)1;
}

void xTimerIsTimerActive_CMockStopIgnore(void)
{
  if(Mock.xTimerIsTimerActive_IgnoreBool)
    Mock.xTimerIsTimerActive_CallInstance = CMock_Guts_MemNext(Mock.xTimerIsTimerActive_CallInstance);
  Mock.xTimerIsTimerActive_IgnoreBool = (char)0;
}

void xTimerIsTimerActive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerIsTimerActive_CALL_INSTANCE));
  CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerIsTimerActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerIsTimerActive_CallInstance = CMock_Guts_MemChain(Mock.xTimerIsTimerActive_CallInstance, cmock_guts_index);
  Mock.xTimerIsTimerActive_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerIsTimerActive(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTimerIsTimerActive_AddCallback(CMOCK_xTimerIsTimerActive_CALLBACK Callback)
{
  Mock.xTimerIsTimerActive_IgnoreBool = (char)0;
  Mock.xTimerIsTimerActive_CallbackBool = (char)1;
  Mock.xTimerIsTimerActive_CallbackFunctionPointer = Callback;
}

void xTimerIsTimerActive_Stub(CMOCK_xTimerIsTimerActive_CALLBACK Callback)
{
  Mock.xTimerIsTimerActive_IgnoreBool = (char)0;
  Mock.xTimerIsTimerActive_CallbackBool = (char)0;
  Mock.xTimerIsTimerActive_CallbackFunctionPointer = Callback;
}

void xTimerIsTimerActive_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerIsTimerActive_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerIsTimerActive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerIsTimerActive_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

TaskHandle_t xTimerGetTimerDaemonTaskHandle(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGetTimerDaemonTaskHandle);
  cmock_call_instance = (CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance);
  Mock.xTimerGetTimerDaemonTaskHandle_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance);
  if (Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerGetTimerDaemonTaskHandle_FinalReturn;
    memcpy((void*)(&Mock.xTimerGetTimerDaemonTaskHandle_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TaskHandle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTimerGetTimerDaemonTaskHandle_CallbackBool &&
      Mock.xTimerGetTimerDaemonTaskHandle_CallbackFunctionPointer != NULL)
  {
    TaskHandle_t cmock_cb_ret = Mock.xTimerGetTimerDaemonTaskHandle_CallbackFunctionPointer(Mock.xTimerGetTimerDaemonTaskHandle_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.xTimerGetTimerDaemonTaskHandle_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTimerGetTimerDaemonTaskHandle_CallbackFunctionPointer(Mock.xTimerGetTimerDaemonTaskHandle_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTimerGetTimerDaemonTaskHandle_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE));
  CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetTimerDaemonTaskHandle_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance, cmock_guts_index);
  Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool = (char)1;
}

void xTimerGetTimerDaemonTaskHandle_CMockStopIgnore(void)
{
  if(Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool)
    Mock.xTimerGetTimerDaemonTaskHandle_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance);
  Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool = (char)0;
}

void xTimerGetTimerDaemonTaskHandle_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TaskHandle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE));
  CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetTimerDaemonTaskHandle_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetTimerDaemonTaskHandle_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetTimerDaemonTaskHandle_CallInstance, cmock_guts_index);
  Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TaskHandle_t[sizeof(cmock_to_return) == sizeof(TaskHandle_t) ? 1 : -1])); /* add TaskHandle_t to :treat_as_array if this causes an error */
}

void xTimerGetTimerDaemonTaskHandle_AddCallback(CMOCK_xTimerGetTimerDaemonTaskHandle_CALLBACK Callback)
{
  Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool = (char)0;
  Mock.xTimerGetTimerDaemonTaskHandle_CallbackBool = (char)1;
  Mock.xTimerGetTimerDaemonTaskHandle_CallbackFunctionPointer = Callback;
}

void xTimerGetTimerDaemonTaskHandle_Stub(CMOCK_xTimerGetTimerDaemonTaskHandle_CALLBACK Callback)
{
  Mock.xTimerGetTimerDaemonTaskHandle_IgnoreBool = (char)0;
  Mock.xTimerGetTimerDaemonTaskHandle_CallbackBool = (char)0;
  Mock.xTimerGetTimerDaemonTaskHandle_CallbackFunctionPointer = Callback;
}

BaseType_t xTimerPendFunctionCallFromISR(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCallFromISR);
  cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerPendFunctionCallFromISR_CallInstance);
  Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTimerPendFunctionCallFromISR_CallInstance);
  if (Mock.xTimerPendFunctionCallFromISR_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerPendFunctionCallFromISR_FinalReturn;
    memcpy((void*)(&Mock.xTimerPendFunctionCallFromISR_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTimerPendFunctionCallFromISR_CallbackBool &&
      Mock.xTimerPendFunctionCallFromISR_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xTimerPendFunctionCallFromISR_CallbackFunctionPointer(xFunctionToPend, pvParameter1, ulParameter2, pxHigherPriorityTaskWoken, Mock.xTimerPendFunctionCallFromISR_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xFunctionToPend)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_xFunctionToPend);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend), sizeof(PendedFunction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvParameter1)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_pvParameter1);
    if (cmock_call_instance->Expected_pvParameter1 == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameter1, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameter1, pvParameter1, cmock_call_instance->Expected_pvParameter1_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ulParameter2)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_ulParameter2);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulParameter2, ulParameter2, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCallFromISR,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.xTimerPendFunctionCallFromISR_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTimerPendFunctionCallFromISR_CallbackFunctionPointer(xFunctionToPend, pvParameter1, ulParameter2, pxHigherPriorityTaskWoken, Mock.xTimerPendFunctionCallFromISR_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvParameter1_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvParameter1, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvParameter1, (void*)cmock_call_instance->ReturnThruPtr_pvParameter1_Val,
      cmock_call_instance->ReturnThruPtr_pvParameter1_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxHigherPriorityTaskWoken, (void*)cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val,
      cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerPendFunctionCallFromISR(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance, PendedFunction_t xFunctionToPend, void* pvParameter1, int pvParameter1_Depth, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth);
void CMockExpectParameters_xTimerPendFunctionCallFromISR(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance, PendedFunction_t xFunctionToPend, void* pvParameter1, int pvParameter1_Depth, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend),
         sizeof(PendedFunction_t[sizeof(xFunctionToPend) == sizeof(PendedFunction_t) ? 1 : -1])); /* add PendedFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xFunctionToPend = 0;
  cmock_call_instance->Expected_pvParameter1 = pvParameter1;
  cmock_call_instance->Expected_pvParameter1_Depth = pvParameter1_Depth;
  cmock_call_instance->IgnoreArg_pvParameter1 = 0;
  cmock_call_instance->ReturnThruPtr_pvParameter1_Used = 0;
  cmock_call_instance->Expected_ulParameter2 = ulParameter2;
  cmock_call_instance->IgnoreArg_ulParameter2 = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 0;
}

void xTimerPendFunctionCallFromISR_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCallFromISR_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)1;
}

void xTimerPendFunctionCallFromISR_CMockStopIgnore(void)
{
  if(Mock.xTimerPendFunctionCallFromISR_IgnoreBool)
    Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemNext(Mock.xTimerPendFunctionCallFromISR_CallInstance);
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)0;
}

void xTimerPendFunctionCallFromISR_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCallFromISR_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerPendFunctionCallFromISR(cmock_call_instance, xFunctionToPend, pvParameter1, 1, ulParameter2, pxHigherPriorityTaskWoken, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTimerPendFunctionCallFromISR_AddCallback(CMOCK_xTimerPendFunctionCallFromISR_CALLBACK Callback)
{
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)0;
  Mock.xTimerPendFunctionCallFromISR_CallbackBool = (char)1;
  Mock.xTimerPendFunctionCallFromISR_CallbackFunctionPointer = Callback;
}

void xTimerPendFunctionCallFromISR_Stub(CMOCK_xTimerPendFunctionCallFromISR_CALLBACK Callback)
{
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)0;
  Mock.xTimerPendFunctionCallFromISR_CallbackBool = (char)0;
  Mock.xTimerPendFunctionCallFromISR_CallbackFunctionPointer = Callback;
}

void xTimerPendFunctionCallFromISR_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, PendedFunction_t xFunctionToPend, void* pvParameter1, int pvParameter1_Depth, uint32_t ulParameter2, BaseType_t* pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCallFromISR_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCallFromISR_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCallFromISR_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerPendFunctionCallFromISR(cmock_call_instance, xFunctionToPend, pvParameter1, pvParameter1_Depth, ulParameter2, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTimerPendFunctionCallFromISR_CMockReturnMemThruPtr_pvParameter1(UNITY_LINE_TYPE cmock_line, void* pvParameter1, size_t cmock_size)
{
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCallFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvParameter1_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvParameter1_Val = pvParameter1;
  cmock_call_instance->ReturnThruPtr_pvParameter1_Size = cmock_size;
}

void xTimerPendFunctionCallFromISR_CMockReturnMemThruPtr_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line, BaseType_t* pxHigherPriorityTaskWoken, size_t cmock_size)
{
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCallFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val = pxHigherPriorityTaskWoken;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size = cmock_size;
}

void xTimerPendFunctionCallFromISR_CMockIgnoreArg_xFunctionToPend(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCallFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xFunctionToPend = 1;
}

void xTimerPendFunctionCallFromISR_CMockIgnoreArg_pvParameter1(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCallFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvParameter1 = 1;
}

void xTimerPendFunctionCallFromISR_CMockIgnoreArg_ulParameter2(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCallFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulParameter2 = 1;
}

void xTimerPendFunctionCallFromISR_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCallFromISR_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCallFromISR_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

BaseType_t xTimerPendFunctionCall(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerPendFunctionCall);
  cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerPendFunctionCall_CallInstance);
  Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemNext(Mock.xTimerPendFunctionCall_CallInstance);
  if (Mock.xTimerPendFunctionCall_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerPendFunctionCall_FinalReturn;
    memcpy((void*)(&Mock.xTimerPendFunctionCall_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTimerPendFunctionCall_CallbackBool &&
      Mock.xTimerPendFunctionCall_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xTimerPendFunctionCall_CallbackFunctionPointer(xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait, Mock.xTimerPendFunctionCall_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xFunctionToPend)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_xFunctionToPend);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend), sizeof(PendedFunction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pvParameter1)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_pvParameter1);
    if (cmock_call_instance->Expected_pvParameter1 == NULL)
      { UNITY_TEST_ASSERT_NULL(pvParameter1, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_pvParameter1, pvParameter1, cmock_call_instance->Expected_pvParameter1_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_ulParameter2)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_ulParameter2);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_ulParameter2, ulParameter2, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xTimerPendFunctionCall,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.xTimerPendFunctionCall_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTimerPendFunctionCall_CallbackFunctionPointer(xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait, Mock.xTimerPendFunctionCall_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pvParameter1_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pvParameter1, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pvParameter1, (void*)cmock_call_instance->ReturnThruPtr_pvParameter1_Val,
      cmock_call_instance->ReturnThruPtr_pvParameter1_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerPendFunctionCall(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance, PendedFunction_t xFunctionToPend, void* pvParameter1, int pvParameter1_Depth, uint32_t ulParameter2, TickType_t xTicksToWait);
void CMockExpectParameters_xTimerPendFunctionCall(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance, PendedFunction_t xFunctionToPend, void* pvParameter1, int pvParameter1_Depth, uint32_t ulParameter2, TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xFunctionToPend), (void*)(&xFunctionToPend),
         sizeof(PendedFunction_t[sizeof(xFunctionToPend) == sizeof(PendedFunction_t) ? 1 : -1])); /* add PendedFunction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xFunctionToPend = 0;
  cmock_call_instance->Expected_pvParameter1 = pvParameter1;
  cmock_call_instance->Expected_pvParameter1_Depth = pvParameter1_Depth;
  cmock_call_instance->IgnoreArg_pvParameter1 = 0;
  cmock_call_instance->ReturnThruPtr_pvParameter1_Used = 0;
  cmock_call_instance->Expected_ulParameter2 = ulParameter2;
  cmock_call_instance->IgnoreArg_ulParameter2 = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xTimerPendFunctionCall_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCall_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)1;
}

void xTimerPendFunctionCall_CMockStopIgnore(void)
{
  if(Mock.xTimerPendFunctionCall_IgnoreBool)
    Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemNext(Mock.xTimerPendFunctionCall_CallInstance);
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)0;
}

void xTimerPendFunctionCall_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCall_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerPendFunctionCall(cmock_call_instance, xFunctionToPend, pvParameter1, 1, ulParameter2, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTimerPendFunctionCall_AddCallback(CMOCK_xTimerPendFunctionCall_CALLBACK Callback)
{
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)0;
  Mock.xTimerPendFunctionCall_CallbackBool = (char)1;
  Mock.xTimerPendFunctionCall_CallbackFunctionPointer = Callback;
}

void xTimerPendFunctionCall_Stub(CMOCK_xTimerPendFunctionCall_CALLBACK Callback)
{
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)0;
  Mock.xTimerPendFunctionCall_CallbackBool = (char)0;
  Mock.xTimerPendFunctionCall_CallbackFunctionPointer = Callback;
}

void xTimerPendFunctionCall_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, PendedFunction_t xFunctionToPend, void* pvParameter1, int pvParameter1_Depth, uint32_t ulParameter2, TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerPendFunctionCall_CALL_INSTANCE));
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerPendFunctionCall_CallInstance = CMock_Guts_MemChain(Mock.xTimerPendFunctionCall_CallInstance, cmock_guts_index);
  Mock.xTimerPendFunctionCall_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerPendFunctionCall(cmock_call_instance, xFunctionToPend, pvParameter1, pvParameter1_Depth, ulParameter2, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTimerPendFunctionCall_CMockReturnMemThruPtr_pvParameter1(UNITY_LINE_TYPE cmock_line, void* pvParameter1, size_t cmock_size)
{
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCall_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pvParameter1_Used = 1;
  cmock_call_instance->ReturnThruPtr_pvParameter1_Val = pvParameter1;
  cmock_call_instance->ReturnThruPtr_pvParameter1_Size = cmock_size;
}

void xTimerPendFunctionCall_CMockIgnoreArg_xFunctionToPend(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCall_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xFunctionToPend = 1;
}

void xTimerPendFunctionCall_CMockIgnoreArg_pvParameter1(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCall_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pvParameter1 = 1;
}

void xTimerPendFunctionCall_CMockIgnoreArg_ulParameter2(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCall_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ulParameter2 = 1;
}

void xTimerPendFunctionCall_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerPendFunctionCall_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerPendFunctionCall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerPendFunctionCall_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

const char* pcTimerGetName(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pcTimerGetName);
  cmock_call_instance = (CMOCK_pcTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pcTimerGetName_CallInstance);
  Mock.pcTimerGetName_CallInstance = CMock_Guts_MemNext(Mock.pcTimerGetName_CallInstance);
  if (Mock.pcTimerGetName_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.pcTimerGetName_FinalReturn;
    Mock.pcTimerGetName_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.pcTimerGetName_CallbackBool &&
      Mock.pcTimerGetName_CallbackFunctionPointer != NULL)
  {
    const char* cmock_cb_ret = Mock.pcTimerGetName_CallbackFunctionPointer(xTimer, Mock.pcTimerGetName_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_pcTimerGetName,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.pcTimerGetName_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.pcTimerGetName_CallbackFunctionPointer(xTimer, Mock.pcTimerGetName_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_pcTimerGetName(CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer);
void CMockExpectParameters_pcTimerGetName(CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void pcTimerGetName_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, const char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcTimerGetName_CALL_INSTANCE));
  CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcTimerGetName_CallInstance = CMock_Guts_MemChain(Mock.pcTimerGetName_CallInstance, cmock_guts_index);
  Mock.pcTimerGetName_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.pcTimerGetName_IgnoreBool = (char)1;
}

void pcTimerGetName_CMockStopIgnore(void)
{
  if(Mock.pcTimerGetName_IgnoreBool)
    Mock.pcTimerGetName_CallInstance = CMock_Guts_MemNext(Mock.pcTimerGetName_CallInstance);
  Mock.pcTimerGetName_IgnoreBool = (char)0;
}

void pcTimerGetName_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, const char* cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pcTimerGetName_CALL_INSTANCE));
  CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pcTimerGetName_CallInstance = CMock_Guts_MemChain(Mock.pcTimerGetName_CallInstance, cmock_guts_index);
  Mock.pcTimerGetName_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_pcTimerGetName(cmock_call_instance, xTimer);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void pcTimerGetName_AddCallback(CMOCK_pcTimerGetName_CALLBACK Callback)
{
  Mock.pcTimerGetName_IgnoreBool = (char)0;
  Mock.pcTimerGetName_CallbackBool = (char)1;
  Mock.pcTimerGetName_CallbackFunctionPointer = Callback;
}

void pcTimerGetName_Stub(CMOCK_pcTimerGetName_CALLBACK Callback)
{
  Mock.pcTimerGetName_IgnoreBool = (char)0;
  Mock.pcTimerGetName_CallbackBool = (char)0;
  Mock.pcTimerGetName_CallbackFunctionPointer = Callback;
}

void pcTimerGetName_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_pcTimerGetName_CALL_INSTANCE* cmock_call_instance = (CMOCK_pcTimerGetName_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.pcTimerGetName_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void vTimerSetReloadMode(TimerHandle_t xTimer, const UBaseType_t uxAutoReload)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTimerSetReloadMode);
  cmock_call_instance = (CMOCK_vTimerSetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTimerSetReloadMode_CallInstance);
  Mock.vTimerSetReloadMode_CallInstance = CMock_Guts_MemNext(Mock.vTimerSetReloadMode_CallInstance);
  if (Mock.vTimerSetReloadMode_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vTimerSetReloadMode_CallbackBool &&
      Mock.vTimerSetReloadMode_CallbackFunctionPointer != NULL)
  {
    Mock.vTimerSetReloadMode_CallbackFunctionPointer(xTimer, uxAutoReload, Mock.vTimerSetReloadMode_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetReloadMode,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxAutoReload)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetReloadMode,CMockString_uxAutoReload);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.vTimerSetReloadMode_CallbackFunctionPointer != NULL)
  {
    Mock.vTimerSetReloadMode_CallbackFunctionPointer(xTimer, uxAutoReload, Mock.vTimerSetReloadMode_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTimerSetReloadMode(CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, const UBaseType_t uxAutoReload);
void CMockExpectParameters_vTimerSetReloadMode(CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, const UBaseType_t uxAutoReload)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxAutoReload), (void*)(&uxAutoReload),
         sizeof(UBaseType_t[sizeof(uxAutoReload) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxAutoReload = 0;
}

void vTimerSetReloadMode_CMockIgnore(void)
{
  Mock.vTimerSetReloadMode_IgnoreBool = (char)1;
}

void vTimerSetReloadMode_CMockStopIgnore(void)
{
  Mock.vTimerSetReloadMode_IgnoreBool = (char)0;
}

void vTimerSetReloadMode_CMockExpect(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, const UBaseType_t uxAutoReload)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetReloadMode_CALL_INSTANCE));
  CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetReloadMode_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetReloadMode_CallInstance, cmock_guts_index);
  Mock.vTimerSetReloadMode_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_vTimerSetReloadMode(cmock_call_instance, xTimer, uxAutoReload);
}

void vTimerSetReloadMode_AddCallback(CMOCK_vTimerSetReloadMode_CALLBACK Callback)
{
  Mock.vTimerSetReloadMode_IgnoreBool = (char)0;
  Mock.vTimerSetReloadMode_CallbackBool = (char)1;
  Mock.vTimerSetReloadMode_CallbackFunctionPointer = Callback;
}

void vTimerSetReloadMode_Stub(CMOCK_vTimerSetReloadMode_CALLBACK Callback)
{
  Mock.vTimerSetReloadMode_IgnoreBool = (char)0;
  Mock.vTimerSetReloadMode_CallbackBool = (char)0;
  Mock.vTimerSetReloadMode_CallbackFunctionPointer = Callback;
}

void vTimerSetReloadMode_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetReloadMode_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void vTimerSetReloadMode_CMockIgnoreArg_uxAutoReload(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetReloadMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetReloadMode_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxAutoReload = 1;
}

UBaseType_t uxTimerGetReloadMode(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTimerGetReloadMode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTimerGetReloadMode);
  cmock_call_instance = (CMOCK_uxTimerGetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTimerGetReloadMode_CallInstance);
  Mock.uxTimerGetReloadMode_CallInstance = CMock_Guts_MemNext(Mock.uxTimerGetReloadMode_CallInstance);
  if (Mock.uxTimerGetReloadMode_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxTimerGetReloadMode_FinalReturn;
    memcpy((void*)(&Mock.uxTimerGetReloadMode_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(UBaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxTimerGetReloadMode_CallbackBool &&
      Mock.uxTimerGetReloadMode_CallbackFunctionPointer != NULL)
  {
    UBaseType_t cmock_cb_ret = Mock.uxTimerGetReloadMode_CallbackFunctionPointer(xTimer, Mock.uxTimerGetReloadMode_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_uxTimerGetReloadMode,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.uxTimerGetReloadMode_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxTimerGetReloadMode_CallbackFunctionPointer(xTimer, Mock.uxTimerGetReloadMode_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTimerGetReloadMode(CMOCK_uxTimerGetReloadMode_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer);
void CMockExpectParameters_uxTimerGetReloadMode(CMOCK_uxTimerGetReloadMode_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void uxTimerGetReloadMode_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTimerGetReloadMode_CALL_INSTANCE));
  CMOCK_uxTimerGetReloadMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTimerGetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTimerGetReloadMode_CallInstance = CMock_Guts_MemChain(Mock.uxTimerGetReloadMode_CallInstance, cmock_guts_index);
  Mock.uxTimerGetReloadMode_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxTimerGetReloadMode_IgnoreBool = (char)1;
}

void uxTimerGetReloadMode_CMockStopIgnore(void)
{
  if(Mock.uxTimerGetReloadMode_IgnoreBool)
    Mock.uxTimerGetReloadMode_CallInstance = CMock_Guts_MemNext(Mock.uxTimerGetReloadMode_CallInstance);
  Mock.uxTimerGetReloadMode_IgnoreBool = (char)0;
}

void uxTimerGetReloadMode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTimerGetReloadMode_CALL_INSTANCE));
  CMOCK_uxTimerGetReloadMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTimerGetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTimerGetReloadMode_CallInstance = CMock_Guts_MemChain(Mock.uxTimerGetReloadMode_CallInstance, cmock_guts_index);
  Mock.uxTimerGetReloadMode_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_uxTimerGetReloadMode(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxTimerGetReloadMode_AddCallback(CMOCK_uxTimerGetReloadMode_CALLBACK Callback)
{
  Mock.uxTimerGetReloadMode_IgnoreBool = (char)0;
  Mock.uxTimerGetReloadMode_CallbackBool = (char)1;
  Mock.uxTimerGetReloadMode_CallbackFunctionPointer = Callback;
}

void uxTimerGetReloadMode_Stub(CMOCK_uxTimerGetReloadMode_CALLBACK Callback)
{
  Mock.uxTimerGetReloadMode_IgnoreBool = (char)0;
  Mock.uxTimerGetReloadMode_CallbackBool = (char)0;
  Mock.uxTimerGetReloadMode_CallbackFunctionPointer = Callback;
}

void uxTimerGetReloadMode_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTimerGetReloadMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTimerGetReloadMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTimerGetReloadMode_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

TickType_t xTimerGetPeriod(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGetPeriod);
  cmock_call_instance = (CMOCK_xTimerGetPeriod_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGetPeriod_CallInstance);
  Mock.xTimerGetPeriod_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetPeriod_CallInstance);
  if (Mock.xTimerGetPeriod_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerGetPeriod_FinalReturn;
    memcpy((void*)(&Mock.xTimerGetPeriod_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TickType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTimerGetPeriod_CallbackBool &&
      Mock.xTimerGetPeriod_CallbackFunctionPointer != NULL)
  {
    TickType_t cmock_cb_ret = Mock.xTimerGetPeriod_CallbackFunctionPointer(xTimer, Mock.xTimerGetPeriod_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGetPeriod,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.xTimerGetPeriod_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTimerGetPeriod_CallbackFunctionPointer(xTimer, Mock.xTimerGetPeriod_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerGetPeriod(CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer);
void CMockExpectParameters_xTimerGetPeriod(CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void xTimerGetPeriod_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetPeriod_CALL_INSTANCE));
  CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetPeriod_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetPeriod_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetPeriod_CallInstance, cmock_guts_index);
  Mock.xTimerGetPeriod_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerGetPeriod_IgnoreBool = (char)1;
}

void xTimerGetPeriod_CMockStopIgnore(void)
{
  if(Mock.xTimerGetPeriod_IgnoreBool)
    Mock.xTimerGetPeriod_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetPeriod_CallInstance);
  Mock.xTimerGetPeriod_IgnoreBool = (char)0;
}

void xTimerGetPeriod_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetPeriod_CALL_INSTANCE));
  CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetPeriod_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetPeriod_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetPeriod_CallInstance, cmock_guts_index);
  Mock.xTimerGetPeriod_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerGetPeriod(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xTimerGetPeriod_AddCallback(CMOCK_xTimerGetPeriod_CALLBACK Callback)
{
  Mock.xTimerGetPeriod_IgnoreBool = (char)0;
  Mock.xTimerGetPeriod_CallbackBool = (char)1;
  Mock.xTimerGetPeriod_CallbackFunctionPointer = Callback;
}

void xTimerGetPeriod_Stub(CMOCK_xTimerGetPeriod_CALLBACK Callback)
{
  Mock.xTimerGetPeriod_IgnoreBool = (char)0;
  Mock.xTimerGetPeriod_CallbackBool = (char)0;
  Mock.xTimerGetPeriod_CallbackFunctionPointer = Callback;
}

void xTimerGetPeriod_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGetPeriod_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetPeriod_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGetPeriod_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

TickType_t xTimerGetExpiryTime(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGetExpiryTime);
  cmock_call_instance = (CMOCK_xTimerGetExpiryTime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGetExpiryTime_CallInstance);
  Mock.xTimerGetExpiryTime_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetExpiryTime_CallInstance);
  if (Mock.xTimerGetExpiryTime_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerGetExpiryTime_FinalReturn;
    memcpy((void*)(&Mock.xTimerGetExpiryTime_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(TickType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTimerGetExpiryTime_CallbackBool &&
      Mock.xTimerGetExpiryTime_CallbackFunctionPointer != NULL)
  {
    TickType_t cmock_cb_ret = Mock.xTimerGetExpiryTime_CallbackFunctionPointer(xTimer, Mock.xTimerGetExpiryTime_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGetExpiryTime,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.xTimerGetExpiryTime_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTimerGetExpiryTime_CallbackFunctionPointer(xTimer, Mock.xTimerGetExpiryTime_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerGetExpiryTime(CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer);
void CMockExpectParameters_xTimerGetExpiryTime(CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void xTimerGetExpiryTime_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetExpiryTime_CALL_INSTANCE));
  CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetExpiryTime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetExpiryTime_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetExpiryTime_CallInstance, cmock_guts_index);
  Mock.xTimerGetExpiryTime_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerGetExpiryTime_IgnoreBool = (char)1;
}

void xTimerGetExpiryTime_CMockStopIgnore(void)
{
  if(Mock.xTimerGetExpiryTime_IgnoreBool)
    Mock.xTimerGetExpiryTime_CallInstance = CMock_Guts_MemNext(Mock.xTimerGetExpiryTime_CallInstance);
  Mock.xTimerGetExpiryTime_IgnoreBool = (char)0;
}

void xTimerGetExpiryTime_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, TickType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGetExpiryTime_CALL_INSTANCE));
  CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetExpiryTime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGetExpiryTime_CallInstance = CMock_Guts_MemChain(Mock.xTimerGetExpiryTime_CallInstance, cmock_guts_index);
  Mock.xTimerGetExpiryTime_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerGetExpiryTime(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(TickType_t[sizeof(cmock_to_return) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
}

void xTimerGetExpiryTime_AddCallback(CMOCK_xTimerGetExpiryTime_CALLBACK Callback)
{
  Mock.xTimerGetExpiryTime_IgnoreBool = (char)0;
  Mock.xTimerGetExpiryTime_CallbackBool = (char)1;
  Mock.xTimerGetExpiryTime_CallbackFunctionPointer = Callback;
}

void xTimerGetExpiryTime_Stub(CMOCK_xTimerGetExpiryTime_CALLBACK Callback)
{
  Mock.xTimerGetExpiryTime_IgnoreBool = (char)0;
  Mock.xTimerGetExpiryTime_CallbackBool = (char)0;
  Mock.xTimerGetExpiryTime_CallbackFunctionPointer = Callback;
}

void xTimerGetExpiryTime_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGetExpiryTime_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGetExpiryTime_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGetExpiryTime_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

BaseType_t xTimerCreateTimerTask(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerCreateTimerTask_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerCreateTimerTask);
  cmock_call_instance = (CMOCK_xTimerCreateTimerTask_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerCreateTimerTask_CallInstance);
  Mock.xTimerCreateTimerTask_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreateTimerTask_CallInstance);
  if (Mock.xTimerCreateTimerTask_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerCreateTimerTask_FinalReturn;
    memcpy((void*)(&Mock.xTimerCreateTimerTask_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTimerCreateTimerTask_CallbackBool &&
      Mock.xTimerCreateTimerTask_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xTimerCreateTimerTask_CallbackFunctionPointer(Mock.xTimerCreateTimerTask_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.xTimerCreateTimerTask_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTimerCreateTimerTask_CallbackFunctionPointer(Mock.xTimerCreateTimerTask_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void xTimerCreateTimerTask_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateTimerTask_CALL_INSTANCE));
  CMOCK_xTimerCreateTimerTask_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateTimerTask_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateTimerTask_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateTimerTask_CallInstance, cmock_guts_index);
  Mock.xTimerCreateTimerTask_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerCreateTimerTask_IgnoreBool = (char)1;
}

void xTimerCreateTimerTask_CMockStopIgnore(void)
{
  if(Mock.xTimerCreateTimerTask_IgnoreBool)
    Mock.xTimerCreateTimerTask_CallInstance = CMock_Guts_MemNext(Mock.xTimerCreateTimerTask_CallInstance);
  Mock.xTimerCreateTimerTask_IgnoreBool = (char)0;
}

void xTimerCreateTimerTask_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerCreateTimerTask_CALL_INSTANCE));
  CMOCK_xTimerCreateTimerTask_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerCreateTimerTask_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerCreateTimerTask_CallInstance = CMock_Guts_MemChain(Mock.xTimerCreateTimerTask_CallInstance, cmock_guts_index);
  Mock.xTimerCreateTimerTask_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTimerCreateTimerTask_AddCallback(CMOCK_xTimerCreateTimerTask_CALLBACK Callback)
{
  Mock.xTimerCreateTimerTask_IgnoreBool = (char)0;
  Mock.xTimerCreateTimerTask_CallbackBool = (char)1;
  Mock.xTimerCreateTimerTask_CallbackFunctionPointer = Callback;
}

void xTimerCreateTimerTask_Stub(CMOCK_xTimerCreateTimerTask_CALLBACK Callback)
{
  Mock.xTimerCreateTimerTask_IgnoreBool = (char)0;
  Mock.xTimerCreateTimerTask_CallbackBool = (char)0;
  Mock.xTimerCreateTimerTask_CallbackFunctionPointer = Callback;
}

BaseType_t xTimerGenericCommand(TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_xTimerGenericCommand);
  cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.xTimerGenericCommand_CallInstance);
  Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemNext(Mock.xTimerGenericCommand_CallInstance);
  if (Mock.xTimerGenericCommand_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.xTimerGenericCommand_FinalReturn;
    memcpy((void*)(&Mock.xTimerGenericCommand_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(BaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.xTimerGenericCommand_CallbackBool &&
      Mock.xTimerGenericCommand_CallbackFunctionPointer != NULL)
  {
    BaseType_t cmock_cb_ret = Mock.xTimerGenericCommand_CallbackFunctionPointer(xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, xTicksToWait, Mock.xTimerGenericCommand_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xCommandID)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xCommandID);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xCommandID), (void*)(&xCommandID), sizeof(BaseType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_xOptionalValue)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xOptionalValue);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xOptionalValue), (void*)(&xOptionalValue), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_pxHigherPriorityTaskWoken);
    if (cmock_call_instance->Expected_pxHigherPriorityTaskWoken == NULL)
      { UNITY_TEST_ASSERT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pxHigherPriorityTaskWoken), (void*)(pxHigherPriorityTaskWoken), sizeof(BaseType_t), cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_xTicksToWait)
  {
    UNITY_SET_DETAILS(CMockString_xTimerGenericCommand,CMockString_xTicksToWait);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait), sizeof(TickType_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.xTimerGenericCommand_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.xTimerGenericCommand_CallbackFunctionPointer(xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, xTicksToWait, Mock.xTimerGenericCommand_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pxHigherPriorityTaskWoken, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pxHigherPriorityTaskWoken, (void*)cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val,
      cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_xTimerGenericCommand(CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, const TickType_t xTicksToWait);
void CMockExpectParameters_xTimerGenericCommand(CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, const TickType_t xTicksToWait)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xCommandID), (void*)(&xCommandID),
         sizeof(BaseType_t[sizeof(xCommandID) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xCommandID = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xOptionalValue), (void*)(&xOptionalValue),
         sizeof(TickType_t[sizeof(xOptionalValue) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xOptionalValue = 0;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken = pxHigherPriorityTaskWoken;
  cmock_call_instance->Expected_pxHigherPriorityTaskWoken_Depth = pxHigherPriorityTaskWoken_Depth;
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 0;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 0;
  memcpy((void*)(&cmock_call_instance->Expected_xTicksToWait), (void*)(&xTicksToWait),
         sizeof(TickType_t[sizeof(xTicksToWait) == sizeof(TickType_t) ? 1 : -1])); /* add TickType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTicksToWait = 0;
}

void xTimerGenericCommand_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGenericCommand_CALL_INSTANCE));
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemChain(Mock.xTimerGenericCommand_CallInstance, cmock_guts_index);
  Mock.xTimerGenericCommand_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.xTimerGenericCommand_IgnoreBool = (char)1;
}

void xTimerGenericCommand_CMockStopIgnore(void)
{
  if(Mock.xTimerGenericCommand_IgnoreBool)
    Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemNext(Mock.xTimerGenericCommand_CallInstance);
  Mock.xTimerGenericCommand_IgnoreBool = (char)0;
}

void xTimerGenericCommand_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGenericCommand_CALL_INSTANCE));
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemChain(Mock.xTimerGenericCommand_CallInstance, cmock_guts_index);
  Mock.xTimerGenericCommand_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerGenericCommand(cmock_call_instance, xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, 1, xTicksToWait);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(BaseType_t[sizeof(cmock_to_return) == sizeof(BaseType_t) ? 1 : -1])); /* add BaseType_t to :treat_as_array if this causes an error */
}

void xTimerGenericCommand_AddCallback(CMOCK_xTimerGenericCommand_CALLBACK Callback)
{
  Mock.xTimerGenericCommand_IgnoreBool = (char)0;
  Mock.xTimerGenericCommand_CallbackBool = (char)1;
  Mock.xTimerGenericCommand_CallbackFunctionPointer = Callback;
}

void xTimerGenericCommand_Stub(CMOCK_xTimerGenericCommand_CALLBACK Callback)
{
  Mock.xTimerGenericCommand_IgnoreBool = (char)0;
  Mock.xTimerGenericCommand_CallbackBool = (char)0;
  Mock.xTimerGenericCommand_CallbackFunctionPointer = Callback;
}

void xTimerGenericCommand_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t* const pxHigherPriorityTaskWoken, int pxHigherPriorityTaskWoken_Depth, const TickType_t xTicksToWait, BaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_xTimerGenericCommand_CALL_INSTANCE));
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.xTimerGenericCommand_CallInstance = CMock_Guts_MemChain(Mock.xTimerGenericCommand_CallInstance, cmock_guts_index);
  Mock.xTimerGenericCommand_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_xTimerGenericCommand(cmock_call_instance, xTimer, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, pxHigherPriorityTaskWoken_Depth, xTicksToWait);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void xTimerGenericCommand_CMockReturnMemThruPtr_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line, BaseType_t* pxHigherPriorityTaskWoken, size_t cmock_size)
{
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGenericCommand_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Used = 1;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Val = pxHigherPriorityTaskWoken;
  cmock_call_instance->ReturnThruPtr_pxHigherPriorityTaskWoken_Size = cmock_size;
}

void xTimerGenericCommand_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGenericCommand_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void xTimerGenericCommand_CMockIgnoreArg_xCommandID(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGenericCommand_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xCommandID = 1;
}

void xTimerGenericCommand_CMockIgnoreArg_xOptionalValue(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGenericCommand_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xOptionalValue = 1;
}

void xTimerGenericCommand_CMockIgnoreArg_pxHigherPriorityTaskWoken(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGenericCommand_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pxHigherPriorityTaskWoken = 1;
}

void xTimerGenericCommand_CMockIgnoreArg_xTicksToWait(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_xTimerGenericCommand_CALL_INSTANCE* cmock_call_instance = (CMOCK_xTimerGenericCommand_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.xTimerGenericCommand_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTicksToWait = 1;
}

void vTimerSetTimerNumber(TimerHandle_t xTimer, UBaseType_t uxTimerNumber)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vTimerSetTimerNumber);
  cmock_call_instance = (CMOCK_vTimerSetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vTimerSetTimerNumber_CallInstance);
  Mock.vTimerSetTimerNumber_CallInstance = CMock_Guts_MemNext(Mock.vTimerSetTimerNumber_CallInstance);
  if (Mock.vTimerSetTimerNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vTimerSetTimerNumber_CallbackBool &&
      Mock.vTimerSetTimerNumber_CallbackFunctionPointer != NULL)
  {
    Mock.vTimerSetTimerNumber_CallbackFunctionPointer(xTimer, uxTimerNumber, Mock.vTimerSetTimerNumber_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerNumber,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_uxTimerNumber)
  {
    UNITY_SET_DETAILS(CMockString_vTimerSetTimerNumber,CMockString_uxTimerNumber);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_uxTimerNumber), (void*)(&uxTimerNumber), sizeof(UBaseType_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.vTimerSetTimerNumber_CallbackFunctionPointer != NULL)
  {
    Mock.vTimerSetTimerNumber_CallbackFunctionPointer(xTimer, uxTimerNumber, Mock.vTimerSetTimerNumber_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vTimerSetTimerNumber(CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, UBaseType_t uxTimerNumber);
void CMockExpectParameters_vTimerSetTimerNumber(CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer, UBaseType_t uxTimerNumber)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
  memcpy((void*)(&cmock_call_instance->Expected_uxTimerNumber), (void*)(&uxTimerNumber),
         sizeof(UBaseType_t[sizeof(uxTimerNumber) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_uxTimerNumber = 0;
}

void vTimerSetTimerNumber_CMockIgnore(void)
{
  Mock.vTimerSetTimerNumber_IgnoreBool = (char)1;
}

void vTimerSetTimerNumber_CMockStopIgnore(void)
{
  Mock.vTimerSetTimerNumber_IgnoreBool = (char)0;
}

void vTimerSetTimerNumber_CMockExpect(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, UBaseType_t uxTimerNumber)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vTimerSetTimerNumber_CALL_INSTANCE));
  CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vTimerSetTimerNumber_CallInstance = CMock_Guts_MemChain(Mock.vTimerSetTimerNumber_CallInstance, cmock_guts_index);
  Mock.vTimerSetTimerNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_vTimerSetTimerNumber(cmock_call_instance, xTimer, uxTimerNumber);
}

void vTimerSetTimerNumber_AddCallback(CMOCK_vTimerSetTimerNumber_CALLBACK Callback)
{
  Mock.vTimerSetTimerNumber_IgnoreBool = (char)0;
  Mock.vTimerSetTimerNumber_CallbackBool = (char)1;
  Mock.vTimerSetTimerNumber_CallbackFunctionPointer = Callback;
}

void vTimerSetTimerNumber_Stub(CMOCK_vTimerSetTimerNumber_CALLBACK Callback)
{
  Mock.vTimerSetTimerNumber_IgnoreBool = (char)0;
  Mock.vTimerSetTimerNumber_CallbackBool = (char)0;
  Mock.vTimerSetTimerNumber_CallbackFunctionPointer = Callback;
}

void vTimerSetTimerNumber_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetTimerNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void vTimerSetTimerNumber_CMockIgnoreArg_uxTimerNumber(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vTimerSetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_vTimerSetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vTimerSetTimerNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_uxTimerNumber = 1;
}

UBaseType_t uxTimerGetTimerNumber(TimerHandle_t xTimer)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_uxTimerGetTimerNumber);
  cmock_call_instance = (CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.uxTimerGetTimerNumber_CallInstance);
  Mock.uxTimerGetTimerNumber_CallInstance = CMock_Guts_MemNext(Mock.uxTimerGetTimerNumber_CallInstance);
  if (Mock.uxTimerGetTimerNumber_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.uxTimerGetTimerNumber_FinalReturn;
    memcpy((void*)(&Mock.uxTimerGetTimerNumber_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(UBaseType_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.uxTimerGetTimerNumber_CallbackBool &&
      Mock.uxTimerGetTimerNumber_CallbackFunctionPointer != NULL)
  {
    UBaseType_t cmock_cb_ret = Mock.uxTimerGetTimerNumber_CallbackFunctionPointer(xTimer, Mock.uxTimerGetTimerNumber_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_xTimer)
  {
    UNITY_SET_DETAILS(CMockString_uxTimerGetTimerNumber,CMockString_xTimer);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer), sizeof(TimerHandle_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.uxTimerGetTimerNumber_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.uxTimerGetTimerNumber_CallbackFunctionPointer(xTimer, Mock.uxTimerGetTimerNumber_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_uxTimerGetTimerNumber(CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer);
void CMockExpectParameters_uxTimerGetTimerNumber(CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance, TimerHandle_t xTimer)
{
  memcpy((void*)(&cmock_call_instance->Expected_xTimer), (void*)(&xTimer),
         sizeof(TimerHandle_t[sizeof(xTimer) == sizeof(TimerHandle_t) ? 1 : -1])); /* add TimerHandle_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_xTimer = 0;
}

void uxTimerGetTimerNumber_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE));
  CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTimerGetTimerNumber_CallInstance = CMock_Guts_MemChain(Mock.uxTimerGetTimerNumber_CallInstance, cmock_guts_index);
  Mock.uxTimerGetTimerNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.uxTimerGetTimerNumber_IgnoreBool = (char)1;
}

void uxTimerGetTimerNumber_CMockStopIgnore(void)
{
  if(Mock.uxTimerGetTimerNumber_IgnoreBool)
    Mock.uxTimerGetTimerNumber_CallInstance = CMock_Guts_MemNext(Mock.uxTimerGetTimerNumber_CallInstance);
  Mock.uxTimerGetTimerNumber_IgnoreBool = (char)0;
}

void uxTimerGetTimerNumber_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, TimerHandle_t xTimer, UBaseType_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE));
  CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.uxTimerGetTimerNumber_CallInstance = CMock_Guts_MemChain(Mock.uxTimerGetTimerNumber_CallInstance, cmock_guts_index);
  Mock.uxTimerGetTimerNumber_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_uxTimerGetTimerNumber(cmock_call_instance, xTimer);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(UBaseType_t[sizeof(cmock_to_return) == sizeof(UBaseType_t) ? 1 : -1])); /* add UBaseType_t to :treat_as_array if this causes an error */
}

void uxTimerGetTimerNumber_AddCallback(CMOCK_uxTimerGetTimerNumber_CALLBACK Callback)
{
  Mock.uxTimerGetTimerNumber_IgnoreBool = (char)0;
  Mock.uxTimerGetTimerNumber_CallbackBool = (char)1;
  Mock.uxTimerGetTimerNumber_CallbackFunctionPointer = Callback;
}

void uxTimerGetTimerNumber_Stub(CMOCK_uxTimerGetTimerNumber_CALLBACK Callback)
{
  Mock.uxTimerGetTimerNumber_IgnoreBool = (char)0;
  Mock.uxTimerGetTimerNumber_CallbackBool = (char)0;
  Mock.uxTimerGetTimerNumber_CallbackFunctionPointer = Callback;
}

void uxTimerGetTimerNumber_CMockIgnoreArg_xTimer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE* cmock_call_instance = (CMOCK_uxTimerGetTimerNumber_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.uxTimerGetTimerNumber_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_xTimer = 1;
}

void vApplicationGetTimerTaskMemory(StaticTask_t** ppxTimerTaskTCBBuffer, StackType_t** ppxTimerTaskStackBuffer, uint32_t* pulTimerTaskStackSize)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_vApplicationGetTimerTaskMemory);
  cmock_call_instance = (CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.vApplicationGetTimerTaskMemory_CallInstance);
  Mock.vApplicationGetTimerTaskMemory_CallInstance = CMock_Guts_MemNext(Mock.vApplicationGetTimerTaskMemory_CallInstance);
  if (Mock.vApplicationGetTimerTaskMemory_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.vApplicationGetTimerTaskMemory_CallbackBool &&
      Mock.vApplicationGetTimerTaskMemory_CallbackFunctionPointer != NULL)
  {
    Mock.vApplicationGetTimerTaskMemory_CallbackFunctionPointer(ppxTimerTaskTCBBuffer, ppxTimerTaskStackBuffer, pulTimerTaskStackSize, Mock.vApplicationGetTimerTaskMemory_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_ppxTimerTaskTCBBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationGetTimerTaskMemory,CMockString_ppxTimerTaskTCBBuffer);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_ppxTimerTaskTCBBuffer, ppxTimerTaskTCBBuffer, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ppxTimerTaskStackBuffer)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationGetTimerTaskMemory,CMockString_ppxTimerTaskStackBuffer);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_ppxTimerTaskStackBuffer, ppxTimerTaskStackBuffer, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pulTimerTaskStackSize)
  {
    UNITY_SET_DETAILS(CMockString_vApplicationGetTimerTaskMemory,CMockString_pulTimerTaskStackSize);
    if (cmock_call_instance->Expected_pulTimerTaskStackSize == NULL)
      { UNITY_TEST_ASSERT_NULL(pulTimerTaskStackSize, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX32_ARRAY(cmock_call_instance->Expected_pulTimerTaskStackSize, pulTimerTaskStackSize, cmock_call_instance->Expected_pulTimerTaskStackSize_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.vApplicationGetTimerTaskMemory_CallbackFunctionPointer != NULL)
  {
    Mock.vApplicationGetTimerTaskMemory_CallbackFunctionPointer(ppxTimerTaskTCBBuffer, ppxTimerTaskStackBuffer, pulTimerTaskStackSize, Mock.vApplicationGetTimerTaskMemory_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_ppxTimerTaskTCBBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ppxTimerTaskTCBBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ppxTimerTaskTCBBuffer, (void*)cmock_call_instance->ReturnThruPtr_ppxTimerTaskTCBBuffer_Val,
      cmock_call_instance->ReturnThruPtr_ppxTimerTaskTCBBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_ppxTimerTaskStackBuffer_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(ppxTimerTaskStackBuffer, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)ppxTimerTaskStackBuffer, (void*)cmock_call_instance->ReturnThruPtr_ppxTimerTaskStackBuffer_Val,
      cmock_call_instance->ReturnThruPtr_ppxTimerTaskStackBuffer_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_pulTimerTaskStackSize_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(pulTimerTaskStackSize, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)pulTimerTaskStackSize, (void*)cmock_call_instance->ReturnThruPtr_pulTimerTaskStackSize_Val,
      cmock_call_instance->ReturnThruPtr_pulTimerTaskStackSize_Size);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_vApplicationGetTimerTaskMemory(CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE* cmock_call_instance, StaticTask_t** ppxTimerTaskTCBBuffer, int ppxTimerTaskTCBBuffer_Depth, StackType_t** ppxTimerTaskStackBuffer, int ppxTimerTaskStackBuffer_Depth, uint32_t* pulTimerTaskStackSize, int pulTimerTaskStackSize_Depth);
void CMockExpectParameters_vApplicationGetTimerTaskMemory(CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE* cmock_call_instance, StaticTask_t** ppxTimerTaskTCBBuffer, int ppxTimerTaskTCBBuffer_Depth, StackType_t** ppxTimerTaskStackBuffer, int ppxTimerTaskStackBuffer_Depth, uint32_t* pulTimerTaskStackSize, int pulTimerTaskStackSize_Depth)
{
  cmock_call_instance->Expected_ppxTimerTaskTCBBuffer = ppxTimerTaskTCBBuffer;
  cmock_call_instance->Expected_ppxTimerTaskTCBBuffer_Depth = ppxTimerTaskTCBBuffer_Depth;
  cmock_call_instance->IgnoreArg_ppxTimerTaskTCBBuffer = 0;
  cmock_call_instance->ReturnThruPtr_ppxTimerTaskTCBBuffer_Used = 0;
  cmock_call_instance->Expected_ppxTimerTaskStackBuffer = ppxTimerTaskStackBuffer;
  cmock_call_instance->Expected_ppxTimerTaskStackBuffer_Depth = ppxTimerTaskStackBuffer_Depth;
  cmock_call_instance->IgnoreArg_ppxTimerTaskStackBuffer = 0;
  cmock_call_instance->ReturnThruPtr_ppxTimerTaskStackBuffer_Used = 0;
  cmock_call_instance->Expected_pulTimerTaskStackSize = pulTimerTaskStackSize;
  cmock_call_instance->Expected_pulTimerTaskStackSize_Depth = pulTimerTaskStackSize_Depth;
  cmock_call_instance->IgnoreArg_pulTimerTaskStackSize = 0;
  cmock_call_instance->ReturnThruPtr_pulTimerTaskStackSize_Used = 0;
}

void vApplicationGetTimerTaskMemory_CMockIgnore(void)
{
  Mock.vApplicationGetTimerTaskMemory_IgnoreBool = (char)1;
}

void vApplicationGetTimerTaskMemory_CMockStopIgnore(void)
{
  Mock.vApplicationGetTimerTaskMemory_IgnoreBool = (char)0;
}

void vApplicationGetTimerTaskMemory_CMockExpect(UNITY_LINE_TYPE cmock_line, StaticTask_t** ppxTimerTaskTCBBuffer, StackType_t** ppxTimerTaskStackBuffer, uint32_t* pulTimerTaskStackSize)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE));
  CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vApplicationGetTimerTaskMemory_CallInstance = CMock_Guts_MemChain(Mock.vApplicationGetTimerTaskMemory_CallInstance, cmock_guts_index);
  Mock.vApplicationGetTimerTaskMemory_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_vApplicationGetTimerTaskMemory(cmock_call_instance, ppxTimerTaskTCBBuffer, 1, ppxTimerTaskStackBuffer, 1, pulTimerTaskStackSize, 1);
}

void vApplicationGetTimerTaskMemory_AddCallback(CMOCK_vApplicationGetTimerTaskMemory_CALLBACK Callback)
{
  Mock.vApplicationGetTimerTaskMemory_IgnoreBool = (char)0;
  Mock.vApplicationGetTimerTaskMemory_CallbackBool = (char)1;
  Mock.vApplicationGetTimerTaskMemory_CallbackFunctionPointer = Callback;
}

void vApplicationGetTimerTaskMemory_Stub(CMOCK_vApplicationGetTimerTaskMemory_CALLBACK Callback)
{
  Mock.vApplicationGetTimerTaskMemory_IgnoreBool = (char)0;
  Mock.vApplicationGetTimerTaskMemory_CallbackBool = (char)0;
  Mock.vApplicationGetTimerTaskMemory_CallbackFunctionPointer = Callback;
}

void vApplicationGetTimerTaskMemory_CMockExpectWithArray(UNITY_LINE_TYPE cmock_line, StaticTask_t** ppxTimerTaskTCBBuffer, int ppxTimerTaskTCBBuffer_Depth, StackType_t** ppxTimerTaskStackBuffer, int ppxTimerTaskStackBuffer_Depth, uint32_t* pulTimerTaskStackSize, int pulTimerTaskStackSize_Depth)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE));
  CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.vApplicationGetTimerTaskMemory_CallInstance = CMock_Guts_MemChain(Mock.vApplicationGetTimerTaskMemory_CallInstance, cmock_guts_index);
  Mock.vApplicationGetTimerTaskMemory_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_vApplicationGetTimerTaskMemory(cmock_call_instance, ppxTimerTaskTCBBuffer, ppxTimerTaskTCBBuffer_Depth, ppxTimerTaskStackBuffer, ppxTimerTaskStackBuffer_Depth, pulTimerTaskStackSize, pulTimerTaskStackSize_Depth);
}

void vApplicationGetTimerTaskMemory_CMockReturnMemThruPtr_ppxTimerTaskTCBBuffer(UNITY_LINE_TYPE cmock_line, StaticTask_t** ppxTimerTaskTCBBuffer, size_t cmock_size)
{
  CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetTimerTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ppxTimerTaskTCBBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_ppxTimerTaskTCBBuffer_Val = ppxTimerTaskTCBBuffer;
  cmock_call_instance->ReturnThruPtr_ppxTimerTaskTCBBuffer_Size = cmock_size;
}

void vApplicationGetTimerTaskMemory_CMockReturnMemThruPtr_ppxTimerTaskStackBuffer(UNITY_LINE_TYPE cmock_line, StackType_t** ppxTimerTaskStackBuffer, size_t cmock_size)
{
  CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetTimerTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_ppxTimerTaskStackBuffer_Used = 1;
  cmock_call_instance->ReturnThruPtr_ppxTimerTaskStackBuffer_Val = ppxTimerTaskStackBuffer;
  cmock_call_instance->ReturnThruPtr_ppxTimerTaskStackBuffer_Size = cmock_size;
}

void vApplicationGetTimerTaskMemory_CMockReturnMemThruPtr_pulTimerTaskStackSize(UNITY_LINE_TYPE cmock_line, uint32_t* pulTimerTaskStackSize, size_t cmock_size)
{
  CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetTimerTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_pulTimerTaskStackSize_Used = 1;
  cmock_call_instance->ReturnThruPtr_pulTimerTaskStackSize_Val = pulTimerTaskStackSize;
  cmock_call_instance->ReturnThruPtr_pulTimerTaskStackSize_Size = cmock_size;
}

void vApplicationGetTimerTaskMemory_CMockIgnoreArg_ppxTimerTaskTCBBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetTimerTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ppxTimerTaskTCBBuffer = 1;
}

void vApplicationGetTimerTaskMemory_CMockIgnoreArg_ppxTimerTaskStackBuffer(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetTimerTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ppxTimerTaskStackBuffer = 1;
}

void vApplicationGetTimerTaskMemory_CMockIgnoreArg_pulTimerTaskStackSize(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE* cmock_call_instance = (CMOCK_vApplicationGetTimerTaskMemory_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.vApplicationGetTimerTaskMemory_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pulTimerTaskStackSize = 1;
}

