/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_gpio.h"

static const char* CMockString_arg = "arg";
static const char* CMockString_args = "args";
static const char* CMockString_fn = "fn";
static const char* CMockString_func = "func";
static const char* CMockString_gpio_config = "gpio_config";
static const char* CMockString_gpio_deep_sleep_hold_dis = "gpio_deep_sleep_hold_dis";
static const char* CMockString_gpio_deep_sleep_hold_en = "gpio_deep_sleep_hold_en";
static const char* CMockString_gpio_deep_sleep_wakeup_disable = "gpio_deep_sleep_wakeup_disable";
static const char* CMockString_gpio_deep_sleep_wakeup_enable = "gpio_deep_sleep_wakeup_enable";
static const char* CMockString_gpio_force_hold_all = "gpio_force_hold_all";
static const char* CMockString_gpio_force_unhold_all = "gpio_force_unhold_all";
static const char* CMockString_gpio_get_drive_capability = "gpio_get_drive_capability";
static const char* CMockString_gpio_get_level = "gpio_get_level";
static const char* CMockString_gpio_hold_dis = "gpio_hold_dis";
static const char* CMockString_gpio_hold_en = "gpio_hold_en";
static const char* CMockString_gpio_install_isr_service = "gpio_install_isr_service";
static const char* CMockString_gpio_intr_disable = "gpio_intr_disable";
static const char* CMockString_gpio_intr_enable = "gpio_intr_enable";
static const char* CMockString_gpio_iomux_in = "gpio_iomux_in";
static const char* CMockString_gpio_iomux_out = "gpio_iomux_out";
static const char* CMockString_gpio_isr_handler_add = "gpio_isr_handler_add";
static const char* CMockString_gpio_isr_handler_remove = "gpio_isr_handler_remove";
static const char* CMockString_gpio_isr_register = "gpio_isr_register";
static const char* CMockString_gpio_num = "gpio_num";
static const char* CMockString_gpio_pulldown_dis = "gpio_pulldown_dis";
static const char* CMockString_gpio_pulldown_en = "gpio_pulldown_en";
static const char* CMockString_gpio_pullup_dis = "gpio_pullup_dis";
static const char* CMockString_gpio_pullup_en = "gpio_pullup_en";
static const char* CMockString_gpio_reset_pin = "gpio_reset_pin";
static const char* CMockString_gpio_set_direction = "gpio_set_direction";
static const char* CMockString_gpio_set_drive_capability = "gpio_set_drive_capability";
static const char* CMockString_gpio_set_intr_type = "gpio_set_intr_type";
static const char* CMockString_gpio_set_level = "gpio_set_level";
static const char* CMockString_gpio_set_pull_mode = "gpio_set_pull_mode";
static const char* CMockString_gpio_sleep_sel_dis = "gpio_sleep_sel_dis";
static const char* CMockString_gpio_sleep_sel_en = "gpio_sleep_sel_en";
static const char* CMockString_gpio_sleep_set_direction = "gpio_sleep_set_direction";
static const char* CMockString_gpio_sleep_set_pull_mode = "gpio_sleep_set_pull_mode";
static const char* CMockString_gpio_uninstall_isr_service = "gpio_uninstall_isr_service";
static const char* CMockString_gpio_wakeup_disable = "gpio_wakeup_disable";
static const char* CMockString_gpio_wakeup_enable = "gpio_wakeup_enable";
static const char* CMockString_handle = "handle";
static const char* CMockString_intr_alloc_flags = "intr_alloc_flags";
static const char* CMockString_intr_type = "intr_type";
static const char* CMockString_isr_handler = "isr_handler";
static const char* CMockString_level = "level";
static const char* CMockString_mode = "mode";
static const char* CMockString_oen_inv = "oen_inv";
static const char* CMockString_pGPIOConfig = "pGPIOConfig";
static const char* CMockString_pull = "pull";
static const char* CMockString_signal_idx = "signal_idx";
static const char* CMockString_strength = "strength";

typedef struct _CMOCK_gpio_config_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  const gpio_config_t* Expected_pGPIOConfig;
  int Expected_pGPIOConfig_Depth;
  char IgnoreArg_pGPIOConfig;

} CMOCK_gpio_config_CALL_INSTANCE;

typedef struct _CMOCK_gpio_reset_pin_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_reset_pin_CALL_INSTANCE;

typedef struct _CMOCK_gpio_set_intr_type_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  gpio_int_type_t Expected_intr_type;
  char IgnoreArg_gpio_num;
  char IgnoreArg_intr_type;

} CMOCK_gpio_set_intr_type_CALL_INSTANCE;

typedef struct _CMOCK_gpio_intr_enable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_intr_enable_CALL_INSTANCE;

typedef struct _CMOCK_gpio_intr_disable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_intr_disable_CALL_INSTANCE;

typedef struct _CMOCK_gpio_set_level_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  uint32_t Expected_level;
  char IgnoreArg_gpio_num;
  char IgnoreArg_level;

} CMOCK_gpio_set_level_CALL_INSTANCE;

typedef struct _CMOCK_gpio_get_level_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_get_level_CALL_INSTANCE;

typedef struct _CMOCK_gpio_set_direction_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  gpio_mode_t Expected_mode;
  char IgnoreArg_gpio_num;
  char IgnoreArg_mode;

} CMOCK_gpio_set_direction_CALL_INSTANCE;

typedef struct _CMOCK_gpio_set_pull_mode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  gpio_pull_mode_t Expected_pull;
  char IgnoreArg_gpio_num;
  char IgnoreArg_pull;

} CMOCK_gpio_set_pull_mode_CALL_INSTANCE;

typedef struct _CMOCK_gpio_wakeup_enable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  gpio_int_type_t Expected_intr_type;
  char IgnoreArg_gpio_num;
  char IgnoreArg_intr_type;

} CMOCK_gpio_wakeup_enable_CALL_INSTANCE;

typedef struct _CMOCK_gpio_wakeup_disable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_wakeup_disable_CALL_INSTANCE;

typedef struct _CMOCK_gpio_isr_register_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  cmock_gpio_func_ptr1 Expected_fn;
  void* Expected_arg;
  int Expected_intr_alloc_flags;
  gpio_isr_handle_t* Expected_handle;
  int Expected_arg_Depth;
  int Expected_handle_Depth;
  char ReturnThruPtr_arg_Used;
  void* ReturnThruPtr_arg_Val;
  size_t ReturnThruPtr_arg_Size;
  char ReturnThruPtr_handle_Used;
  gpio_isr_handle_t* ReturnThruPtr_handle_Val;
  size_t ReturnThruPtr_handle_Size;
  char IgnoreArg_fn;
  char IgnoreArg_arg;
  char IgnoreArg_intr_alloc_flags;
  char IgnoreArg_handle;

} CMOCK_gpio_isr_register_CALL_INSTANCE;

typedef struct _CMOCK_gpio_pullup_en_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_pullup_en_CALL_INSTANCE;

typedef struct _CMOCK_gpio_pullup_dis_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_pullup_dis_CALL_INSTANCE;

typedef struct _CMOCK_gpio_pulldown_en_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_pulldown_en_CALL_INSTANCE;

typedef struct _CMOCK_gpio_pulldown_dis_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_pulldown_dis_CALL_INSTANCE;

typedef struct _CMOCK_gpio_install_isr_service_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  int Expected_intr_alloc_flags;
  char IgnoreArg_intr_alloc_flags;

} CMOCK_gpio_install_isr_service_CALL_INSTANCE;

typedef struct _CMOCK_gpio_uninstall_isr_service_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_gpio_uninstall_isr_service_CALL_INSTANCE;

typedef struct _CMOCK_gpio_isr_handler_add_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  gpio_isr_t Expected_isr_handler;
  void* Expected_args;
  int Expected_args_Depth;
  char ReturnThruPtr_args_Used;
  void* ReturnThruPtr_args_Val;
  size_t ReturnThruPtr_args_Size;
  char IgnoreArg_gpio_num;
  char IgnoreArg_isr_handler;
  char IgnoreArg_args;

} CMOCK_gpio_isr_handler_add_CALL_INSTANCE;

typedef struct _CMOCK_gpio_isr_handler_remove_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_isr_handler_remove_CALL_INSTANCE;

typedef struct _CMOCK_gpio_set_drive_capability_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  gpio_drive_cap_t Expected_strength;
  char IgnoreArg_gpio_num;
  char IgnoreArg_strength;

} CMOCK_gpio_set_drive_capability_CALL_INSTANCE;

typedef struct _CMOCK_gpio_get_drive_capability_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  gpio_drive_cap_t* Expected_strength;
  int Expected_strength_Depth;
  char ReturnThruPtr_strength_Used;
  gpio_drive_cap_t* ReturnThruPtr_strength_Val;
  size_t ReturnThruPtr_strength_Size;
  char IgnoreArg_gpio_num;
  char IgnoreArg_strength;

} CMOCK_gpio_get_drive_capability_CALL_INSTANCE;

typedef struct _CMOCK_gpio_hold_en_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_hold_en_CALL_INSTANCE;

typedef struct _CMOCK_gpio_hold_dis_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_hold_dis_CALL_INSTANCE;

typedef struct _CMOCK_gpio_deep_sleep_hold_en_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_gpio_deep_sleep_hold_en_CALL_INSTANCE;

typedef struct _CMOCK_gpio_deep_sleep_hold_dis_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_gpio_deep_sleep_hold_dis_CALL_INSTANCE;

typedef struct _CMOCK_gpio_iomux_in_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint32_t Expected_gpio_num;
  uint32_t Expected_signal_idx;
  char IgnoreArg_gpio_num;
  char IgnoreArg_signal_idx;

} CMOCK_gpio_iomux_in_CALL_INSTANCE;

typedef struct _CMOCK_gpio_iomux_out_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;
  uint8_t Expected_gpio_num;
  int Expected_func;
  bool Expected_oen_inv;
  char IgnoreArg_gpio_num;
  char IgnoreArg_func;
  char IgnoreArg_oen_inv;

} CMOCK_gpio_iomux_out_CALL_INSTANCE;

typedef struct _CMOCK_gpio_force_hold_all_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;

} CMOCK_gpio_force_hold_all_CALL_INSTANCE;

typedef struct _CMOCK_gpio_force_unhold_all_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;

} CMOCK_gpio_force_unhold_all_CALL_INSTANCE;

typedef struct _CMOCK_gpio_sleep_sel_en_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_sleep_sel_en_CALL_INSTANCE;

typedef struct _CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE;

typedef struct _CMOCK_gpio_sleep_set_direction_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  gpio_mode_t Expected_mode;
  char IgnoreArg_gpio_num;
  char IgnoreArg_mode;

} CMOCK_gpio_sleep_set_direction_CALL_INSTANCE;

typedef struct _CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  gpio_pull_mode_t Expected_pull;
  char IgnoreArg_gpio_num;
  char IgnoreArg_pull;

} CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE;

typedef struct _CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  gpio_int_type_t Expected_intr_type;
  char IgnoreArg_gpio_num;
  char IgnoreArg_intr_type;

} CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE;

typedef struct _CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  gpio_num_t Expected_gpio_num;
  char IgnoreArg_gpio_num;

} CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE;

static struct mock_gpioInstance
{
  char gpio_config_IgnoreBool;
  esp_err_t gpio_config_FinalReturn;
  char gpio_config_CallbackBool;
  CMOCK_gpio_config_CALLBACK gpio_config_CallbackFunctionPointer;
  int gpio_config_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_config_CallInstance;
  char gpio_reset_pin_IgnoreBool;
  esp_err_t gpio_reset_pin_FinalReturn;
  char gpio_reset_pin_CallbackBool;
  CMOCK_gpio_reset_pin_CALLBACK gpio_reset_pin_CallbackFunctionPointer;
  int gpio_reset_pin_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_reset_pin_CallInstance;
  char gpio_set_intr_type_IgnoreBool;
  esp_err_t gpio_set_intr_type_FinalReturn;
  char gpio_set_intr_type_CallbackBool;
  CMOCK_gpio_set_intr_type_CALLBACK gpio_set_intr_type_CallbackFunctionPointer;
  int gpio_set_intr_type_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_set_intr_type_CallInstance;
  char gpio_intr_enable_IgnoreBool;
  esp_err_t gpio_intr_enable_FinalReturn;
  char gpio_intr_enable_CallbackBool;
  CMOCK_gpio_intr_enable_CALLBACK gpio_intr_enable_CallbackFunctionPointer;
  int gpio_intr_enable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_intr_enable_CallInstance;
  char gpio_intr_disable_IgnoreBool;
  esp_err_t gpio_intr_disable_FinalReturn;
  char gpio_intr_disable_CallbackBool;
  CMOCK_gpio_intr_disable_CALLBACK gpio_intr_disable_CallbackFunctionPointer;
  int gpio_intr_disable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_intr_disable_CallInstance;
  char gpio_set_level_IgnoreBool;
  esp_err_t gpio_set_level_FinalReturn;
  char gpio_set_level_CallbackBool;
  CMOCK_gpio_set_level_CALLBACK gpio_set_level_CallbackFunctionPointer;
  int gpio_set_level_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_set_level_CallInstance;
  char gpio_get_level_IgnoreBool;
  int gpio_get_level_FinalReturn;
  char gpio_get_level_CallbackBool;
  CMOCK_gpio_get_level_CALLBACK gpio_get_level_CallbackFunctionPointer;
  int gpio_get_level_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_get_level_CallInstance;
  char gpio_set_direction_IgnoreBool;
  esp_err_t gpio_set_direction_FinalReturn;
  char gpio_set_direction_CallbackBool;
  CMOCK_gpio_set_direction_CALLBACK gpio_set_direction_CallbackFunctionPointer;
  int gpio_set_direction_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_set_direction_CallInstance;
  char gpio_set_pull_mode_IgnoreBool;
  esp_err_t gpio_set_pull_mode_FinalReturn;
  char gpio_set_pull_mode_CallbackBool;
  CMOCK_gpio_set_pull_mode_CALLBACK gpio_set_pull_mode_CallbackFunctionPointer;
  int gpio_set_pull_mode_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_set_pull_mode_CallInstance;
  char gpio_wakeup_enable_IgnoreBool;
  esp_err_t gpio_wakeup_enable_FinalReturn;
  char gpio_wakeup_enable_CallbackBool;
  CMOCK_gpio_wakeup_enable_CALLBACK gpio_wakeup_enable_CallbackFunctionPointer;
  int gpio_wakeup_enable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_wakeup_enable_CallInstance;
  char gpio_wakeup_disable_IgnoreBool;
  esp_err_t gpio_wakeup_disable_FinalReturn;
  char gpio_wakeup_disable_CallbackBool;
  CMOCK_gpio_wakeup_disable_CALLBACK gpio_wakeup_disable_CallbackFunctionPointer;
  int gpio_wakeup_disable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_wakeup_disable_CallInstance;
  char gpio_isr_register_IgnoreBool;
  esp_err_t gpio_isr_register_FinalReturn;
  char gpio_isr_register_CallbackBool;
  CMOCK_gpio_isr_register_CALLBACK gpio_isr_register_CallbackFunctionPointer;
  int gpio_isr_register_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_isr_register_CallInstance;
  char gpio_pullup_en_IgnoreBool;
  esp_err_t gpio_pullup_en_FinalReturn;
  char gpio_pullup_en_CallbackBool;
  CMOCK_gpio_pullup_en_CALLBACK gpio_pullup_en_CallbackFunctionPointer;
  int gpio_pullup_en_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_pullup_en_CallInstance;
  char gpio_pullup_dis_IgnoreBool;
  esp_err_t gpio_pullup_dis_FinalReturn;
  char gpio_pullup_dis_CallbackBool;
  CMOCK_gpio_pullup_dis_CALLBACK gpio_pullup_dis_CallbackFunctionPointer;
  int gpio_pullup_dis_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_pullup_dis_CallInstance;
  char gpio_pulldown_en_IgnoreBool;
  esp_err_t gpio_pulldown_en_FinalReturn;
  char gpio_pulldown_en_CallbackBool;
  CMOCK_gpio_pulldown_en_CALLBACK gpio_pulldown_en_CallbackFunctionPointer;
  int gpio_pulldown_en_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_pulldown_en_CallInstance;
  char gpio_pulldown_dis_IgnoreBool;
  esp_err_t gpio_pulldown_dis_FinalReturn;
  char gpio_pulldown_dis_CallbackBool;
  CMOCK_gpio_pulldown_dis_CALLBACK gpio_pulldown_dis_CallbackFunctionPointer;
  int gpio_pulldown_dis_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_pulldown_dis_CallInstance;
  char gpio_install_isr_service_IgnoreBool;
  esp_err_t gpio_install_isr_service_FinalReturn;
  char gpio_install_isr_service_CallbackBool;
  CMOCK_gpio_install_isr_service_CALLBACK gpio_install_isr_service_CallbackFunctionPointer;
  int gpio_install_isr_service_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_install_isr_service_CallInstance;
  char gpio_uninstall_isr_service_IgnoreBool;
  char gpio_uninstall_isr_service_CallbackBool;
  CMOCK_gpio_uninstall_isr_service_CALLBACK gpio_uninstall_isr_service_CallbackFunctionPointer;
  int gpio_uninstall_isr_service_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_uninstall_isr_service_CallInstance;
  char gpio_isr_handler_add_IgnoreBool;
  esp_err_t gpio_isr_handler_add_FinalReturn;
  char gpio_isr_handler_add_CallbackBool;
  CMOCK_gpio_isr_handler_add_CALLBACK gpio_isr_handler_add_CallbackFunctionPointer;
  int gpio_isr_handler_add_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_isr_handler_add_CallInstance;
  char gpio_isr_handler_remove_IgnoreBool;
  esp_err_t gpio_isr_handler_remove_FinalReturn;
  char gpio_isr_handler_remove_CallbackBool;
  CMOCK_gpio_isr_handler_remove_CALLBACK gpio_isr_handler_remove_CallbackFunctionPointer;
  int gpio_isr_handler_remove_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_isr_handler_remove_CallInstance;
  char gpio_set_drive_capability_IgnoreBool;
  esp_err_t gpio_set_drive_capability_FinalReturn;
  char gpio_set_drive_capability_CallbackBool;
  CMOCK_gpio_set_drive_capability_CALLBACK gpio_set_drive_capability_CallbackFunctionPointer;
  int gpio_set_drive_capability_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_set_drive_capability_CallInstance;
  char gpio_get_drive_capability_IgnoreBool;
  esp_err_t gpio_get_drive_capability_FinalReturn;
  char gpio_get_drive_capability_CallbackBool;
  CMOCK_gpio_get_drive_capability_CALLBACK gpio_get_drive_capability_CallbackFunctionPointer;
  int gpio_get_drive_capability_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_get_drive_capability_CallInstance;
  char gpio_hold_en_IgnoreBool;
  esp_err_t gpio_hold_en_FinalReturn;
  char gpio_hold_en_CallbackBool;
  CMOCK_gpio_hold_en_CALLBACK gpio_hold_en_CallbackFunctionPointer;
  int gpio_hold_en_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_hold_en_CallInstance;
  char gpio_hold_dis_IgnoreBool;
  esp_err_t gpio_hold_dis_FinalReturn;
  char gpio_hold_dis_CallbackBool;
  CMOCK_gpio_hold_dis_CALLBACK gpio_hold_dis_CallbackFunctionPointer;
  int gpio_hold_dis_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_hold_dis_CallInstance;
  char gpio_deep_sleep_hold_en_IgnoreBool;
  char gpio_deep_sleep_hold_en_CallbackBool;
  CMOCK_gpio_deep_sleep_hold_en_CALLBACK gpio_deep_sleep_hold_en_CallbackFunctionPointer;
  int gpio_deep_sleep_hold_en_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_deep_sleep_hold_en_CallInstance;
  char gpio_deep_sleep_hold_dis_IgnoreBool;
  char gpio_deep_sleep_hold_dis_CallbackBool;
  CMOCK_gpio_deep_sleep_hold_dis_CALLBACK gpio_deep_sleep_hold_dis_CallbackFunctionPointer;
  int gpio_deep_sleep_hold_dis_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_deep_sleep_hold_dis_CallInstance;
  char gpio_iomux_in_IgnoreBool;
  char gpio_iomux_in_CallbackBool;
  CMOCK_gpio_iomux_in_CALLBACK gpio_iomux_in_CallbackFunctionPointer;
  int gpio_iomux_in_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_iomux_in_CallInstance;
  char gpio_iomux_out_IgnoreBool;
  char gpio_iomux_out_CallbackBool;
  CMOCK_gpio_iomux_out_CALLBACK gpio_iomux_out_CallbackFunctionPointer;
  int gpio_iomux_out_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_iomux_out_CallInstance;
  char gpio_force_hold_all_IgnoreBool;
  esp_err_t gpio_force_hold_all_FinalReturn;
  char gpio_force_hold_all_CallbackBool;
  CMOCK_gpio_force_hold_all_CALLBACK gpio_force_hold_all_CallbackFunctionPointer;
  int gpio_force_hold_all_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_force_hold_all_CallInstance;
  char gpio_force_unhold_all_IgnoreBool;
  esp_err_t gpio_force_unhold_all_FinalReturn;
  char gpio_force_unhold_all_CallbackBool;
  CMOCK_gpio_force_unhold_all_CALLBACK gpio_force_unhold_all_CallbackFunctionPointer;
  int gpio_force_unhold_all_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_force_unhold_all_CallInstance;
  char gpio_sleep_sel_en_IgnoreBool;
  esp_err_t gpio_sleep_sel_en_FinalReturn;
  char gpio_sleep_sel_en_CallbackBool;
  CMOCK_gpio_sleep_sel_en_CALLBACK gpio_sleep_sel_en_CallbackFunctionPointer;
  int gpio_sleep_sel_en_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_sleep_sel_en_CallInstance;
  char gpio_sleep_sel_dis_IgnoreBool;
  esp_err_t gpio_sleep_sel_dis_FinalReturn;
  char gpio_sleep_sel_dis_CallbackBool;
  CMOCK_gpio_sleep_sel_dis_CALLBACK gpio_sleep_sel_dis_CallbackFunctionPointer;
  int gpio_sleep_sel_dis_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_sleep_sel_dis_CallInstance;
  char gpio_sleep_set_direction_IgnoreBool;
  esp_err_t gpio_sleep_set_direction_FinalReturn;
  char gpio_sleep_set_direction_CallbackBool;
  CMOCK_gpio_sleep_set_direction_CALLBACK gpio_sleep_set_direction_CallbackFunctionPointer;
  int gpio_sleep_set_direction_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_sleep_set_direction_CallInstance;
  char gpio_sleep_set_pull_mode_IgnoreBool;
  esp_err_t gpio_sleep_set_pull_mode_FinalReturn;
  char gpio_sleep_set_pull_mode_CallbackBool;
  CMOCK_gpio_sleep_set_pull_mode_CALLBACK gpio_sleep_set_pull_mode_CallbackFunctionPointer;
  int gpio_sleep_set_pull_mode_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_sleep_set_pull_mode_CallInstance;
  char gpio_deep_sleep_wakeup_enable_IgnoreBool;
  esp_err_t gpio_deep_sleep_wakeup_enable_FinalReturn;
  char gpio_deep_sleep_wakeup_enable_CallbackBool;
  CMOCK_gpio_deep_sleep_wakeup_enable_CALLBACK gpio_deep_sleep_wakeup_enable_CallbackFunctionPointer;
  int gpio_deep_sleep_wakeup_enable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_deep_sleep_wakeup_enable_CallInstance;
  char gpio_deep_sleep_wakeup_disable_IgnoreBool;
  esp_err_t gpio_deep_sleep_wakeup_disable_FinalReturn;
  char gpio_deep_sleep_wakeup_disable_CallbackBool;
  CMOCK_gpio_deep_sleep_wakeup_disable_CALLBACK gpio_deep_sleep_wakeup_disable_CallbackFunctionPointer;
  int gpio_deep_sleep_wakeup_disable_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE gpio_deep_sleep_wakeup_disable_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_gpio_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.gpio_config_CallInstance;
  if (Mock.gpio_config_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_config);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_config_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_reset_pin_CallInstance;
  if (Mock.gpio_reset_pin_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_reset_pin);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_reset_pin_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_set_intr_type_CallInstance;
  if (Mock.gpio_set_intr_type_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_set_intr_type);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_set_intr_type_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_intr_enable_CallInstance;
  if (Mock.gpio_intr_enable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_intr_enable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_intr_enable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_intr_disable_CallInstance;
  if (Mock.gpio_intr_disable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_intr_disable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_intr_disable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_set_level_CallInstance;
  if (Mock.gpio_set_level_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_set_level);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_set_level_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_get_level_CallInstance;
  if (Mock.gpio_get_level_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_get_level);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_get_level_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_set_direction_CallInstance;
  if (Mock.gpio_set_direction_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_set_direction);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_set_direction_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_set_pull_mode_CallInstance;
  if (Mock.gpio_set_pull_mode_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_set_pull_mode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_set_pull_mode_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_wakeup_enable_CallInstance;
  if (Mock.gpio_wakeup_enable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_wakeup_enable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_wakeup_enable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_wakeup_disable_CallInstance;
  if (Mock.gpio_wakeup_disable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_wakeup_disable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_wakeup_disable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_isr_register_CallInstance;
  if (Mock.gpio_isr_register_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_isr_register);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_isr_register_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_pullup_en_CallInstance;
  if (Mock.gpio_pullup_en_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_pullup_en);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_pullup_en_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_pullup_dis_CallInstance;
  if (Mock.gpio_pullup_dis_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_pullup_dis);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_pullup_dis_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_pulldown_en_CallInstance;
  if (Mock.gpio_pulldown_en_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_pulldown_en);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_pulldown_en_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_pulldown_dis_CallInstance;
  if (Mock.gpio_pulldown_dis_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_pulldown_dis);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_pulldown_dis_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_install_isr_service_CallInstance;
  if (Mock.gpio_install_isr_service_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_install_isr_service);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_install_isr_service_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_uninstall_isr_service_CallInstance;
  if (Mock.gpio_uninstall_isr_service_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_uninstall_isr_service);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_uninstall_isr_service_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_isr_handler_add_CallInstance;
  if (Mock.gpio_isr_handler_add_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_isr_handler_add);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_isr_handler_add_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_isr_handler_remove_CallInstance;
  if (Mock.gpio_isr_handler_remove_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_isr_handler_remove);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_isr_handler_remove_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_set_drive_capability_CallInstance;
  if (Mock.gpio_set_drive_capability_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_set_drive_capability);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_set_drive_capability_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_get_drive_capability_CallInstance;
  if (Mock.gpio_get_drive_capability_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_get_drive_capability);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_get_drive_capability_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_hold_en_CallInstance;
  if (Mock.gpio_hold_en_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_hold_en);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_hold_en_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_hold_dis_CallInstance;
  if (Mock.gpio_hold_dis_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_hold_dis);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_hold_dis_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_deep_sleep_hold_en_CallInstance;
  if (Mock.gpio_deep_sleep_hold_en_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_deep_sleep_hold_en);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_deep_sleep_hold_en_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_deep_sleep_hold_dis_CallInstance;
  if (Mock.gpio_deep_sleep_hold_dis_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_deep_sleep_hold_dis);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_deep_sleep_hold_dis_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_iomux_in_CallInstance;
  if (Mock.gpio_iomux_in_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_iomux_in);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_iomux_in_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_iomux_out_CallInstance;
  if (Mock.gpio_iomux_out_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_iomux_out);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_iomux_out_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_force_hold_all_CallInstance;
  if (Mock.gpio_force_hold_all_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_force_hold_all);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_force_hold_all_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_force_unhold_all_CallInstance;
  if (Mock.gpio_force_unhold_all_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_force_unhold_all);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_force_unhold_all_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_sleep_sel_en_CallInstance;
  if (Mock.gpio_sleep_sel_en_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_sleep_sel_en);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_sleep_sel_en_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_sleep_sel_dis_CallInstance;
  if (Mock.gpio_sleep_sel_dis_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_sleep_sel_dis);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_sleep_sel_dis_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_sleep_set_direction_CallInstance;
  if (Mock.gpio_sleep_set_direction_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_sleep_set_direction);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_sleep_set_direction_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_sleep_set_pull_mode_CallInstance;
  if (Mock.gpio_sleep_set_pull_mode_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_sleep_set_pull_mode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_sleep_set_pull_mode_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_deep_sleep_wakeup_enable_CallInstance;
  if (Mock.gpio_deep_sleep_wakeup_enable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_deep_sleep_wakeup_enable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_deep_sleep_wakeup_enable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.gpio_deep_sleep_wakeup_disable_CallInstance;
  if (Mock.gpio_deep_sleep_wakeup_disable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_gpio_deep_sleep_wakeup_disable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.gpio_deep_sleep_wakeup_disable_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_gpio_Init(void)
{
  mock_gpio_Destroy();
}

void mock_gpio_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

esp_err_t gpio_config(const gpio_config_t* pGPIOConfig)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_config_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_config);
  cmock_call_instance = (CMOCK_gpio_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_config_CallInstance);
  Mock.gpio_config_CallInstance = CMock_Guts_MemNext(Mock.gpio_config_CallInstance);
  if (Mock.gpio_config_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_config_FinalReturn;
    memcpy((void*)(&Mock.gpio_config_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_config_CallbackBool &&
      Mock.gpio_config_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_config_CallbackFunctionPointer(pGPIOConfig, Mock.gpio_config_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_pGPIOConfig)
  {
    UNITY_SET_DETAILS(CMockString_gpio_config,CMockString_pGPIOConfig);
    if (cmock_call_instance->Expected_pGPIOConfig == NULL)
      { UNITY_TEST_ASSERT_NULL(pGPIOConfig, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_pGPIOConfig), (void*)(pGPIOConfig), sizeof(const gpio_config_t), cmock_call_instance->Expected_pGPIOConfig_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.gpio_config_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_config_CallbackFunctionPointer(pGPIOConfig, Mock.gpio_config_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_config(CMOCK_gpio_config_CALL_INSTANCE* cmock_call_instance, const gpio_config_t* pGPIOConfig, int pGPIOConfig_Depth);
void CMockExpectParameters_gpio_config(CMOCK_gpio_config_CALL_INSTANCE* cmock_call_instance, const gpio_config_t* pGPIOConfig, int pGPIOConfig_Depth)
{
  cmock_call_instance->Expected_pGPIOConfig = pGPIOConfig;
  cmock_call_instance->Expected_pGPIOConfig_Depth = pGPIOConfig_Depth;
  cmock_call_instance->IgnoreArg_pGPIOConfig = 0;
}

void gpio_config_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_config_CALL_INSTANCE));
  CMOCK_gpio_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_config_CallInstance = CMock_Guts_MemChain(Mock.gpio_config_CallInstance, cmock_guts_index);
  Mock.gpio_config_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_config_IgnoreBool = (char)1;
}

void gpio_config_CMockStopIgnore(void)
{
  if(Mock.gpio_config_IgnoreBool)
    Mock.gpio_config_CallInstance = CMock_Guts_MemNext(Mock.gpio_config_CallInstance);
  Mock.gpio_config_IgnoreBool = (char)0;
}

void gpio_config_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const gpio_config_t* pGPIOConfig, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_config_CALL_INSTANCE));
  CMOCK_gpio_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_config_CallInstance = CMock_Guts_MemChain(Mock.gpio_config_CallInstance, cmock_guts_index);
  Mock.gpio_config_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_config(cmock_call_instance, pGPIOConfig, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_config_AddCallback(CMOCK_gpio_config_CALLBACK Callback)
{
  Mock.gpio_config_IgnoreBool = (char)0;
  Mock.gpio_config_CallbackBool = (char)1;
  Mock.gpio_config_CallbackFunctionPointer = Callback;
}

void gpio_config_Stub(CMOCK_gpio_config_CALLBACK Callback)
{
  Mock.gpio_config_IgnoreBool = (char)0;
  Mock.gpio_config_CallbackBool = (char)0;
  Mock.gpio_config_CallbackFunctionPointer = Callback;
}

void gpio_config_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const gpio_config_t* pGPIOConfig, int pGPIOConfig_Depth, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_config_CALL_INSTANCE));
  CMOCK_gpio_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_config_CallInstance = CMock_Guts_MemChain(Mock.gpio_config_CallInstance, cmock_guts_index);
  Mock.gpio_config_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_config(cmock_call_instance, pGPIOConfig, pGPIOConfig_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gpio_config_CMockIgnoreArg_pGPIOConfig(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_config_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pGPIOConfig = 1;
}

esp_err_t gpio_reset_pin(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_reset_pin_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_reset_pin);
  cmock_call_instance = (CMOCK_gpio_reset_pin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_reset_pin_CallInstance);
  Mock.gpio_reset_pin_CallInstance = CMock_Guts_MemNext(Mock.gpio_reset_pin_CallInstance);
  if (Mock.gpio_reset_pin_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_reset_pin_FinalReturn;
    memcpy((void*)(&Mock.gpio_reset_pin_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_reset_pin_CallbackBool &&
      Mock.gpio_reset_pin_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_reset_pin_CallbackFunctionPointer(gpio_num, Mock.gpio_reset_pin_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_reset_pin,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_reset_pin_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_reset_pin_CallbackFunctionPointer(gpio_num, Mock.gpio_reset_pin_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_reset_pin(CMOCK_gpio_reset_pin_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_reset_pin(CMOCK_gpio_reset_pin_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_reset_pin_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_reset_pin_CALL_INSTANCE));
  CMOCK_gpio_reset_pin_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_reset_pin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_reset_pin_CallInstance = CMock_Guts_MemChain(Mock.gpio_reset_pin_CallInstance, cmock_guts_index);
  Mock.gpio_reset_pin_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_reset_pin_IgnoreBool = (char)1;
}

void gpio_reset_pin_CMockStopIgnore(void)
{
  if(Mock.gpio_reset_pin_IgnoreBool)
    Mock.gpio_reset_pin_CallInstance = CMock_Guts_MemNext(Mock.gpio_reset_pin_CallInstance);
  Mock.gpio_reset_pin_IgnoreBool = (char)0;
}

void gpio_reset_pin_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_reset_pin_CALL_INSTANCE));
  CMOCK_gpio_reset_pin_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_reset_pin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_reset_pin_CallInstance = CMock_Guts_MemChain(Mock.gpio_reset_pin_CallInstance, cmock_guts_index);
  Mock.gpio_reset_pin_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_reset_pin(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_reset_pin_AddCallback(CMOCK_gpio_reset_pin_CALLBACK Callback)
{
  Mock.gpio_reset_pin_IgnoreBool = (char)0;
  Mock.gpio_reset_pin_CallbackBool = (char)1;
  Mock.gpio_reset_pin_CallbackFunctionPointer = Callback;
}

void gpio_reset_pin_Stub(CMOCK_gpio_reset_pin_CALLBACK Callback)
{
  Mock.gpio_reset_pin_IgnoreBool = (char)0;
  Mock.gpio_reset_pin_CallbackBool = (char)0;
  Mock.gpio_reset_pin_CallbackFunctionPointer = Callback;
}

void gpio_reset_pin_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_reset_pin_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_reset_pin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_reset_pin_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_set_intr_type(gpio_num_t gpio_num, gpio_int_type_t intr_type)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_set_intr_type_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_set_intr_type);
  cmock_call_instance = (CMOCK_gpio_set_intr_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_set_intr_type_CallInstance);
  Mock.gpio_set_intr_type_CallInstance = CMock_Guts_MemNext(Mock.gpio_set_intr_type_CallInstance);
  if (Mock.gpio_set_intr_type_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_set_intr_type_FinalReturn;
    memcpy((void*)(&Mock.gpio_set_intr_type_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_set_intr_type_CallbackBool &&
      Mock.gpio_set_intr_type_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_set_intr_type_CallbackFunctionPointer(gpio_num, intr_type, Mock.gpio_set_intr_type_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_set_intr_type,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_intr_type)
  {
    UNITY_SET_DETAILS(CMockString_gpio_set_intr_type,CMockString_intr_type);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_intr_type), (void*)(&intr_type), sizeof(gpio_int_type_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_set_intr_type_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_set_intr_type_CallbackFunctionPointer(gpio_num, intr_type, Mock.gpio_set_intr_type_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_set_intr_type(CMOCK_gpio_set_intr_type_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_int_type_t intr_type);
void CMockExpectParameters_gpio_set_intr_type(CMOCK_gpio_set_intr_type_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_int_type_t intr_type)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  memcpy((void*)(&cmock_call_instance->Expected_intr_type), (void*)(&intr_type),
         sizeof(gpio_int_type_t[sizeof(intr_type) == sizeof(gpio_int_type_t) ? 1 : -1])); /* add gpio_int_type_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_intr_type = 0;
}

void gpio_set_intr_type_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_set_intr_type_CALL_INSTANCE));
  CMOCK_gpio_set_intr_type_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_intr_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_set_intr_type_CallInstance = CMock_Guts_MemChain(Mock.gpio_set_intr_type_CallInstance, cmock_guts_index);
  Mock.gpio_set_intr_type_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_set_intr_type_IgnoreBool = (char)1;
}

void gpio_set_intr_type_CMockStopIgnore(void)
{
  if(Mock.gpio_set_intr_type_IgnoreBool)
    Mock.gpio_set_intr_type_CallInstance = CMock_Guts_MemNext(Mock.gpio_set_intr_type_CallInstance);
  Mock.gpio_set_intr_type_IgnoreBool = (char)0;
}

void gpio_set_intr_type_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_int_type_t intr_type, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_set_intr_type_CALL_INSTANCE));
  CMOCK_gpio_set_intr_type_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_intr_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_set_intr_type_CallInstance = CMock_Guts_MemChain(Mock.gpio_set_intr_type_CallInstance, cmock_guts_index);
  Mock.gpio_set_intr_type_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_set_intr_type(cmock_call_instance, gpio_num, intr_type);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_set_intr_type_AddCallback(CMOCK_gpio_set_intr_type_CALLBACK Callback)
{
  Mock.gpio_set_intr_type_IgnoreBool = (char)0;
  Mock.gpio_set_intr_type_CallbackBool = (char)1;
  Mock.gpio_set_intr_type_CallbackFunctionPointer = Callback;
}

void gpio_set_intr_type_Stub(CMOCK_gpio_set_intr_type_CALLBACK Callback)
{
  Mock.gpio_set_intr_type_IgnoreBool = (char)0;
  Mock.gpio_set_intr_type_CallbackBool = (char)0;
  Mock.gpio_set_intr_type_CallbackFunctionPointer = Callback;
}

void gpio_set_intr_type_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_set_intr_type_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_intr_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_set_intr_type_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_set_intr_type_CMockIgnoreArg_intr_type(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_set_intr_type_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_intr_type_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_set_intr_type_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_intr_type = 1;
}

esp_err_t gpio_intr_enable(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_intr_enable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_intr_enable);
  cmock_call_instance = (CMOCK_gpio_intr_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_intr_enable_CallInstance);
  Mock.gpio_intr_enable_CallInstance = CMock_Guts_MemNext(Mock.gpio_intr_enable_CallInstance);
  if (Mock.gpio_intr_enable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_intr_enable_FinalReturn;
    memcpy((void*)(&Mock.gpio_intr_enable_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_intr_enable_CallbackBool &&
      Mock.gpio_intr_enable_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_intr_enable_CallbackFunctionPointer(gpio_num, Mock.gpio_intr_enable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_intr_enable,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_intr_enable_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_intr_enable_CallbackFunctionPointer(gpio_num, Mock.gpio_intr_enable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_intr_enable(CMOCK_gpio_intr_enable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_intr_enable(CMOCK_gpio_intr_enable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_intr_enable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_intr_enable_CALL_INSTANCE));
  CMOCK_gpio_intr_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_intr_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_intr_enable_CallInstance = CMock_Guts_MemChain(Mock.gpio_intr_enable_CallInstance, cmock_guts_index);
  Mock.gpio_intr_enable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_intr_enable_IgnoreBool = (char)1;
}

void gpio_intr_enable_CMockStopIgnore(void)
{
  if(Mock.gpio_intr_enable_IgnoreBool)
    Mock.gpio_intr_enable_CallInstance = CMock_Guts_MemNext(Mock.gpio_intr_enable_CallInstance);
  Mock.gpio_intr_enable_IgnoreBool = (char)0;
}

void gpio_intr_enable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_intr_enable_CALL_INSTANCE));
  CMOCK_gpio_intr_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_intr_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_intr_enable_CallInstance = CMock_Guts_MemChain(Mock.gpio_intr_enable_CallInstance, cmock_guts_index);
  Mock.gpio_intr_enable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_intr_enable(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_intr_enable_AddCallback(CMOCK_gpio_intr_enable_CALLBACK Callback)
{
  Mock.gpio_intr_enable_IgnoreBool = (char)0;
  Mock.gpio_intr_enable_CallbackBool = (char)1;
  Mock.gpio_intr_enable_CallbackFunctionPointer = Callback;
}

void gpio_intr_enable_Stub(CMOCK_gpio_intr_enable_CALLBACK Callback)
{
  Mock.gpio_intr_enable_IgnoreBool = (char)0;
  Mock.gpio_intr_enable_CallbackBool = (char)0;
  Mock.gpio_intr_enable_CallbackFunctionPointer = Callback;
}

void gpio_intr_enable_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_intr_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_intr_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_intr_enable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_intr_disable(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_intr_disable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_intr_disable);
  cmock_call_instance = (CMOCK_gpio_intr_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_intr_disable_CallInstance);
  Mock.gpio_intr_disable_CallInstance = CMock_Guts_MemNext(Mock.gpio_intr_disable_CallInstance);
  if (Mock.gpio_intr_disable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_intr_disable_FinalReturn;
    memcpy((void*)(&Mock.gpio_intr_disable_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_intr_disable_CallbackBool &&
      Mock.gpio_intr_disable_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_intr_disable_CallbackFunctionPointer(gpio_num, Mock.gpio_intr_disable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_intr_disable,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_intr_disable_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_intr_disable_CallbackFunctionPointer(gpio_num, Mock.gpio_intr_disable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_intr_disable(CMOCK_gpio_intr_disable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_intr_disable(CMOCK_gpio_intr_disable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_intr_disable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_intr_disable_CALL_INSTANCE));
  CMOCK_gpio_intr_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_intr_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_intr_disable_CallInstance = CMock_Guts_MemChain(Mock.gpio_intr_disable_CallInstance, cmock_guts_index);
  Mock.gpio_intr_disable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_intr_disable_IgnoreBool = (char)1;
}

void gpio_intr_disable_CMockStopIgnore(void)
{
  if(Mock.gpio_intr_disable_IgnoreBool)
    Mock.gpio_intr_disable_CallInstance = CMock_Guts_MemNext(Mock.gpio_intr_disable_CallInstance);
  Mock.gpio_intr_disable_IgnoreBool = (char)0;
}

void gpio_intr_disable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_intr_disable_CALL_INSTANCE));
  CMOCK_gpio_intr_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_intr_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_intr_disable_CallInstance = CMock_Guts_MemChain(Mock.gpio_intr_disable_CallInstance, cmock_guts_index);
  Mock.gpio_intr_disable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_intr_disable(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_intr_disable_AddCallback(CMOCK_gpio_intr_disable_CALLBACK Callback)
{
  Mock.gpio_intr_disable_IgnoreBool = (char)0;
  Mock.gpio_intr_disable_CallbackBool = (char)1;
  Mock.gpio_intr_disable_CallbackFunctionPointer = Callback;
}

void gpio_intr_disable_Stub(CMOCK_gpio_intr_disable_CALLBACK Callback)
{
  Mock.gpio_intr_disable_IgnoreBool = (char)0;
  Mock.gpio_intr_disable_CallbackBool = (char)0;
  Mock.gpio_intr_disable_CallbackFunctionPointer = Callback;
}

void gpio_intr_disable_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_intr_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_intr_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_intr_disable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_set_level_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_set_level);
  cmock_call_instance = (CMOCK_gpio_set_level_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_set_level_CallInstance);
  Mock.gpio_set_level_CallInstance = CMock_Guts_MemNext(Mock.gpio_set_level_CallInstance);
  if (Mock.gpio_set_level_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_set_level_FinalReturn;
    memcpy((void*)(&Mock.gpio_set_level_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_set_level_CallbackBool &&
      Mock.gpio_set_level_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_set_level_CallbackFunctionPointer(gpio_num, level, Mock.gpio_set_level_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_set_level,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_level)
  {
    UNITY_SET_DETAILS(CMockString_gpio_set_level,CMockString_level);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_level, level, cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_set_level_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_set_level_CallbackFunctionPointer(gpio_num, level, Mock.gpio_set_level_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_set_level(CMOCK_gpio_set_level_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, uint32_t level);
void CMockExpectParameters_gpio_set_level(CMOCK_gpio_set_level_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, uint32_t level)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  cmock_call_instance->Expected_level = level;
  cmock_call_instance->IgnoreArg_level = 0;
}

void gpio_set_level_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_set_level_CALL_INSTANCE));
  CMOCK_gpio_set_level_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_level_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_set_level_CallInstance = CMock_Guts_MemChain(Mock.gpio_set_level_CallInstance, cmock_guts_index);
  Mock.gpio_set_level_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_set_level_IgnoreBool = (char)1;
}

void gpio_set_level_CMockStopIgnore(void)
{
  if(Mock.gpio_set_level_IgnoreBool)
    Mock.gpio_set_level_CallInstance = CMock_Guts_MemNext(Mock.gpio_set_level_CallInstance);
  Mock.gpio_set_level_IgnoreBool = (char)0;
}

void gpio_set_level_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, uint32_t level, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_set_level_CALL_INSTANCE));
  CMOCK_gpio_set_level_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_level_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_set_level_CallInstance = CMock_Guts_MemChain(Mock.gpio_set_level_CallInstance, cmock_guts_index);
  Mock.gpio_set_level_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_set_level(cmock_call_instance, gpio_num, level);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_set_level_AddCallback(CMOCK_gpio_set_level_CALLBACK Callback)
{
  Mock.gpio_set_level_IgnoreBool = (char)0;
  Mock.gpio_set_level_CallbackBool = (char)1;
  Mock.gpio_set_level_CallbackFunctionPointer = Callback;
}

void gpio_set_level_Stub(CMOCK_gpio_set_level_CALLBACK Callback)
{
  Mock.gpio_set_level_IgnoreBool = (char)0;
  Mock.gpio_set_level_CallbackBool = (char)0;
  Mock.gpio_set_level_CallbackFunctionPointer = Callback;
}

void gpio_set_level_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_set_level_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_level_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_set_level_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_set_level_CMockIgnoreArg_level(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_set_level_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_level_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_set_level_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_level = 1;
}

int gpio_get_level(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_get_level_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_get_level);
  cmock_call_instance = (CMOCK_gpio_get_level_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_get_level_CallInstance);
  Mock.gpio_get_level_CallInstance = CMock_Guts_MemNext(Mock.gpio_get_level_CallInstance);
  if (Mock.gpio_get_level_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_get_level_FinalReturn;
    Mock.gpio_get_level_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_get_level_CallbackBool &&
      Mock.gpio_get_level_CallbackFunctionPointer != NULL)
  {
    int cmock_cb_ret = Mock.gpio_get_level_CallbackFunctionPointer(gpio_num, Mock.gpio_get_level_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_get_level,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_get_level_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_get_level_CallbackFunctionPointer(gpio_num, Mock.gpio_get_level_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_get_level(CMOCK_gpio_get_level_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_get_level(CMOCK_gpio_get_level_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_get_level_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_get_level_CALL_INSTANCE));
  CMOCK_gpio_get_level_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_get_level_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_get_level_CallInstance = CMock_Guts_MemChain(Mock.gpio_get_level_CallInstance, cmock_guts_index);
  Mock.gpio_get_level_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_get_level_IgnoreBool = (char)1;
}

void gpio_get_level_CMockStopIgnore(void)
{
  if(Mock.gpio_get_level_IgnoreBool)
    Mock.gpio_get_level_CallInstance = CMock_Guts_MemNext(Mock.gpio_get_level_CallInstance);
  Mock.gpio_get_level_IgnoreBool = (char)0;
}

void gpio_get_level_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_get_level_CALL_INSTANCE));
  CMOCK_gpio_get_level_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_get_level_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_get_level_CallInstance = CMock_Guts_MemChain(Mock.gpio_get_level_CallInstance, cmock_guts_index);
  Mock.gpio_get_level_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_get_level(cmock_call_instance, gpio_num);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gpio_get_level_AddCallback(CMOCK_gpio_get_level_CALLBACK Callback)
{
  Mock.gpio_get_level_IgnoreBool = (char)0;
  Mock.gpio_get_level_CallbackBool = (char)1;
  Mock.gpio_get_level_CallbackFunctionPointer = Callback;
}

void gpio_get_level_Stub(CMOCK_gpio_get_level_CALLBACK Callback)
{
  Mock.gpio_get_level_IgnoreBool = (char)0;
  Mock.gpio_get_level_CallbackBool = (char)0;
  Mock.gpio_get_level_CallbackFunctionPointer = Callback;
}

void gpio_get_level_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_get_level_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_get_level_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_get_level_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_set_direction(gpio_num_t gpio_num, gpio_mode_t mode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_set_direction_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_set_direction);
  cmock_call_instance = (CMOCK_gpio_set_direction_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_set_direction_CallInstance);
  Mock.gpio_set_direction_CallInstance = CMock_Guts_MemNext(Mock.gpio_set_direction_CallInstance);
  if (Mock.gpio_set_direction_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_set_direction_FinalReturn;
    memcpy((void*)(&Mock.gpio_set_direction_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_set_direction_CallbackBool &&
      Mock.gpio_set_direction_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_set_direction_CallbackFunctionPointer(gpio_num, mode, Mock.gpio_set_direction_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_set_direction,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_mode)
  {
    UNITY_SET_DETAILS(CMockString_gpio_set_direction,CMockString_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mode), (void*)(&mode), sizeof(gpio_mode_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_set_direction_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_set_direction_CallbackFunctionPointer(gpio_num, mode, Mock.gpio_set_direction_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_set_direction(CMOCK_gpio_set_direction_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_mode_t mode);
void CMockExpectParameters_gpio_set_direction(CMOCK_gpio_set_direction_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_mode_t mode)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  memcpy((void*)(&cmock_call_instance->Expected_mode), (void*)(&mode),
         sizeof(gpio_mode_t[sizeof(mode) == sizeof(gpio_mode_t) ? 1 : -1])); /* add gpio_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_mode = 0;
}

void gpio_set_direction_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_set_direction_CALL_INSTANCE));
  CMOCK_gpio_set_direction_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_direction_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_set_direction_CallInstance = CMock_Guts_MemChain(Mock.gpio_set_direction_CallInstance, cmock_guts_index);
  Mock.gpio_set_direction_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_set_direction_IgnoreBool = (char)1;
}

void gpio_set_direction_CMockStopIgnore(void)
{
  if(Mock.gpio_set_direction_IgnoreBool)
    Mock.gpio_set_direction_CallInstance = CMock_Guts_MemNext(Mock.gpio_set_direction_CallInstance);
  Mock.gpio_set_direction_IgnoreBool = (char)0;
}

void gpio_set_direction_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_mode_t mode, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_set_direction_CALL_INSTANCE));
  CMOCK_gpio_set_direction_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_direction_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_set_direction_CallInstance = CMock_Guts_MemChain(Mock.gpio_set_direction_CallInstance, cmock_guts_index);
  Mock.gpio_set_direction_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_set_direction(cmock_call_instance, gpio_num, mode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_set_direction_AddCallback(CMOCK_gpio_set_direction_CALLBACK Callback)
{
  Mock.gpio_set_direction_IgnoreBool = (char)0;
  Mock.gpio_set_direction_CallbackBool = (char)1;
  Mock.gpio_set_direction_CallbackFunctionPointer = Callback;
}

void gpio_set_direction_Stub(CMOCK_gpio_set_direction_CALLBACK Callback)
{
  Mock.gpio_set_direction_IgnoreBool = (char)0;
  Mock.gpio_set_direction_CallbackBool = (char)0;
  Mock.gpio_set_direction_CallbackFunctionPointer = Callback;
}

void gpio_set_direction_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_set_direction_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_direction_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_set_direction_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_set_direction_CMockIgnoreArg_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_set_direction_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_direction_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_set_direction_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_mode = 1;
}

esp_err_t gpio_set_pull_mode(gpio_num_t gpio_num, gpio_pull_mode_t pull)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_set_pull_mode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_set_pull_mode);
  cmock_call_instance = (CMOCK_gpio_set_pull_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_set_pull_mode_CallInstance);
  Mock.gpio_set_pull_mode_CallInstance = CMock_Guts_MemNext(Mock.gpio_set_pull_mode_CallInstance);
  if (Mock.gpio_set_pull_mode_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_set_pull_mode_FinalReturn;
    memcpy((void*)(&Mock.gpio_set_pull_mode_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_set_pull_mode_CallbackBool &&
      Mock.gpio_set_pull_mode_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_set_pull_mode_CallbackFunctionPointer(gpio_num, pull, Mock.gpio_set_pull_mode_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_set_pull_mode,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pull)
  {
    UNITY_SET_DETAILS(CMockString_gpio_set_pull_mode,CMockString_pull);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pull), (void*)(&pull), sizeof(gpio_pull_mode_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_set_pull_mode_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_set_pull_mode_CallbackFunctionPointer(gpio_num, pull, Mock.gpio_set_pull_mode_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_set_pull_mode(CMOCK_gpio_set_pull_mode_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_pull_mode_t pull);
void CMockExpectParameters_gpio_set_pull_mode(CMOCK_gpio_set_pull_mode_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_pull_mode_t pull)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  memcpy((void*)(&cmock_call_instance->Expected_pull), (void*)(&pull),
         sizeof(gpio_pull_mode_t[sizeof(pull) == sizeof(gpio_pull_mode_t) ? 1 : -1])); /* add gpio_pull_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pull = 0;
}

void gpio_set_pull_mode_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_set_pull_mode_CALL_INSTANCE));
  CMOCK_gpio_set_pull_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_pull_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_set_pull_mode_CallInstance = CMock_Guts_MemChain(Mock.gpio_set_pull_mode_CallInstance, cmock_guts_index);
  Mock.gpio_set_pull_mode_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_set_pull_mode_IgnoreBool = (char)1;
}

void gpio_set_pull_mode_CMockStopIgnore(void)
{
  if(Mock.gpio_set_pull_mode_IgnoreBool)
    Mock.gpio_set_pull_mode_CallInstance = CMock_Guts_MemNext(Mock.gpio_set_pull_mode_CallInstance);
  Mock.gpio_set_pull_mode_IgnoreBool = (char)0;
}

void gpio_set_pull_mode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_pull_mode_t pull, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_set_pull_mode_CALL_INSTANCE));
  CMOCK_gpio_set_pull_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_pull_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_set_pull_mode_CallInstance = CMock_Guts_MemChain(Mock.gpio_set_pull_mode_CallInstance, cmock_guts_index);
  Mock.gpio_set_pull_mode_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_set_pull_mode(cmock_call_instance, gpio_num, pull);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_set_pull_mode_AddCallback(CMOCK_gpio_set_pull_mode_CALLBACK Callback)
{
  Mock.gpio_set_pull_mode_IgnoreBool = (char)0;
  Mock.gpio_set_pull_mode_CallbackBool = (char)1;
  Mock.gpio_set_pull_mode_CallbackFunctionPointer = Callback;
}

void gpio_set_pull_mode_Stub(CMOCK_gpio_set_pull_mode_CALLBACK Callback)
{
  Mock.gpio_set_pull_mode_IgnoreBool = (char)0;
  Mock.gpio_set_pull_mode_CallbackBool = (char)0;
  Mock.gpio_set_pull_mode_CallbackFunctionPointer = Callback;
}

void gpio_set_pull_mode_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_set_pull_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_pull_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_set_pull_mode_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_set_pull_mode_CMockIgnoreArg_pull(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_set_pull_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_pull_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_set_pull_mode_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pull = 1;
}

esp_err_t gpio_wakeup_enable(gpio_num_t gpio_num, gpio_int_type_t intr_type)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_wakeup_enable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_wakeup_enable);
  cmock_call_instance = (CMOCK_gpio_wakeup_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_wakeup_enable_CallInstance);
  Mock.gpio_wakeup_enable_CallInstance = CMock_Guts_MemNext(Mock.gpio_wakeup_enable_CallInstance);
  if (Mock.gpio_wakeup_enable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_wakeup_enable_FinalReturn;
    memcpy((void*)(&Mock.gpio_wakeup_enable_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_wakeup_enable_CallbackBool &&
      Mock.gpio_wakeup_enable_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_wakeup_enable_CallbackFunctionPointer(gpio_num, intr_type, Mock.gpio_wakeup_enable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_wakeup_enable,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_intr_type)
  {
    UNITY_SET_DETAILS(CMockString_gpio_wakeup_enable,CMockString_intr_type);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_intr_type), (void*)(&intr_type), sizeof(gpio_int_type_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_wakeup_enable_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_wakeup_enable_CallbackFunctionPointer(gpio_num, intr_type, Mock.gpio_wakeup_enable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_wakeup_enable(CMOCK_gpio_wakeup_enable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_int_type_t intr_type);
void CMockExpectParameters_gpio_wakeup_enable(CMOCK_gpio_wakeup_enable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_int_type_t intr_type)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  memcpy((void*)(&cmock_call_instance->Expected_intr_type), (void*)(&intr_type),
         sizeof(gpio_int_type_t[sizeof(intr_type) == sizeof(gpio_int_type_t) ? 1 : -1])); /* add gpio_int_type_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_intr_type = 0;
}

void gpio_wakeup_enable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_wakeup_enable_CALL_INSTANCE));
  CMOCK_gpio_wakeup_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_wakeup_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_wakeup_enable_CallInstance = CMock_Guts_MemChain(Mock.gpio_wakeup_enable_CallInstance, cmock_guts_index);
  Mock.gpio_wakeup_enable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_wakeup_enable_IgnoreBool = (char)1;
}

void gpio_wakeup_enable_CMockStopIgnore(void)
{
  if(Mock.gpio_wakeup_enable_IgnoreBool)
    Mock.gpio_wakeup_enable_CallInstance = CMock_Guts_MemNext(Mock.gpio_wakeup_enable_CallInstance);
  Mock.gpio_wakeup_enable_IgnoreBool = (char)0;
}

void gpio_wakeup_enable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_int_type_t intr_type, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_wakeup_enable_CALL_INSTANCE));
  CMOCK_gpio_wakeup_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_wakeup_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_wakeup_enable_CallInstance = CMock_Guts_MemChain(Mock.gpio_wakeup_enable_CallInstance, cmock_guts_index);
  Mock.gpio_wakeup_enable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_wakeup_enable(cmock_call_instance, gpio_num, intr_type);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_wakeup_enable_AddCallback(CMOCK_gpio_wakeup_enable_CALLBACK Callback)
{
  Mock.gpio_wakeup_enable_IgnoreBool = (char)0;
  Mock.gpio_wakeup_enable_CallbackBool = (char)1;
  Mock.gpio_wakeup_enable_CallbackFunctionPointer = Callback;
}

void gpio_wakeup_enable_Stub(CMOCK_gpio_wakeup_enable_CALLBACK Callback)
{
  Mock.gpio_wakeup_enable_IgnoreBool = (char)0;
  Mock.gpio_wakeup_enable_CallbackBool = (char)0;
  Mock.gpio_wakeup_enable_CallbackFunctionPointer = Callback;
}

void gpio_wakeup_enable_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_wakeup_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_wakeup_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_wakeup_enable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_wakeup_enable_CMockIgnoreArg_intr_type(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_wakeup_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_wakeup_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_wakeup_enable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_intr_type = 1;
}

esp_err_t gpio_wakeup_disable(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_wakeup_disable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_wakeup_disable);
  cmock_call_instance = (CMOCK_gpio_wakeup_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_wakeup_disable_CallInstance);
  Mock.gpio_wakeup_disable_CallInstance = CMock_Guts_MemNext(Mock.gpio_wakeup_disable_CallInstance);
  if (Mock.gpio_wakeup_disable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_wakeup_disable_FinalReturn;
    memcpy((void*)(&Mock.gpio_wakeup_disable_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_wakeup_disable_CallbackBool &&
      Mock.gpio_wakeup_disable_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_wakeup_disable_CallbackFunctionPointer(gpio_num, Mock.gpio_wakeup_disable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_wakeup_disable,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_wakeup_disable_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_wakeup_disable_CallbackFunctionPointer(gpio_num, Mock.gpio_wakeup_disable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_wakeup_disable(CMOCK_gpio_wakeup_disable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_wakeup_disable(CMOCK_gpio_wakeup_disable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_wakeup_disable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_wakeup_disable_CALL_INSTANCE));
  CMOCK_gpio_wakeup_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_wakeup_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_wakeup_disable_CallInstance = CMock_Guts_MemChain(Mock.gpio_wakeup_disable_CallInstance, cmock_guts_index);
  Mock.gpio_wakeup_disable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_wakeup_disable_IgnoreBool = (char)1;
}

void gpio_wakeup_disable_CMockStopIgnore(void)
{
  if(Mock.gpio_wakeup_disable_IgnoreBool)
    Mock.gpio_wakeup_disable_CallInstance = CMock_Guts_MemNext(Mock.gpio_wakeup_disable_CallInstance);
  Mock.gpio_wakeup_disable_IgnoreBool = (char)0;
}

void gpio_wakeup_disable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_wakeup_disable_CALL_INSTANCE));
  CMOCK_gpio_wakeup_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_wakeup_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_wakeup_disable_CallInstance = CMock_Guts_MemChain(Mock.gpio_wakeup_disable_CallInstance, cmock_guts_index);
  Mock.gpio_wakeup_disable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_wakeup_disable(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_wakeup_disable_AddCallback(CMOCK_gpio_wakeup_disable_CALLBACK Callback)
{
  Mock.gpio_wakeup_disable_IgnoreBool = (char)0;
  Mock.gpio_wakeup_disable_CallbackBool = (char)1;
  Mock.gpio_wakeup_disable_CallbackFunctionPointer = Callback;
}

void gpio_wakeup_disable_Stub(CMOCK_gpio_wakeup_disable_CALLBACK Callback)
{
  Mock.gpio_wakeup_disable_IgnoreBool = (char)0;
  Mock.gpio_wakeup_disable_CallbackBool = (char)0;
  Mock.gpio_wakeup_disable_CallbackFunctionPointer = Callback;
}

void gpio_wakeup_disable_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_wakeup_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_wakeup_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_wakeup_disable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_isr_register(cmock_gpio_func_ptr1 fn, void* arg, int intr_alloc_flags, gpio_isr_handle_t* handle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_isr_register);
  cmock_call_instance = (CMOCK_gpio_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_isr_register_CallInstance);
  Mock.gpio_isr_register_CallInstance = CMock_Guts_MemNext(Mock.gpio_isr_register_CallInstance);
  if (Mock.gpio_isr_register_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_isr_register_FinalReturn;
    memcpy((void*)(&Mock.gpio_isr_register_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_isr_register_CallbackBool &&
      Mock.gpio_isr_register_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_isr_register_CallbackFunctionPointer(fn, arg, intr_alloc_flags, handle, Mock.gpio_isr_register_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_fn)
  {
    UNITY_SET_DETAILS(CMockString_gpio_isr_register,CMockString_fn);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_fn, fn, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_arg)
  {
    UNITY_SET_DETAILS(CMockString_gpio_isr_register,CMockString_arg);
    if (cmock_call_instance->Expected_arg == NULL)
      { UNITY_TEST_ASSERT_NULL(arg, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_arg, arg, cmock_call_instance->Expected_arg_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_intr_alloc_flags)
  {
    UNITY_SET_DETAILS(CMockString_gpio_isr_register,CMockString_intr_alloc_flags);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_intr_alloc_flags, intr_alloc_flags, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_handle)
  {
    UNITY_SET_DETAILS(CMockString_gpio_isr_register,CMockString_handle);
    if (cmock_call_instance->Expected_handle == NULL)
      { UNITY_TEST_ASSERT_NULL(handle, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_handle), (void*)(handle), sizeof(gpio_isr_handle_t), cmock_call_instance->Expected_handle_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.gpio_isr_register_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_isr_register_CallbackFunctionPointer(fn, arg, intr_alloc_flags, handle, Mock.gpio_isr_register_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_arg_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(arg, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)arg, (void*)cmock_call_instance->ReturnThruPtr_arg_Val,
      cmock_call_instance->ReturnThruPtr_arg_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_handle_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(handle, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)handle, (void*)cmock_call_instance->ReturnThruPtr_handle_Val,
      cmock_call_instance->ReturnThruPtr_handle_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_isr_register(CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance, cmock_gpio_func_ptr1 fn, void* arg, int arg_Depth, int intr_alloc_flags, gpio_isr_handle_t* handle, int handle_Depth);
void CMockExpectParameters_gpio_isr_register(CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance, cmock_gpio_func_ptr1 fn, void* arg, int arg_Depth, int intr_alloc_flags, gpio_isr_handle_t* handle, int handle_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_fn), (void*)(&fn),
         sizeof(cmock_gpio_func_ptr1[sizeof(fn) == sizeof(cmock_gpio_func_ptr1) ? 1 : -1])); /* add cmock_gpio_func_ptr1 to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_fn = 0;
  cmock_call_instance->Expected_arg = arg;
  cmock_call_instance->Expected_arg_Depth = arg_Depth;
  cmock_call_instance->IgnoreArg_arg = 0;
  cmock_call_instance->ReturnThruPtr_arg_Used = 0;
  cmock_call_instance->Expected_intr_alloc_flags = intr_alloc_flags;
  cmock_call_instance->IgnoreArg_intr_alloc_flags = 0;
  cmock_call_instance->Expected_handle = handle;
  cmock_call_instance->Expected_handle_Depth = handle_Depth;
  cmock_call_instance->IgnoreArg_handle = 0;
  cmock_call_instance->ReturnThruPtr_handle_Used = 0;
}

void gpio_isr_register_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_isr_register_CALL_INSTANCE));
  CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_isr_register_CallInstance = CMock_Guts_MemChain(Mock.gpio_isr_register_CallInstance, cmock_guts_index);
  Mock.gpio_isr_register_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_isr_register_IgnoreBool = (char)1;
}

void gpio_isr_register_CMockStopIgnore(void)
{
  if(Mock.gpio_isr_register_IgnoreBool)
    Mock.gpio_isr_register_CallInstance = CMock_Guts_MemNext(Mock.gpio_isr_register_CallInstance);
  Mock.gpio_isr_register_IgnoreBool = (char)0;
}

void gpio_isr_register_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, cmock_gpio_func_ptr1 fn, void* arg, int intr_alloc_flags, gpio_isr_handle_t* handle, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_isr_register_CALL_INSTANCE));
  CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_isr_register_CallInstance = CMock_Guts_MemChain(Mock.gpio_isr_register_CallInstance, cmock_guts_index);
  Mock.gpio_isr_register_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_isr_register(cmock_call_instance, fn, arg, 1, intr_alloc_flags, handle, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_isr_register_AddCallback(CMOCK_gpio_isr_register_CALLBACK Callback)
{
  Mock.gpio_isr_register_IgnoreBool = (char)0;
  Mock.gpio_isr_register_CallbackBool = (char)1;
  Mock.gpio_isr_register_CallbackFunctionPointer = Callback;
}

void gpio_isr_register_Stub(CMOCK_gpio_isr_register_CALLBACK Callback)
{
  Mock.gpio_isr_register_IgnoreBool = (char)0;
  Mock.gpio_isr_register_CallbackBool = (char)0;
  Mock.gpio_isr_register_CallbackFunctionPointer = Callback;
}

void gpio_isr_register_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, cmock_gpio_func_ptr1 fn, void* arg, int arg_Depth, int intr_alloc_flags, gpio_isr_handle_t* handle, int handle_Depth, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_isr_register_CALL_INSTANCE));
  CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_isr_register_CallInstance = CMock_Guts_MemChain(Mock.gpio_isr_register_CallInstance, cmock_guts_index);
  Mock.gpio_isr_register_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_isr_register(cmock_call_instance, fn, arg, arg_Depth, intr_alloc_flags, handle, handle_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gpio_isr_register_CMockReturnMemThruPtr_arg(UNITY_LINE_TYPE cmock_line, void* arg, size_t cmock_size)
{
  CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_arg_Used = 1;
  cmock_call_instance->ReturnThruPtr_arg_Val = arg;
  cmock_call_instance->ReturnThruPtr_arg_Size = cmock_size;
}

void gpio_isr_register_CMockReturnMemThruPtr_handle(UNITY_LINE_TYPE cmock_line, gpio_isr_handle_t* handle, size_t cmock_size)
{
  CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_handle_Used = 1;
  cmock_call_instance->ReturnThruPtr_handle_Val = handle;
  cmock_call_instance->ReturnThruPtr_handle_Size = cmock_size;
}

void gpio_isr_register_CMockIgnoreArg_fn(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fn = 1;
}

void gpio_isr_register_CMockIgnoreArg_arg(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_arg = 1;
}

void gpio_isr_register_CMockIgnoreArg_intr_alloc_flags(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_intr_alloc_flags = 1;
}

void gpio_isr_register_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_handle = 1;
}

esp_err_t gpio_pullup_en(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_pullup_en_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_pullup_en);
  cmock_call_instance = (CMOCK_gpio_pullup_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_pullup_en_CallInstance);
  Mock.gpio_pullup_en_CallInstance = CMock_Guts_MemNext(Mock.gpio_pullup_en_CallInstance);
  if (Mock.gpio_pullup_en_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_pullup_en_FinalReturn;
    memcpy((void*)(&Mock.gpio_pullup_en_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_pullup_en_CallbackBool &&
      Mock.gpio_pullup_en_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_pullup_en_CallbackFunctionPointer(gpio_num, Mock.gpio_pullup_en_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_pullup_en,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_pullup_en_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_pullup_en_CallbackFunctionPointer(gpio_num, Mock.gpio_pullup_en_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_pullup_en(CMOCK_gpio_pullup_en_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_pullup_en(CMOCK_gpio_pullup_en_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_pullup_en_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_pullup_en_CALL_INSTANCE));
  CMOCK_gpio_pullup_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pullup_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_pullup_en_CallInstance = CMock_Guts_MemChain(Mock.gpio_pullup_en_CallInstance, cmock_guts_index);
  Mock.gpio_pullup_en_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_pullup_en_IgnoreBool = (char)1;
}

void gpio_pullup_en_CMockStopIgnore(void)
{
  if(Mock.gpio_pullup_en_IgnoreBool)
    Mock.gpio_pullup_en_CallInstance = CMock_Guts_MemNext(Mock.gpio_pullup_en_CallInstance);
  Mock.gpio_pullup_en_IgnoreBool = (char)0;
}

void gpio_pullup_en_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_pullup_en_CALL_INSTANCE));
  CMOCK_gpio_pullup_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pullup_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_pullup_en_CallInstance = CMock_Guts_MemChain(Mock.gpio_pullup_en_CallInstance, cmock_guts_index);
  Mock.gpio_pullup_en_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_pullup_en(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_pullup_en_AddCallback(CMOCK_gpio_pullup_en_CALLBACK Callback)
{
  Mock.gpio_pullup_en_IgnoreBool = (char)0;
  Mock.gpio_pullup_en_CallbackBool = (char)1;
  Mock.gpio_pullup_en_CallbackFunctionPointer = Callback;
}

void gpio_pullup_en_Stub(CMOCK_gpio_pullup_en_CALLBACK Callback)
{
  Mock.gpio_pullup_en_IgnoreBool = (char)0;
  Mock.gpio_pullup_en_CallbackBool = (char)0;
  Mock.gpio_pullup_en_CallbackFunctionPointer = Callback;
}

void gpio_pullup_en_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_pullup_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pullup_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_pullup_en_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_pullup_dis(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_pullup_dis_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_pullup_dis);
  cmock_call_instance = (CMOCK_gpio_pullup_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_pullup_dis_CallInstance);
  Mock.gpio_pullup_dis_CallInstance = CMock_Guts_MemNext(Mock.gpio_pullup_dis_CallInstance);
  if (Mock.gpio_pullup_dis_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_pullup_dis_FinalReturn;
    memcpy((void*)(&Mock.gpio_pullup_dis_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_pullup_dis_CallbackBool &&
      Mock.gpio_pullup_dis_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_pullup_dis_CallbackFunctionPointer(gpio_num, Mock.gpio_pullup_dis_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_pullup_dis,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_pullup_dis_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_pullup_dis_CallbackFunctionPointer(gpio_num, Mock.gpio_pullup_dis_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_pullup_dis(CMOCK_gpio_pullup_dis_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_pullup_dis(CMOCK_gpio_pullup_dis_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_pullup_dis_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_pullup_dis_CALL_INSTANCE));
  CMOCK_gpio_pullup_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pullup_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_pullup_dis_CallInstance = CMock_Guts_MemChain(Mock.gpio_pullup_dis_CallInstance, cmock_guts_index);
  Mock.gpio_pullup_dis_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_pullup_dis_IgnoreBool = (char)1;
}

void gpio_pullup_dis_CMockStopIgnore(void)
{
  if(Mock.gpio_pullup_dis_IgnoreBool)
    Mock.gpio_pullup_dis_CallInstance = CMock_Guts_MemNext(Mock.gpio_pullup_dis_CallInstance);
  Mock.gpio_pullup_dis_IgnoreBool = (char)0;
}

void gpio_pullup_dis_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_pullup_dis_CALL_INSTANCE));
  CMOCK_gpio_pullup_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pullup_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_pullup_dis_CallInstance = CMock_Guts_MemChain(Mock.gpio_pullup_dis_CallInstance, cmock_guts_index);
  Mock.gpio_pullup_dis_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_pullup_dis(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_pullup_dis_AddCallback(CMOCK_gpio_pullup_dis_CALLBACK Callback)
{
  Mock.gpio_pullup_dis_IgnoreBool = (char)0;
  Mock.gpio_pullup_dis_CallbackBool = (char)1;
  Mock.gpio_pullup_dis_CallbackFunctionPointer = Callback;
}

void gpio_pullup_dis_Stub(CMOCK_gpio_pullup_dis_CALLBACK Callback)
{
  Mock.gpio_pullup_dis_IgnoreBool = (char)0;
  Mock.gpio_pullup_dis_CallbackBool = (char)0;
  Mock.gpio_pullup_dis_CallbackFunctionPointer = Callback;
}

void gpio_pullup_dis_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_pullup_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pullup_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_pullup_dis_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_pulldown_en(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_pulldown_en_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_pulldown_en);
  cmock_call_instance = (CMOCK_gpio_pulldown_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_pulldown_en_CallInstance);
  Mock.gpio_pulldown_en_CallInstance = CMock_Guts_MemNext(Mock.gpio_pulldown_en_CallInstance);
  if (Mock.gpio_pulldown_en_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_pulldown_en_FinalReturn;
    memcpy((void*)(&Mock.gpio_pulldown_en_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_pulldown_en_CallbackBool &&
      Mock.gpio_pulldown_en_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_pulldown_en_CallbackFunctionPointer(gpio_num, Mock.gpio_pulldown_en_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_pulldown_en,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_pulldown_en_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_pulldown_en_CallbackFunctionPointer(gpio_num, Mock.gpio_pulldown_en_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_pulldown_en(CMOCK_gpio_pulldown_en_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_pulldown_en(CMOCK_gpio_pulldown_en_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_pulldown_en_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_pulldown_en_CALL_INSTANCE));
  CMOCK_gpio_pulldown_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pulldown_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_pulldown_en_CallInstance = CMock_Guts_MemChain(Mock.gpio_pulldown_en_CallInstance, cmock_guts_index);
  Mock.gpio_pulldown_en_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_pulldown_en_IgnoreBool = (char)1;
}

void gpio_pulldown_en_CMockStopIgnore(void)
{
  if(Mock.gpio_pulldown_en_IgnoreBool)
    Mock.gpio_pulldown_en_CallInstance = CMock_Guts_MemNext(Mock.gpio_pulldown_en_CallInstance);
  Mock.gpio_pulldown_en_IgnoreBool = (char)0;
}

void gpio_pulldown_en_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_pulldown_en_CALL_INSTANCE));
  CMOCK_gpio_pulldown_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pulldown_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_pulldown_en_CallInstance = CMock_Guts_MemChain(Mock.gpio_pulldown_en_CallInstance, cmock_guts_index);
  Mock.gpio_pulldown_en_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_pulldown_en(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_pulldown_en_AddCallback(CMOCK_gpio_pulldown_en_CALLBACK Callback)
{
  Mock.gpio_pulldown_en_IgnoreBool = (char)0;
  Mock.gpio_pulldown_en_CallbackBool = (char)1;
  Mock.gpio_pulldown_en_CallbackFunctionPointer = Callback;
}

void gpio_pulldown_en_Stub(CMOCK_gpio_pulldown_en_CALLBACK Callback)
{
  Mock.gpio_pulldown_en_IgnoreBool = (char)0;
  Mock.gpio_pulldown_en_CallbackBool = (char)0;
  Mock.gpio_pulldown_en_CallbackFunctionPointer = Callback;
}

void gpio_pulldown_en_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_pulldown_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pulldown_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_pulldown_en_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_pulldown_dis(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_pulldown_dis_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_pulldown_dis);
  cmock_call_instance = (CMOCK_gpio_pulldown_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_pulldown_dis_CallInstance);
  Mock.gpio_pulldown_dis_CallInstance = CMock_Guts_MemNext(Mock.gpio_pulldown_dis_CallInstance);
  if (Mock.gpio_pulldown_dis_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_pulldown_dis_FinalReturn;
    memcpy((void*)(&Mock.gpio_pulldown_dis_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_pulldown_dis_CallbackBool &&
      Mock.gpio_pulldown_dis_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_pulldown_dis_CallbackFunctionPointer(gpio_num, Mock.gpio_pulldown_dis_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_pulldown_dis,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_pulldown_dis_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_pulldown_dis_CallbackFunctionPointer(gpio_num, Mock.gpio_pulldown_dis_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_pulldown_dis(CMOCK_gpio_pulldown_dis_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_pulldown_dis(CMOCK_gpio_pulldown_dis_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_pulldown_dis_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_pulldown_dis_CALL_INSTANCE));
  CMOCK_gpio_pulldown_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pulldown_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_pulldown_dis_CallInstance = CMock_Guts_MemChain(Mock.gpio_pulldown_dis_CallInstance, cmock_guts_index);
  Mock.gpio_pulldown_dis_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_pulldown_dis_IgnoreBool = (char)1;
}

void gpio_pulldown_dis_CMockStopIgnore(void)
{
  if(Mock.gpio_pulldown_dis_IgnoreBool)
    Mock.gpio_pulldown_dis_CallInstance = CMock_Guts_MemNext(Mock.gpio_pulldown_dis_CallInstance);
  Mock.gpio_pulldown_dis_IgnoreBool = (char)0;
}

void gpio_pulldown_dis_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_pulldown_dis_CALL_INSTANCE));
  CMOCK_gpio_pulldown_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pulldown_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_pulldown_dis_CallInstance = CMock_Guts_MemChain(Mock.gpio_pulldown_dis_CallInstance, cmock_guts_index);
  Mock.gpio_pulldown_dis_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_pulldown_dis(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_pulldown_dis_AddCallback(CMOCK_gpio_pulldown_dis_CALLBACK Callback)
{
  Mock.gpio_pulldown_dis_IgnoreBool = (char)0;
  Mock.gpio_pulldown_dis_CallbackBool = (char)1;
  Mock.gpio_pulldown_dis_CallbackFunctionPointer = Callback;
}

void gpio_pulldown_dis_Stub(CMOCK_gpio_pulldown_dis_CALLBACK Callback)
{
  Mock.gpio_pulldown_dis_IgnoreBool = (char)0;
  Mock.gpio_pulldown_dis_CallbackBool = (char)0;
  Mock.gpio_pulldown_dis_CallbackFunctionPointer = Callback;
}

void gpio_pulldown_dis_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_pulldown_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_pulldown_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_pulldown_dis_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_install_isr_service(int intr_alloc_flags)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_install_isr_service_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_install_isr_service);
  cmock_call_instance = (CMOCK_gpio_install_isr_service_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_install_isr_service_CallInstance);
  Mock.gpio_install_isr_service_CallInstance = CMock_Guts_MemNext(Mock.gpio_install_isr_service_CallInstance);
  if (Mock.gpio_install_isr_service_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_install_isr_service_FinalReturn;
    memcpy((void*)(&Mock.gpio_install_isr_service_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_install_isr_service_CallbackBool &&
      Mock.gpio_install_isr_service_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_install_isr_service_CallbackFunctionPointer(intr_alloc_flags, Mock.gpio_install_isr_service_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_intr_alloc_flags)
  {
    UNITY_SET_DETAILS(CMockString_gpio_install_isr_service,CMockString_intr_alloc_flags);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_intr_alloc_flags, intr_alloc_flags, cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_install_isr_service_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_install_isr_service_CallbackFunctionPointer(intr_alloc_flags, Mock.gpio_install_isr_service_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_install_isr_service(CMOCK_gpio_install_isr_service_CALL_INSTANCE* cmock_call_instance, int intr_alloc_flags);
void CMockExpectParameters_gpio_install_isr_service(CMOCK_gpio_install_isr_service_CALL_INSTANCE* cmock_call_instance, int intr_alloc_flags)
{
  cmock_call_instance->Expected_intr_alloc_flags = intr_alloc_flags;
  cmock_call_instance->IgnoreArg_intr_alloc_flags = 0;
}

void gpio_install_isr_service_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_install_isr_service_CALL_INSTANCE));
  CMOCK_gpio_install_isr_service_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_install_isr_service_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_install_isr_service_CallInstance = CMock_Guts_MemChain(Mock.gpio_install_isr_service_CallInstance, cmock_guts_index);
  Mock.gpio_install_isr_service_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_install_isr_service_IgnoreBool = (char)1;
}

void gpio_install_isr_service_CMockStopIgnore(void)
{
  if(Mock.gpio_install_isr_service_IgnoreBool)
    Mock.gpio_install_isr_service_CallInstance = CMock_Guts_MemNext(Mock.gpio_install_isr_service_CallInstance);
  Mock.gpio_install_isr_service_IgnoreBool = (char)0;
}

void gpio_install_isr_service_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int intr_alloc_flags, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_install_isr_service_CALL_INSTANCE));
  CMOCK_gpio_install_isr_service_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_install_isr_service_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_install_isr_service_CallInstance = CMock_Guts_MemChain(Mock.gpio_install_isr_service_CallInstance, cmock_guts_index);
  Mock.gpio_install_isr_service_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_install_isr_service(cmock_call_instance, intr_alloc_flags);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_install_isr_service_AddCallback(CMOCK_gpio_install_isr_service_CALLBACK Callback)
{
  Mock.gpio_install_isr_service_IgnoreBool = (char)0;
  Mock.gpio_install_isr_service_CallbackBool = (char)1;
  Mock.gpio_install_isr_service_CallbackFunctionPointer = Callback;
}

void gpio_install_isr_service_Stub(CMOCK_gpio_install_isr_service_CALLBACK Callback)
{
  Mock.gpio_install_isr_service_IgnoreBool = (char)0;
  Mock.gpio_install_isr_service_CallbackBool = (char)0;
  Mock.gpio_install_isr_service_CallbackFunctionPointer = Callback;
}

void gpio_install_isr_service_CMockIgnoreArg_intr_alloc_flags(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_install_isr_service_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_install_isr_service_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_install_isr_service_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_intr_alloc_flags = 1;
}

void gpio_uninstall_isr_service(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_uninstall_isr_service_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_uninstall_isr_service);
  cmock_call_instance = (CMOCK_gpio_uninstall_isr_service_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_uninstall_isr_service_CallInstance);
  Mock.gpio_uninstall_isr_service_CallInstance = CMock_Guts_MemNext(Mock.gpio_uninstall_isr_service_CallInstance);
  if (Mock.gpio_uninstall_isr_service_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.gpio_uninstall_isr_service_CallbackBool &&
      Mock.gpio_uninstall_isr_service_CallbackFunctionPointer != NULL)
  {
    Mock.gpio_uninstall_isr_service_CallbackFunctionPointer(Mock.gpio_uninstall_isr_service_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.gpio_uninstall_isr_service_CallbackFunctionPointer != NULL)
  {
    Mock.gpio_uninstall_isr_service_CallbackFunctionPointer(Mock.gpio_uninstall_isr_service_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void gpio_uninstall_isr_service_CMockIgnore(void)
{
  Mock.gpio_uninstall_isr_service_IgnoreBool = (char)1;
}

void gpio_uninstall_isr_service_CMockStopIgnore(void)
{
  Mock.gpio_uninstall_isr_service_IgnoreBool = (char)0;
}

void gpio_uninstall_isr_service_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_uninstall_isr_service_CALL_INSTANCE));
  CMOCK_gpio_uninstall_isr_service_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_uninstall_isr_service_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_uninstall_isr_service_CallInstance = CMock_Guts_MemChain(Mock.gpio_uninstall_isr_service_CallInstance, cmock_guts_index);
  Mock.gpio_uninstall_isr_service_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void gpio_uninstall_isr_service_AddCallback(CMOCK_gpio_uninstall_isr_service_CALLBACK Callback)
{
  Mock.gpio_uninstall_isr_service_IgnoreBool = (char)0;
  Mock.gpio_uninstall_isr_service_CallbackBool = (char)1;
  Mock.gpio_uninstall_isr_service_CallbackFunctionPointer = Callback;
}

void gpio_uninstall_isr_service_Stub(CMOCK_gpio_uninstall_isr_service_CALLBACK Callback)
{
  Mock.gpio_uninstall_isr_service_IgnoreBool = (char)0;
  Mock.gpio_uninstall_isr_service_CallbackBool = (char)0;
  Mock.gpio_uninstall_isr_service_CallbackFunctionPointer = Callback;
}

esp_err_t gpio_isr_handler_add(gpio_num_t gpio_num, gpio_isr_t isr_handler, void* args)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_isr_handler_add_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_isr_handler_add);
  cmock_call_instance = (CMOCK_gpio_isr_handler_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_isr_handler_add_CallInstance);
  Mock.gpio_isr_handler_add_CallInstance = CMock_Guts_MemNext(Mock.gpio_isr_handler_add_CallInstance);
  if (Mock.gpio_isr_handler_add_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_isr_handler_add_FinalReturn;
    memcpy((void*)(&Mock.gpio_isr_handler_add_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_isr_handler_add_CallbackBool &&
      Mock.gpio_isr_handler_add_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_isr_handler_add_CallbackFunctionPointer(gpio_num, isr_handler, args, Mock.gpio_isr_handler_add_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_isr_handler_add,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_isr_handler)
  {
    UNITY_SET_DETAILS(CMockString_gpio_isr_handler_add,CMockString_isr_handler);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_isr_handler), (void*)(&isr_handler), sizeof(gpio_isr_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_args)
  {
    UNITY_SET_DETAILS(CMockString_gpio_isr_handler_add,CMockString_args);
    if (cmock_call_instance->Expected_args == NULL)
      { UNITY_TEST_ASSERT_NULL(args, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_args, args, cmock_call_instance->Expected_args_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.gpio_isr_handler_add_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_isr_handler_add_CallbackFunctionPointer(gpio_num, isr_handler, args, Mock.gpio_isr_handler_add_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_args_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(args, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)args, (void*)cmock_call_instance->ReturnThruPtr_args_Val,
      cmock_call_instance->ReturnThruPtr_args_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_isr_handler_add(CMOCK_gpio_isr_handler_add_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_isr_t isr_handler, void* args, int args_Depth);
void CMockExpectParameters_gpio_isr_handler_add(CMOCK_gpio_isr_handler_add_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_isr_t isr_handler, void* args, int args_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  memcpy((void*)(&cmock_call_instance->Expected_isr_handler), (void*)(&isr_handler),
         sizeof(gpio_isr_t[sizeof(isr_handler) == sizeof(gpio_isr_t) ? 1 : -1])); /* add gpio_isr_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_isr_handler = 0;
  cmock_call_instance->Expected_args = args;
  cmock_call_instance->Expected_args_Depth = args_Depth;
  cmock_call_instance->IgnoreArg_args = 0;
  cmock_call_instance->ReturnThruPtr_args_Used = 0;
}

void gpio_isr_handler_add_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_isr_handler_add_CALL_INSTANCE));
  CMOCK_gpio_isr_handler_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_handler_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_isr_handler_add_CallInstance = CMock_Guts_MemChain(Mock.gpio_isr_handler_add_CallInstance, cmock_guts_index);
  Mock.gpio_isr_handler_add_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_isr_handler_add_IgnoreBool = (char)1;
}

void gpio_isr_handler_add_CMockStopIgnore(void)
{
  if(Mock.gpio_isr_handler_add_IgnoreBool)
    Mock.gpio_isr_handler_add_CallInstance = CMock_Guts_MemNext(Mock.gpio_isr_handler_add_CallInstance);
  Mock.gpio_isr_handler_add_IgnoreBool = (char)0;
}

void gpio_isr_handler_add_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_isr_t isr_handler, void* args, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_isr_handler_add_CALL_INSTANCE));
  CMOCK_gpio_isr_handler_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_handler_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_isr_handler_add_CallInstance = CMock_Guts_MemChain(Mock.gpio_isr_handler_add_CallInstance, cmock_guts_index);
  Mock.gpio_isr_handler_add_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_isr_handler_add(cmock_call_instance, gpio_num, isr_handler, args, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_isr_handler_add_AddCallback(CMOCK_gpio_isr_handler_add_CALLBACK Callback)
{
  Mock.gpio_isr_handler_add_IgnoreBool = (char)0;
  Mock.gpio_isr_handler_add_CallbackBool = (char)1;
  Mock.gpio_isr_handler_add_CallbackFunctionPointer = Callback;
}

void gpio_isr_handler_add_Stub(CMOCK_gpio_isr_handler_add_CALLBACK Callback)
{
  Mock.gpio_isr_handler_add_IgnoreBool = (char)0;
  Mock.gpio_isr_handler_add_CallbackBool = (char)0;
  Mock.gpio_isr_handler_add_CallbackFunctionPointer = Callback;
}

void gpio_isr_handler_add_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_isr_t isr_handler, void* args, int args_Depth, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_isr_handler_add_CALL_INSTANCE));
  CMOCK_gpio_isr_handler_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_handler_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_isr_handler_add_CallInstance = CMock_Guts_MemChain(Mock.gpio_isr_handler_add_CallInstance, cmock_guts_index);
  Mock.gpio_isr_handler_add_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_isr_handler_add(cmock_call_instance, gpio_num, isr_handler, args, args_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gpio_isr_handler_add_CMockReturnMemThruPtr_args(UNITY_LINE_TYPE cmock_line, void* args, size_t cmock_size)
{
  CMOCK_gpio_isr_handler_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_handler_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_isr_handler_add_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_args_Used = 1;
  cmock_call_instance->ReturnThruPtr_args_Val = args;
  cmock_call_instance->ReturnThruPtr_args_Size = cmock_size;
}

void gpio_isr_handler_add_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_isr_handler_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_handler_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_isr_handler_add_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_isr_handler_add_CMockIgnoreArg_isr_handler(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_isr_handler_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_handler_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_isr_handler_add_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_isr_handler = 1;
}

void gpio_isr_handler_add_CMockIgnoreArg_args(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_isr_handler_add_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_handler_add_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_isr_handler_add_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_args = 1;
}

esp_err_t gpio_isr_handler_remove(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_isr_handler_remove_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_isr_handler_remove);
  cmock_call_instance = (CMOCK_gpio_isr_handler_remove_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_isr_handler_remove_CallInstance);
  Mock.gpio_isr_handler_remove_CallInstance = CMock_Guts_MemNext(Mock.gpio_isr_handler_remove_CallInstance);
  if (Mock.gpio_isr_handler_remove_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_isr_handler_remove_FinalReturn;
    memcpy((void*)(&Mock.gpio_isr_handler_remove_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_isr_handler_remove_CallbackBool &&
      Mock.gpio_isr_handler_remove_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_isr_handler_remove_CallbackFunctionPointer(gpio_num, Mock.gpio_isr_handler_remove_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_isr_handler_remove,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_isr_handler_remove_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_isr_handler_remove_CallbackFunctionPointer(gpio_num, Mock.gpio_isr_handler_remove_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_isr_handler_remove(CMOCK_gpio_isr_handler_remove_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_isr_handler_remove(CMOCK_gpio_isr_handler_remove_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_isr_handler_remove_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_isr_handler_remove_CALL_INSTANCE));
  CMOCK_gpio_isr_handler_remove_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_handler_remove_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_isr_handler_remove_CallInstance = CMock_Guts_MemChain(Mock.gpio_isr_handler_remove_CallInstance, cmock_guts_index);
  Mock.gpio_isr_handler_remove_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_isr_handler_remove_IgnoreBool = (char)1;
}

void gpio_isr_handler_remove_CMockStopIgnore(void)
{
  if(Mock.gpio_isr_handler_remove_IgnoreBool)
    Mock.gpio_isr_handler_remove_CallInstance = CMock_Guts_MemNext(Mock.gpio_isr_handler_remove_CallInstance);
  Mock.gpio_isr_handler_remove_IgnoreBool = (char)0;
}

void gpio_isr_handler_remove_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_isr_handler_remove_CALL_INSTANCE));
  CMOCK_gpio_isr_handler_remove_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_handler_remove_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_isr_handler_remove_CallInstance = CMock_Guts_MemChain(Mock.gpio_isr_handler_remove_CallInstance, cmock_guts_index);
  Mock.gpio_isr_handler_remove_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_isr_handler_remove(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_isr_handler_remove_AddCallback(CMOCK_gpio_isr_handler_remove_CALLBACK Callback)
{
  Mock.gpio_isr_handler_remove_IgnoreBool = (char)0;
  Mock.gpio_isr_handler_remove_CallbackBool = (char)1;
  Mock.gpio_isr_handler_remove_CallbackFunctionPointer = Callback;
}

void gpio_isr_handler_remove_Stub(CMOCK_gpio_isr_handler_remove_CALLBACK Callback)
{
  Mock.gpio_isr_handler_remove_IgnoreBool = (char)0;
  Mock.gpio_isr_handler_remove_CallbackBool = (char)0;
  Mock.gpio_isr_handler_remove_CallbackFunctionPointer = Callback;
}

void gpio_isr_handler_remove_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_isr_handler_remove_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_isr_handler_remove_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_isr_handler_remove_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_set_drive_capability(gpio_num_t gpio_num, gpio_drive_cap_t strength)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_set_drive_capability_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_set_drive_capability);
  cmock_call_instance = (CMOCK_gpio_set_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_set_drive_capability_CallInstance);
  Mock.gpio_set_drive_capability_CallInstance = CMock_Guts_MemNext(Mock.gpio_set_drive_capability_CallInstance);
  if (Mock.gpio_set_drive_capability_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_set_drive_capability_FinalReturn;
    memcpy((void*)(&Mock.gpio_set_drive_capability_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_set_drive_capability_CallbackBool &&
      Mock.gpio_set_drive_capability_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_set_drive_capability_CallbackFunctionPointer(gpio_num, strength, Mock.gpio_set_drive_capability_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_set_drive_capability,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_strength)
  {
    UNITY_SET_DETAILS(CMockString_gpio_set_drive_capability,CMockString_strength);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_strength), (void*)(&strength), sizeof(gpio_drive_cap_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_set_drive_capability_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_set_drive_capability_CallbackFunctionPointer(gpio_num, strength, Mock.gpio_set_drive_capability_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_set_drive_capability(CMOCK_gpio_set_drive_capability_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_drive_cap_t strength);
void CMockExpectParameters_gpio_set_drive_capability(CMOCK_gpio_set_drive_capability_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_drive_cap_t strength)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  memcpy((void*)(&cmock_call_instance->Expected_strength), (void*)(&strength),
         sizeof(gpio_drive_cap_t[sizeof(strength) == sizeof(gpio_drive_cap_t) ? 1 : -1])); /* add gpio_drive_cap_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_strength = 0;
}

void gpio_set_drive_capability_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_set_drive_capability_CALL_INSTANCE));
  CMOCK_gpio_set_drive_capability_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_set_drive_capability_CallInstance = CMock_Guts_MemChain(Mock.gpio_set_drive_capability_CallInstance, cmock_guts_index);
  Mock.gpio_set_drive_capability_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_set_drive_capability_IgnoreBool = (char)1;
}

void gpio_set_drive_capability_CMockStopIgnore(void)
{
  if(Mock.gpio_set_drive_capability_IgnoreBool)
    Mock.gpio_set_drive_capability_CallInstance = CMock_Guts_MemNext(Mock.gpio_set_drive_capability_CallInstance);
  Mock.gpio_set_drive_capability_IgnoreBool = (char)0;
}

void gpio_set_drive_capability_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_drive_cap_t strength, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_set_drive_capability_CALL_INSTANCE));
  CMOCK_gpio_set_drive_capability_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_set_drive_capability_CallInstance = CMock_Guts_MemChain(Mock.gpio_set_drive_capability_CallInstance, cmock_guts_index);
  Mock.gpio_set_drive_capability_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_set_drive_capability(cmock_call_instance, gpio_num, strength);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_set_drive_capability_AddCallback(CMOCK_gpio_set_drive_capability_CALLBACK Callback)
{
  Mock.gpio_set_drive_capability_IgnoreBool = (char)0;
  Mock.gpio_set_drive_capability_CallbackBool = (char)1;
  Mock.gpio_set_drive_capability_CallbackFunctionPointer = Callback;
}

void gpio_set_drive_capability_Stub(CMOCK_gpio_set_drive_capability_CALLBACK Callback)
{
  Mock.gpio_set_drive_capability_IgnoreBool = (char)0;
  Mock.gpio_set_drive_capability_CallbackBool = (char)0;
  Mock.gpio_set_drive_capability_CallbackFunctionPointer = Callback;
}

void gpio_set_drive_capability_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_set_drive_capability_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_set_drive_capability_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_set_drive_capability_CMockIgnoreArg_strength(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_set_drive_capability_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_set_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_set_drive_capability_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_strength = 1;
}

esp_err_t gpio_get_drive_capability(gpio_num_t gpio_num, gpio_drive_cap_t* strength)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_get_drive_capability_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_get_drive_capability);
  cmock_call_instance = (CMOCK_gpio_get_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_get_drive_capability_CallInstance);
  Mock.gpio_get_drive_capability_CallInstance = CMock_Guts_MemNext(Mock.gpio_get_drive_capability_CallInstance);
  if (Mock.gpio_get_drive_capability_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_get_drive_capability_FinalReturn;
    memcpy((void*)(&Mock.gpio_get_drive_capability_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_get_drive_capability_CallbackBool &&
      Mock.gpio_get_drive_capability_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_get_drive_capability_CallbackFunctionPointer(gpio_num, strength, Mock.gpio_get_drive_capability_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_get_drive_capability,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_strength)
  {
    UNITY_SET_DETAILS(CMockString_gpio_get_drive_capability,CMockString_strength);
    if (cmock_call_instance->Expected_strength == NULL)
      { UNITY_TEST_ASSERT_NULL(strength, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_strength), (void*)(strength), sizeof(gpio_drive_cap_t), cmock_call_instance->Expected_strength_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.gpio_get_drive_capability_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_get_drive_capability_CallbackFunctionPointer(gpio_num, strength, Mock.gpio_get_drive_capability_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_strength_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(strength, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)strength, (void*)cmock_call_instance->ReturnThruPtr_strength_Val,
      cmock_call_instance->ReturnThruPtr_strength_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_get_drive_capability(CMOCK_gpio_get_drive_capability_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_drive_cap_t* strength, int strength_Depth);
void CMockExpectParameters_gpio_get_drive_capability(CMOCK_gpio_get_drive_capability_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_drive_cap_t* strength, int strength_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  cmock_call_instance->Expected_strength = strength;
  cmock_call_instance->Expected_strength_Depth = strength_Depth;
  cmock_call_instance->IgnoreArg_strength = 0;
  cmock_call_instance->ReturnThruPtr_strength_Used = 0;
}

void gpio_get_drive_capability_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_get_drive_capability_CALL_INSTANCE));
  CMOCK_gpio_get_drive_capability_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_get_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_get_drive_capability_CallInstance = CMock_Guts_MemChain(Mock.gpio_get_drive_capability_CallInstance, cmock_guts_index);
  Mock.gpio_get_drive_capability_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_get_drive_capability_IgnoreBool = (char)1;
}

void gpio_get_drive_capability_CMockStopIgnore(void)
{
  if(Mock.gpio_get_drive_capability_IgnoreBool)
    Mock.gpio_get_drive_capability_CallInstance = CMock_Guts_MemNext(Mock.gpio_get_drive_capability_CallInstance);
  Mock.gpio_get_drive_capability_IgnoreBool = (char)0;
}

void gpio_get_drive_capability_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_drive_cap_t* strength, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_get_drive_capability_CALL_INSTANCE));
  CMOCK_gpio_get_drive_capability_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_get_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_get_drive_capability_CallInstance = CMock_Guts_MemChain(Mock.gpio_get_drive_capability_CallInstance, cmock_guts_index);
  Mock.gpio_get_drive_capability_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_get_drive_capability(cmock_call_instance, gpio_num, strength, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_get_drive_capability_AddCallback(CMOCK_gpio_get_drive_capability_CALLBACK Callback)
{
  Mock.gpio_get_drive_capability_IgnoreBool = (char)0;
  Mock.gpio_get_drive_capability_CallbackBool = (char)1;
  Mock.gpio_get_drive_capability_CallbackFunctionPointer = Callback;
}

void gpio_get_drive_capability_Stub(CMOCK_gpio_get_drive_capability_CALLBACK Callback)
{
  Mock.gpio_get_drive_capability_IgnoreBool = (char)0;
  Mock.gpio_get_drive_capability_CallbackBool = (char)0;
  Mock.gpio_get_drive_capability_CallbackFunctionPointer = Callback;
}

void gpio_get_drive_capability_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_drive_cap_t* strength, int strength_Depth, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_get_drive_capability_CALL_INSTANCE));
  CMOCK_gpio_get_drive_capability_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_get_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_get_drive_capability_CallInstance = CMock_Guts_MemChain(Mock.gpio_get_drive_capability_CallInstance, cmock_guts_index);
  Mock.gpio_get_drive_capability_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_get_drive_capability(cmock_call_instance, gpio_num, strength, strength_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void gpio_get_drive_capability_CMockReturnMemThruPtr_strength(UNITY_LINE_TYPE cmock_line, gpio_drive_cap_t* strength, size_t cmock_size)
{
  CMOCK_gpio_get_drive_capability_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_get_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_get_drive_capability_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_strength_Used = 1;
  cmock_call_instance->ReturnThruPtr_strength_Val = strength;
  cmock_call_instance->ReturnThruPtr_strength_Size = cmock_size;
}

void gpio_get_drive_capability_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_get_drive_capability_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_get_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_get_drive_capability_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_get_drive_capability_CMockIgnoreArg_strength(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_get_drive_capability_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_get_drive_capability_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_get_drive_capability_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_strength = 1;
}

esp_err_t gpio_hold_en(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_hold_en_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_hold_en);
  cmock_call_instance = (CMOCK_gpio_hold_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_hold_en_CallInstance);
  Mock.gpio_hold_en_CallInstance = CMock_Guts_MemNext(Mock.gpio_hold_en_CallInstance);
  if (Mock.gpio_hold_en_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_hold_en_FinalReturn;
    memcpy((void*)(&Mock.gpio_hold_en_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_hold_en_CallbackBool &&
      Mock.gpio_hold_en_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_hold_en_CallbackFunctionPointer(gpio_num, Mock.gpio_hold_en_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_hold_en,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_hold_en_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_hold_en_CallbackFunctionPointer(gpio_num, Mock.gpio_hold_en_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_hold_en(CMOCK_gpio_hold_en_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_hold_en(CMOCK_gpio_hold_en_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_hold_en_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_hold_en_CALL_INSTANCE));
  CMOCK_gpio_hold_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_hold_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_hold_en_CallInstance = CMock_Guts_MemChain(Mock.gpio_hold_en_CallInstance, cmock_guts_index);
  Mock.gpio_hold_en_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_hold_en_IgnoreBool = (char)1;
}

void gpio_hold_en_CMockStopIgnore(void)
{
  if(Mock.gpio_hold_en_IgnoreBool)
    Mock.gpio_hold_en_CallInstance = CMock_Guts_MemNext(Mock.gpio_hold_en_CallInstance);
  Mock.gpio_hold_en_IgnoreBool = (char)0;
}

void gpio_hold_en_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_hold_en_CALL_INSTANCE));
  CMOCK_gpio_hold_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_hold_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_hold_en_CallInstance = CMock_Guts_MemChain(Mock.gpio_hold_en_CallInstance, cmock_guts_index);
  Mock.gpio_hold_en_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_hold_en(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_hold_en_AddCallback(CMOCK_gpio_hold_en_CALLBACK Callback)
{
  Mock.gpio_hold_en_IgnoreBool = (char)0;
  Mock.gpio_hold_en_CallbackBool = (char)1;
  Mock.gpio_hold_en_CallbackFunctionPointer = Callback;
}

void gpio_hold_en_Stub(CMOCK_gpio_hold_en_CALLBACK Callback)
{
  Mock.gpio_hold_en_IgnoreBool = (char)0;
  Mock.gpio_hold_en_CallbackBool = (char)0;
  Mock.gpio_hold_en_CallbackFunctionPointer = Callback;
}

void gpio_hold_en_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_hold_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_hold_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_hold_en_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_hold_dis(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_hold_dis_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_hold_dis);
  cmock_call_instance = (CMOCK_gpio_hold_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_hold_dis_CallInstance);
  Mock.gpio_hold_dis_CallInstance = CMock_Guts_MemNext(Mock.gpio_hold_dis_CallInstance);
  if (Mock.gpio_hold_dis_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_hold_dis_FinalReturn;
    memcpy((void*)(&Mock.gpio_hold_dis_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_hold_dis_CallbackBool &&
      Mock.gpio_hold_dis_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_hold_dis_CallbackFunctionPointer(gpio_num, Mock.gpio_hold_dis_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_hold_dis,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_hold_dis_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_hold_dis_CallbackFunctionPointer(gpio_num, Mock.gpio_hold_dis_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_hold_dis(CMOCK_gpio_hold_dis_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_hold_dis(CMOCK_gpio_hold_dis_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_hold_dis_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_hold_dis_CALL_INSTANCE));
  CMOCK_gpio_hold_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_hold_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_hold_dis_CallInstance = CMock_Guts_MemChain(Mock.gpio_hold_dis_CallInstance, cmock_guts_index);
  Mock.gpio_hold_dis_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_hold_dis_IgnoreBool = (char)1;
}

void gpio_hold_dis_CMockStopIgnore(void)
{
  if(Mock.gpio_hold_dis_IgnoreBool)
    Mock.gpio_hold_dis_CallInstance = CMock_Guts_MemNext(Mock.gpio_hold_dis_CallInstance);
  Mock.gpio_hold_dis_IgnoreBool = (char)0;
}

void gpio_hold_dis_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_hold_dis_CALL_INSTANCE));
  CMOCK_gpio_hold_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_hold_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_hold_dis_CallInstance = CMock_Guts_MemChain(Mock.gpio_hold_dis_CallInstance, cmock_guts_index);
  Mock.gpio_hold_dis_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_hold_dis(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_hold_dis_AddCallback(CMOCK_gpio_hold_dis_CALLBACK Callback)
{
  Mock.gpio_hold_dis_IgnoreBool = (char)0;
  Mock.gpio_hold_dis_CallbackBool = (char)1;
  Mock.gpio_hold_dis_CallbackFunctionPointer = Callback;
}

void gpio_hold_dis_Stub(CMOCK_gpio_hold_dis_CALLBACK Callback)
{
  Mock.gpio_hold_dis_IgnoreBool = (char)0;
  Mock.gpio_hold_dis_CallbackBool = (char)0;
  Mock.gpio_hold_dis_CallbackFunctionPointer = Callback;
}

void gpio_hold_dis_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_hold_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_hold_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_hold_dis_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_deep_sleep_hold_en(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_deep_sleep_hold_en_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_deep_sleep_hold_en);
  cmock_call_instance = (CMOCK_gpio_deep_sleep_hold_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_deep_sleep_hold_en_CallInstance);
  Mock.gpio_deep_sleep_hold_en_CallInstance = CMock_Guts_MemNext(Mock.gpio_deep_sleep_hold_en_CallInstance);
  if (Mock.gpio_deep_sleep_hold_en_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.gpio_deep_sleep_hold_en_CallbackBool &&
      Mock.gpio_deep_sleep_hold_en_CallbackFunctionPointer != NULL)
  {
    Mock.gpio_deep_sleep_hold_en_CallbackFunctionPointer(Mock.gpio_deep_sleep_hold_en_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.gpio_deep_sleep_hold_en_CallbackFunctionPointer != NULL)
  {
    Mock.gpio_deep_sleep_hold_en_CallbackFunctionPointer(Mock.gpio_deep_sleep_hold_en_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void gpio_deep_sleep_hold_en_CMockIgnore(void)
{
  Mock.gpio_deep_sleep_hold_en_IgnoreBool = (char)1;
}

void gpio_deep_sleep_hold_en_CMockStopIgnore(void)
{
  Mock.gpio_deep_sleep_hold_en_IgnoreBool = (char)0;
}

void gpio_deep_sleep_hold_en_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_deep_sleep_hold_en_CALL_INSTANCE));
  CMOCK_gpio_deep_sleep_hold_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_deep_sleep_hold_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_deep_sleep_hold_en_CallInstance = CMock_Guts_MemChain(Mock.gpio_deep_sleep_hold_en_CallInstance, cmock_guts_index);
  Mock.gpio_deep_sleep_hold_en_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void gpio_deep_sleep_hold_en_AddCallback(CMOCK_gpio_deep_sleep_hold_en_CALLBACK Callback)
{
  Mock.gpio_deep_sleep_hold_en_IgnoreBool = (char)0;
  Mock.gpio_deep_sleep_hold_en_CallbackBool = (char)1;
  Mock.gpio_deep_sleep_hold_en_CallbackFunctionPointer = Callback;
}

void gpio_deep_sleep_hold_en_Stub(CMOCK_gpio_deep_sleep_hold_en_CALLBACK Callback)
{
  Mock.gpio_deep_sleep_hold_en_IgnoreBool = (char)0;
  Mock.gpio_deep_sleep_hold_en_CallbackBool = (char)0;
  Mock.gpio_deep_sleep_hold_en_CallbackFunctionPointer = Callback;
}

void gpio_deep_sleep_hold_dis(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_deep_sleep_hold_dis_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_deep_sleep_hold_dis);
  cmock_call_instance = (CMOCK_gpio_deep_sleep_hold_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_deep_sleep_hold_dis_CallInstance);
  Mock.gpio_deep_sleep_hold_dis_CallInstance = CMock_Guts_MemNext(Mock.gpio_deep_sleep_hold_dis_CallInstance);
  if (Mock.gpio_deep_sleep_hold_dis_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.gpio_deep_sleep_hold_dis_CallbackBool &&
      Mock.gpio_deep_sleep_hold_dis_CallbackFunctionPointer != NULL)
  {
    Mock.gpio_deep_sleep_hold_dis_CallbackFunctionPointer(Mock.gpio_deep_sleep_hold_dis_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.gpio_deep_sleep_hold_dis_CallbackFunctionPointer != NULL)
  {
    Mock.gpio_deep_sleep_hold_dis_CallbackFunctionPointer(Mock.gpio_deep_sleep_hold_dis_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void gpio_deep_sleep_hold_dis_CMockIgnore(void)
{
  Mock.gpio_deep_sleep_hold_dis_IgnoreBool = (char)1;
}

void gpio_deep_sleep_hold_dis_CMockStopIgnore(void)
{
  Mock.gpio_deep_sleep_hold_dis_IgnoreBool = (char)0;
}

void gpio_deep_sleep_hold_dis_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_deep_sleep_hold_dis_CALL_INSTANCE));
  CMOCK_gpio_deep_sleep_hold_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_deep_sleep_hold_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_deep_sleep_hold_dis_CallInstance = CMock_Guts_MemChain(Mock.gpio_deep_sleep_hold_dis_CallInstance, cmock_guts_index);
  Mock.gpio_deep_sleep_hold_dis_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void gpio_deep_sleep_hold_dis_AddCallback(CMOCK_gpio_deep_sleep_hold_dis_CALLBACK Callback)
{
  Mock.gpio_deep_sleep_hold_dis_IgnoreBool = (char)0;
  Mock.gpio_deep_sleep_hold_dis_CallbackBool = (char)1;
  Mock.gpio_deep_sleep_hold_dis_CallbackFunctionPointer = Callback;
}

void gpio_deep_sleep_hold_dis_Stub(CMOCK_gpio_deep_sleep_hold_dis_CALLBACK Callback)
{
  Mock.gpio_deep_sleep_hold_dis_IgnoreBool = (char)0;
  Mock.gpio_deep_sleep_hold_dis_CallbackBool = (char)0;
  Mock.gpio_deep_sleep_hold_dis_CallbackFunctionPointer = Callback;
}

void gpio_iomux_in(uint32_t gpio_num, uint32_t signal_idx)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_iomux_in_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_iomux_in);
  cmock_call_instance = (CMOCK_gpio_iomux_in_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_iomux_in_CallInstance);
  Mock.gpio_iomux_in_CallInstance = CMock_Guts_MemNext(Mock.gpio_iomux_in_CallInstance);
  if (Mock.gpio_iomux_in_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.gpio_iomux_in_CallbackBool &&
      Mock.gpio_iomux_in_CallbackFunctionPointer != NULL)
  {
    Mock.gpio_iomux_in_CallbackFunctionPointer(gpio_num, signal_idx, Mock.gpio_iomux_in_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_iomux_in,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_gpio_num, gpio_num, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_signal_idx)
  {
    UNITY_SET_DETAILS(CMockString_gpio_iomux_in,CMockString_signal_idx);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_signal_idx, signal_idx, cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_iomux_in_CallbackFunctionPointer != NULL)
  {
    Mock.gpio_iomux_in_CallbackFunctionPointer(gpio_num, signal_idx, Mock.gpio_iomux_in_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_gpio_iomux_in(CMOCK_gpio_iomux_in_CALL_INSTANCE* cmock_call_instance, uint32_t gpio_num, uint32_t signal_idx);
void CMockExpectParameters_gpio_iomux_in(CMOCK_gpio_iomux_in_CALL_INSTANCE* cmock_call_instance, uint32_t gpio_num, uint32_t signal_idx)
{
  cmock_call_instance->Expected_gpio_num = gpio_num;
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  cmock_call_instance->Expected_signal_idx = signal_idx;
  cmock_call_instance->IgnoreArg_signal_idx = 0;
}

void gpio_iomux_in_CMockIgnore(void)
{
  Mock.gpio_iomux_in_IgnoreBool = (char)1;
}

void gpio_iomux_in_CMockStopIgnore(void)
{
  Mock.gpio_iomux_in_IgnoreBool = (char)0;
}

void gpio_iomux_in_CMockExpect(UNITY_LINE_TYPE cmock_line, uint32_t gpio_num, uint32_t signal_idx)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_iomux_in_CALL_INSTANCE));
  CMOCK_gpio_iomux_in_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_iomux_in_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_iomux_in_CallInstance = CMock_Guts_MemChain(Mock.gpio_iomux_in_CallInstance, cmock_guts_index);
  Mock.gpio_iomux_in_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_iomux_in(cmock_call_instance, gpio_num, signal_idx);
}

void gpio_iomux_in_AddCallback(CMOCK_gpio_iomux_in_CALLBACK Callback)
{
  Mock.gpio_iomux_in_IgnoreBool = (char)0;
  Mock.gpio_iomux_in_CallbackBool = (char)1;
  Mock.gpio_iomux_in_CallbackFunctionPointer = Callback;
}

void gpio_iomux_in_Stub(CMOCK_gpio_iomux_in_CALLBACK Callback)
{
  Mock.gpio_iomux_in_IgnoreBool = (char)0;
  Mock.gpio_iomux_in_CallbackBool = (char)0;
  Mock.gpio_iomux_in_CallbackFunctionPointer = Callback;
}

void gpio_iomux_in_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_iomux_in_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_iomux_in_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_iomux_in_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_iomux_in_CMockIgnoreArg_signal_idx(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_iomux_in_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_iomux_in_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_iomux_in_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_signal_idx = 1;
}

void gpio_iomux_out(uint8_t gpio_num, int func, bool oen_inv)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_iomux_out_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_iomux_out);
  cmock_call_instance = (CMOCK_gpio_iomux_out_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_iomux_out_CallInstance);
  Mock.gpio_iomux_out_CallInstance = CMock_Guts_MemNext(Mock.gpio_iomux_out_CallInstance);
  if (Mock.gpio_iomux_out_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.gpio_iomux_out_CallbackBool &&
      Mock.gpio_iomux_out_CallbackFunctionPointer != NULL)
  {
    Mock.gpio_iomux_out_CallbackFunctionPointer(gpio_num, func, oen_inv, Mock.gpio_iomux_out_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_iomux_out,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_gpio_num, gpio_num, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_func)
  {
    UNITY_SET_DETAILS(CMockString_gpio_iomux_out,CMockString_func);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_func, func, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_oen_inv)
  {
    UNITY_SET_DETAILS(CMockString_gpio_iomux_out,CMockString_oen_inv);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_oen_inv, oen_inv, cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_iomux_out_CallbackFunctionPointer != NULL)
  {
    Mock.gpio_iomux_out_CallbackFunctionPointer(gpio_num, func, oen_inv, Mock.gpio_iomux_out_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_gpio_iomux_out(CMOCK_gpio_iomux_out_CALL_INSTANCE* cmock_call_instance, uint8_t gpio_num, int func, bool oen_inv);
void CMockExpectParameters_gpio_iomux_out(CMOCK_gpio_iomux_out_CALL_INSTANCE* cmock_call_instance, uint8_t gpio_num, int func, bool oen_inv)
{
  cmock_call_instance->Expected_gpio_num = gpio_num;
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  cmock_call_instance->Expected_func = func;
  cmock_call_instance->IgnoreArg_func = 0;
  cmock_call_instance->Expected_oen_inv = oen_inv;
  cmock_call_instance->IgnoreArg_oen_inv = 0;
}

void gpio_iomux_out_CMockIgnore(void)
{
  Mock.gpio_iomux_out_IgnoreBool = (char)1;
}

void gpio_iomux_out_CMockStopIgnore(void)
{
  Mock.gpio_iomux_out_IgnoreBool = (char)0;
}

void gpio_iomux_out_CMockExpect(UNITY_LINE_TYPE cmock_line, uint8_t gpio_num, int func, bool oen_inv)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_iomux_out_CALL_INSTANCE));
  CMOCK_gpio_iomux_out_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_iomux_out_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_iomux_out_CallInstance = CMock_Guts_MemChain(Mock.gpio_iomux_out_CallInstance, cmock_guts_index);
  Mock.gpio_iomux_out_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_iomux_out(cmock_call_instance, gpio_num, func, oen_inv);
}

void gpio_iomux_out_AddCallback(CMOCK_gpio_iomux_out_CALLBACK Callback)
{
  Mock.gpio_iomux_out_IgnoreBool = (char)0;
  Mock.gpio_iomux_out_CallbackBool = (char)1;
  Mock.gpio_iomux_out_CallbackFunctionPointer = Callback;
}

void gpio_iomux_out_Stub(CMOCK_gpio_iomux_out_CALLBACK Callback)
{
  Mock.gpio_iomux_out_IgnoreBool = (char)0;
  Mock.gpio_iomux_out_CallbackBool = (char)0;
  Mock.gpio_iomux_out_CallbackFunctionPointer = Callback;
}

void gpio_iomux_out_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_iomux_out_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_iomux_out_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_iomux_out_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_iomux_out_CMockIgnoreArg_func(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_iomux_out_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_iomux_out_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_iomux_out_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_func = 1;
}

void gpio_iomux_out_CMockIgnoreArg_oen_inv(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_iomux_out_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_iomux_out_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_iomux_out_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_oen_inv = 1;
}

esp_err_t gpio_force_hold_all(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_force_hold_all_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_force_hold_all);
  cmock_call_instance = (CMOCK_gpio_force_hold_all_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_force_hold_all_CallInstance);
  Mock.gpio_force_hold_all_CallInstance = CMock_Guts_MemNext(Mock.gpio_force_hold_all_CallInstance);
  if (Mock.gpio_force_hold_all_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_force_hold_all_FinalReturn;
    memcpy((void*)(&Mock.gpio_force_hold_all_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_force_hold_all_CallbackBool &&
      Mock.gpio_force_hold_all_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_force_hold_all_CallbackFunctionPointer(Mock.gpio_force_hold_all_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.gpio_force_hold_all_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_force_hold_all_CallbackFunctionPointer(Mock.gpio_force_hold_all_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void gpio_force_hold_all_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_force_hold_all_CALL_INSTANCE));
  CMOCK_gpio_force_hold_all_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_force_hold_all_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_force_hold_all_CallInstance = CMock_Guts_MemChain(Mock.gpio_force_hold_all_CallInstance, cmock_guts_index);
  Mock.gpio_force_hold_all_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_force_hold_all_IgnoreBool = (char)1;
}

void gpio_force_hold_all_CMockStopIgnore(void)
{
  if(Mock.gpio_force_hold_all_IgnoreBool)
    Mock.gpio_force_hold_all_CallInstance = CMock_Guts_MemNext(Mock.gpio_force_hold_all_CallInstance);
  Mock.gpio_force_hold_all_IgnoreBool = (char)0;
}

void gpio_force_hold_all_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_force_hold_all_CALL_INSTANCE));
  CMOCK_gpio_force_hold_all_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_force_hold_all_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_force_hold_all_CallInstance = CMock_Guts_MemChain(Mock.gpio_force_hold_all_CallInstance, cmock_guts_index);
  Mock.gpio_force_hold_all_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_force_hold_all_AddCallback(CMOCK_gpio_force_hold_all_CALLBACK Callback)
{
  Mock.gpio_force_hold_all_IgnoreBool = (char)0;
  Mock.gpio_force_hold_all_CallbackBool = (char)1;
  Mock.gpio_force_hold_all_CallbackFunctionPointer = Callback;
}

void gpio_force_hold_all_Stub(CMOCK_gpio_force_hold_all_CALLBACK Callback)
{
  Mock.gpio_force_hold_all_IgnoreBool = (char)0;
  Mock.gpio_force_hold_all_CallbackBool = (char)0;
  Mock.gpio_force_hold_all_CallbackFunctionPointer = Callback;
}

esp_err_t gpio_force_unhold_all(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_force_unhold_all_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_force_unhold_all);
  cmock_call_instance = (CMOCK_gpio_force_unhold_all_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_force_unhold_all_CallInstance);
  Mock.gpio_force_unhold_all_CallInstance = CMock_Guts_MemNext(Mock.gpio_force_unhold_all_CallInstance);
  if (Mock.gpio_force_unhold_all_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_force_unhold_all_FinalReturn;
    memcpy((void*)(&Mock.gpio_force_unhold_all_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_force_unhold_all_CallbackBool &&
      Mock.gpio_force_unhold_all_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_force_unhold_all_CallbackFunctionPointer(Mock.gpio_force_unhold_all_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.gpio_force_unhold_all_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_force_unhold_all_CallbackFunctionPointer(Mock.gpio_force_unhold_all_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void gpio_force_unhold_all_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_force_unhold_all_CALL_INSTANCE));
  CMOCK_gpio_force_unhold_all_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_force_unhold_all_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_force_unhold_all_CallInstance = CMock_Guts_MemChain(Mock.gpio_force_unhold_all_CallInstance, cmock_guts_index);
  Mock.gpio_force_unhold_all_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_force_unhold_all_IgnoreBool = (char)1;
}

void gpio_force_unhold_all_CMockStopIgnore(void)
{
  if(Mock.gpio_force_unhold_all_IgnoreBool)
    Mock.gpio_force_unhold_all_CallInstance = CMock_Guts_MemNext(Mock.gpio_force_unhold_all_CallInstance);
  Mock.gpio_force_unhold_all_IgnoreBool = (char)0;
}

void gpio_force_unhold_all_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_force_unhold_all_CALL_INSTANCE));
  CMOCK_gpio_force_unhold_all_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_force_unhold_all_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_force_unhold_all_CallInstance = CMock_Guts_MemChain(Mock.gpio_force_unhold_all_CallInstance, cmock_guts_index);
  Mock.gpio_force_unhold_all_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_force_unhold_all_AddCallback(CMOCK_gpio_force_unhold_all_CALLBACK Callback)
{
  Mock.gpio_force_unhold_all_IgnoreBool = (char)0;
  Mock.gpio_force_unhold_all_CallbackBool = (char)1;
  Mock.gpio_force_unhold_all_CallbackFunctionPointer = Callback;
}

void gpio_force_unhold_all_Stub(CMOCK_gpio_force_unhold_all_CALLBACK Callback)
{
  Mock.gpio_force_unhold_all_IgnoreBool = (char)0;
  Mock.gpio_force_unhold_all_CallbackBool = (char)0;
  Mock.gpio_force_unhold_all_CallbackFunctionPointer = Callback;
}

esp_err_t gpio_sleep_sel_en(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_sleep_sel_en_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_sleep_sel_en);
  cmock_call_instance = (CMOCK_gpio_sleep_sel_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_sleep_sel_en_CallInstance);
  Mock.gpio_sleep_sel_en_CallInstance = CMock_Guts_MemNext(Mock.gpio_sleep_sel_en_CallInstance);
  if (Mock.gpio_sleep_sel_en_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_sleep_sel_en_FinalReturn;
    memcpy((void*)(&Mock.gpio_sleep_sel_en_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_sleep_sel_en_CallbackBool &&
      Mock.gpio_sleep_sel_en_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_sleep_sel_en_CallbackFunctionPointer(gpio_num, Mock.gpio_sleep_sel_en_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_sleep_sel_en,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_sleep_sel_en_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_sleep_sel_en_CallbackFunctionPointer(gpio_num, Mock.gpio_sleep_sel_en_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_sleep_sel_en(CMOCK_gpio_sleep_sel_en_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_sleep_sel_en(CMOCK_gpio_sleep_sel_en_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_sleep_sel_en_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_sleep_sel_en_CALL_INSTANCE));
  CMOCK_gpio_sleep_sel_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_sel_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_sleep_sel_en_CallInstance = CMock_Guts_MemChain(Mock.gpio_sleep_sel_en_CallInstance, cmock_guts_index);
  Mock.gpio_sleep_sel_en_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_sleep_sel_en_IgnoreBool = (char)1;
}

void gpio_sleep_sel_en_CMockStopIgnore(void)
{
  if(Mock.gpio_sleep_sel_en_IgnoreBool)
    Mock.gpio_sleep_sel_en_CallInstance = CMock_Guts_MemNext(Mock.gpio_sleep_sel_en_CallInstance);
  Mock.gpio_sleep_sel_en_IgnoreBool = (char)0;
}

void gpio_sleep_sel_en_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_sleep_sel_en_CALL_INSTANCE));
  CMOCK_gpio_sleep_sel_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_sel_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_sleep_sel_en_CallInstance = CMock_Guts_MemChain(Mock.gpio_sleep_sel_en_CallInstance, cmock_guts_index);
  Mock.gpio_sleep_sel_en_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_sleep_sel_en(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_sleep_sel_en_AddCallback(CMOCK_gpio_sleep_sel_en_CALLBACK Callback)
{
  Mock.gpio_sleep_sel_en_IgnoreBool = (char)0;
  Mock.gpio_sleep_sel_en_CallbackBool = (char)1;
  Mock.gpio_sleep_sel_en_CallbackFunctionPointer = Callback;
}

void gpio_sleep_sel_en_Stub(CMOCK_gpio_sleep_sel_en_CALLBACK Callback)
{
  Mock.gpio_sleep_sel_en_IgnoreBool = (char)0;
  Mock.gpio_sleep_sel_en_CallbackBool = (char)0;
  Mock.gpio_sleep_sel_en_CallbackFunctionPointer = Callback;
}

void gpio_sleep_sel_en_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_sleep_sel_en_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_sel_en_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_sleep_sel_en_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_sleep_sel_dis(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_sleep_sel_dis);
  cmock_call_instance = (CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_sleep_sel_dis_CallInstance);
  Mock.gpio_sleep_sel_dis_CallInstance = CMock_Guts_MemNext(Mock.gpio_sleep_sel_dis_CallInstance);
  if (Mock.gpio_sleep_sel_dis_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_sleep_sel_dis_FinalReturn;
    memcpy((void*)(&Mock.gpio_sleep_sel_dis_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_sleep_sel_dis_CallbackBool &&
      Mock.gpio_sleep_sel_dis_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_sleep_sel_dis_CallbackFunctionPointer(gpio_num, Mock.gpio_sleep_sel_dis_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_sleep_sel_dis,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_sleep_sel_dis_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_sleep_sel_dis_CallbackFunctionPointer(gpio_num, Mock.gpio_sleep_sel_dis_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_sleep_sel_dis(CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_sleep_sel_dis(CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_sleep_sel_dis_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE));
  CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_sleep_sel_dis_CallInstance = CMock_Guts_MemChain(Mock.gpio_sleep_sel_dis_CallInstance, cmock_guts_index);
  Mock.gpio_sleep_sel_dis_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_sleep_sel_dis_IgnoreBool = (char)1;
}

void gpio_sleep_sel_dis_CMockStopIgnore(void)
{
  if(Mock.gpio_sleep_sel_dis_IgnoreBool)
    Mock.gpio_sleep_sel_dis_CallInstance = CMock_Guts_MemNext(Mock.gpio_sleep_sel_dis_CallInstance);
  Mock.gpio_sleep_sel_dis_IgnoreBool = (char)0;
}

void gpio_sleep_sel_dis_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE));
  CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_sleep_sel_dis_CallInstance = CMock_Guts_MemChain(Mock.gpio_sleep_sel_dis_CallInstance, cmock_guts_index);
  Mock.gpio_sleep_sel_dis_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_sleep_sel_dis(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_sleep_sel_dis_AddCallback(CMOCK_gpio_sleep_sel_dis_CALLBACK Callback)
{
  Mock.gpio_sleep_sel_dis_IgnoreBool = (char)0;
  Mock.gpio_sleep_sel_dis_CallbackBool = (char)1;
  Mock.gpio_sleep_sel_dis_CallbackFunctionPointer = Callback;
}

void gpio_sleep_sel_dis_Stub(CMOCK_gpio_sleep_sel_dis_CALLBACK Callback)
{
  Mock.gpio_sleep_sel_dis_IgnoreBool = (char)0;
  Mock.gpio_sleep_sel_dis_CallbackBool = (char)0;
  Mock.gpio_sleep_sel_dis_CallbackFunctionPointer = Callback;
}

void gpio_sleep_sel_dis_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_sel_dis_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_sleep_sel_dis_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

esp_err_t gpio_sleep_set_direction(gpio_num_t gpio_num, gpio_mode_t mode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_sleep_set_direction_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_sleep_set_direction);
  cmock_call_instance = (CMOCK_gpio_sleep_set_direction_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_sleep_set_direction_CallInstance);
  Mock.gpio_sleep_set_direction_CallInstance = CMock_Guts_MemNext(Mock.gpio_sleep_set_direction_CallInstance);
  if (Mock.gpio_sleep_set_direction_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_sleep_set_direction_FinalReturn;
    memcpy((void*)(&Mock.gpio_sleep_set_direction_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_sleep_set_direction_CallbackBool &&
      Mock.gpio_sleep_set_direction_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_sleep_set_direction_CallbackFunctionPointer(gpio_num, mode, Mock.gpio_sleep_set_direction_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_sleep_set_direction,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_mode)
  {
    UNITY_SET_DETAILS(CMockString_gpio_sleep_set_direction,CMockString_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_mode), (void*)(&mode), sizeof(gpio_mode_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_sleep_set_direction_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_sleep_set_direction_CallbackFunctionPointer(gpio_num, mode, Mock.gpio_sleep_set_direction_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_sleep_set_direction(CMOCK_gpio_sleep_set_direction_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_mode_t mode);
void CMockExpectParameters_gpio_sleep_set_direction(CMOCK_gpio_sleep_set_direction_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_mode_t mode)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  memcpy((void*)(&cmock_call_instance->Expected_mode), (void*)(&mode),
         sizeof(gpio_mode_t[sizeof(mode) == sizeof(gpio_mode_t) ? 1 : -1])); /* add gpio_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_mode = 0;
}

void gpio_sleep_set_direction_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_sleep_set_direction_CALL_INSTANCE));
  CMOCK_gpio_sleep_set_direction_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_set_direction_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_sleep_set_direction_CallInstance = CMock_Guts_MemChain(Mock.gpio_sleep_set_direction_CallInstance, cmock_guts_index);
  Mock.gpio_sleep_set_direction_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_sleep_set_direction_IgnoreBool = (char)1;
}

void gpio_sleep_set_direction_CMockStopIgnore(void)
{
  if(Mock.gpio_sleep_set_direction_IgnoreBool)
    Mock.gpio_sleep_set_direction_CallInstance = CMock_Guts_MemNext(Mock.gpio_sleep_set_direction_CallInstance);
  Mock.gpio_sleep_set_direction_IgnoreBool = (char)0;
}

void gpio_sleep_set_direction_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_mode_t mode, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_sleep_set_direction_CALL_INSTANCE));
  CMOCK_gpio_sleep_set_direction_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_set_direction_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_sleep_set_direction_CallInstance = CMock_Guts_MemChain(Mock.gpio_sleep_set_direction_CallInstance, cmock_guts_index);
  Mock.gpio_sleep_set_direction_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_sleep_set_direction(cmock_call_instance, gpio_num, mode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_sleep_set_direction_AddCallback(CMOCK_gpio_sleep_set_direction_CALLBACK Callback)
{
  Mock.gpio_sleep_set_direction_IgnoreBool = (char)0;
  Mock.gpio_sleep_set_direction_CallbackBool = (char)1;
  Mock.gpio_sleep_set_direction_CallbackFunctionPointer = Callback;
}

void gpio_sleep_set_direction_Stub(CMOCK_gpio_sleep_set_direction_CALLBACK Callback)
{
  Mock.gpio_sleep_set_direction_IgnoreBool = (char)0;
  Mock.gpio_sleep_set_direction_CallbackBool = (char)0;
  Mock.gpio_sleep_set_direction_CallbackFunctionPointer = Callback;
}

void gpio_sleep_set_direction_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_sleep_set_direction_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_set_direction_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_sleep_set_direction_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_sleep_set_direction_CMockIgnoreArg_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_sleep_set_direction_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_set_direction_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_sleep_set_direction_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_mode = 1;
}

esp_err_t gpio_sleep_set_pull_mode(gpio_num_t gpio_num, gpio_pull_mode_t pull)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_sleep_set_pull_mode);
  cmock_call_instance = (CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_sleep_set_pull_mode_CallInstance);
  Mock.gpio_sleep_set_pull_mode_CallInstance = CMock_Guts_MemNext(Mock.gpio_sleep_set_pull_mode_CallInstance);
  if (Mock.gpio_sleep_set_pull_mode_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_sleep_set_pull_mode_FinalReturn;
    memcpy((void*)(&Mock.gpio_sleep_set_pull_mode_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_sleep_set_pull_mode_CallbackBool &&
      Mock.gpio_sleep_set_pull_mode_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_sleep_set_pull_mode_CallbackFunctionPointer(gpio_num, pull, Mock.gpio_sleep_set_pull_mode_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_sleep_set_pull_mode,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_pull)
  {
    UNITY_SET_DETAILS(CMockString_gpio_sleep_set_pull_mode,CMockString_pull);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_pull), (void*)(&pull), sizeof(gpio_pull_mode_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_sleep_set_pull_mode_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_sleep_set_pull_mode_CallbackFunctionPointer(gpio_num, pull, Mock.gpio_sleep_set_pull_mode_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_sleep_set_pull_mode(CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_pull_mode_t pull);
void CMockExpectParameters_gpio_sleep_set_pull_mode(CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_pull_mode_t pull)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  memcpy((void*)(&cmock_call_instance->Expected_pull), (void*)(&pull),
         sizeof(gpio_pull_mode_t[sizeof(pull) == sizeof(gpio_pull_mode_t) ? 1 : -1])); /* add gpio_pull_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_pull = 0;
}

void gpio_sleep_set_pull_mode_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE));
  CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_sleep_set_pull_mode_CallInstance = CMock_Guts_MemChain(Mock.gpio_sleep_set_pull_mode_CallInstance, cmock_guts_index);
  Mock.gpio_sleep_set_pull_mode_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_sleep_set_pull_mode_IgnoreBool = (char)1;
}

void gpio_sleep_set_pull_mode_CMockStopIgnore(void)
{
  if(Mock.gpio_sleep_set_pull_mode_IgnoreBool)
    Mock.gpio_sleep_set_pull_mode_CallInstance = CMock_Guts_MemNext(Mock.gpio_sleep_set_pull_mode_CallInstance);
  Mock.gpio_sleep_set_pull_mode_IgnoreBool = (char)0;
}

void gpio_sleep_set_pull_mode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_pull_mode_t pull, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE));
  CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_sleep_set_pull_mode_CallInstance = CMock_Guts_MemChain(Mock.gpio_sleep_set_pull_mode_CallInstance, cmock_guts_index);
  Mock.gpio_sleep_set_pull_mode_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_sleep_set_pull_mode(cmock_call_instance, gpio_num, pull);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_sleep_set_pull_mode_AddCallback(CMOCK_gpio_sleep_set_pull_mode_CALLBACK Callback)
{
  Mock.gpio_sleep_set_pull_mode_IgnoreBool = (char)0;
  Mock.gpio_sleep_set_pull_mode_CallbackBool = (char)1;
  Mock.gpio_sleep_set_pull_mode_CallbackFunctionPointer = Callback;
}

void gpio_sleep_set_pull_mode_Stub(CMOCK_gpio_sleep_set_pull_mode_CALLBACK Callback)
{
  Mock.gpio_sleep_set_pull_mode_IgnoreBool = (char)0;
  Mock.gpio_sleep_set_pull_mode_CallbackBool = (char)0;
  Mock.gpio_sleep_set_pull_mode_CallbackFunctionPointer = Callback;
}

void gpio_sleep_set_pull_mode_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_sleep_set_pull_mode_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_sleep_set_pull_mode_CMockIgnoreArg_pull(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_sleep_set_pull_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_sleep_set_pull_mode_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_pull = 1;
}

esp_err_t gpio_deep_sleep_wakeup_enable(gpio_num_t gpio_num, gpio_int_type_t intr_type)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_deep_sleep_wakeup_enable);
  cmock_call_instance = (CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_deep_sleep_wakeup_enable_CallInstance);
  Mock.gpio_deep_sleep_wakeup_enable_CallInstance = CMock_Guts_MemNext(Mock.gpio_deep_sleep_wakeup_enable_CallInstance);
  if (Mock.gpio_deep_sleep_wakeup_enable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_deep_sleep_wakeup_enable_FinalReturn;
    memcpy((void*)(&Mock.gpio_deep_sleep_wakeup_enable_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_deep_sleep_wakeup_enable_CallbackBool &&
      Mock.gpio_deep_sleep_wakeup_enable_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_deep_sleep_wakeup_enable_CallbackFunctionPointer(gpio_num, intr_type, Mock.gpio_deep_sleep_wakeup_enable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_deep_sleep_wakeup_enable,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_intr_type)
  {
    UNITY_SET_DETAILS(CMockString_gpio_deep_sleep_wakeup_enable,CMockString_intr_type);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_intr_type), (void*)(&intr_type), sizeof(gpio_int_type_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_deep_sleep_wakeup_enable_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_deep_sleep_wakeup_enable_CallbackFunctionPointer(gpio_num, intr_type, Mock.gpio_deep_sleep_wakeup_enable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_deep_sleep_wakeup_enable(CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_int_type_t intr_type);
void CMockExpectParameters_gpio_deep_sleep_wakeup_enable(CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num, gpio_int_type_t intr_type)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  memcpy((void*)(&cmock_call_instance->Expected_intr_type), (void*)(&intr_type),
         sizeof(gpio_int_type_t[sizeof(intr_type) == sizeof(gpio_int_type_t) ? 1 : -1])); /* add gpio_int_type_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_intr_type = 0;
}

void gpio_deep_sleep_wakeup_enable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE));
  CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_deep_sleep_wakeup_enable_CallInstance = CMock_Guts_MemChain(Mock.gpio_deep_sleep_wakeup_enable_CallInstance, cmock_guts_index);
  Mock.gpio_deep_sleep_wakeup_enable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_deep_sleep_wakeup_enable_IgnoreBool = (char)1;
}

void gpio_deep_sleep_wakeup_enable_CMockStopIgnore(void)
{
  if(Mock.gpio_deep_sleep_wakeup_enable_IgnoreBool)
    Mock.gpio_deep_sleep_wakeup_enable_CallInstance = CMock_Guts_MemNext(Mock.gpio_deep_sleep_wakeup_enable_CallInstance);
  Mock.gpio_deep_sleep_wakeup_enable_IgnoreBool = (char)0;
}

void gpio_deep_sleep_wakeup_enable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, gpio_int_type_t intr_type, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE));
  CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_deep_sleep_wakeup_enable_CallInstance = CMock_Guts_MemChain(Mock.gpio_deep_sleep_wakeup_enable_CallInstance, cmock_guts_index);
  Mock.gpio_deep_sleep_wakeup_enable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_deep_sleep_wakeup_enable(cmock_call_instance, gpio_num, intr_type);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_deep_sleep_wakeup_enable_AddCallback(CMOCK_gpio_deep_sleep_wakeup_enable_CALLBACK Callback)
{
  Mock.gpio_deep_sleep_wakeup_enable_IgnoreBool = (char)0;
  Mock.gpio_deep_sleep_wakeup_enable_CallbackBool = (char)1;
  Mock.gpio_deep_sleep_wakeup_enable_CallbackFunctionPointer = Callback;
}

void gpio_deep_sleep_wakeup_enable_Stub(CMOCK_gpio_deep_sleep_wakeup_enable_CALLBACK Callback)
{
  Mock.gpio_deep_sleep_wakeup_enable_IgnoreBool = (char)0;
  Mock.gpio_deep_sleep_wakeup_enable_CallbackBool = (char)0;
  Mock.gpio_deep_sleep_wakeup_enable_CallbackFunctionPointer = Callback;
}

void gpio_deep_sleep_wakeup_enable_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_deep_sleep_wakeup_enable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void gpio_deep_sleep_wakeup_enable_CMockIgnoreArg_intr_type(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_deep_sleep_wakeup_enable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_deep_sleep_wakeup_enable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_intr_type = 1;
}

esp_err_t gpio_deep_sleep_wakeup_disable(gpio_num_t gpio_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_gpio_deep_sleep_wakeup_disable);
  cmock_call_instance = (CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.gpio_deep_sleep_wakeup_disable_CallInstance);
  Mock.gpio_deep_sleep_wakeup_disable_CallInstance = CMock_Guts_MemNext(Mock.gpio_deep_sleep_wakeup_disable_CallInstance);
  if (Mock.gpio_deep_sleep_wakeup_disable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.gpio_deep_sleep_wakeup_disable_FinalReturn;
    memcpy((void*)(&Mock.gpio_deep_sleep_wakeup_disable_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.gpio_deep_sleep_wakeup_disable_CallbackBool &&
      Mock.gpio_deep_sleep_wakeup_disable_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.gpio_deep_sleep_wakeup_disable_CallbackFunctionPointer(gpio_num, Mock.gpio_deep_sleep_wakeup_disable_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_gpio_deep_sleep_wakeup_disable,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num), sizeof(gpio_num_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.gpio_deep_sleep_wakeup_disable_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.gpio_deep_sleep_wakeup_disable_CallbackFunctionPointer(gpio_num, Mock.gpio_deep_sleep_wakeup_disable_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_gpio_deep_sleep_wakeup_disable(CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num);
void CMockExpectParameters_gpio_deep_sleep_wakeup_disable(CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE* cmock_call_instance, gpio_num_t gpio_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_gpio_num), (void*)(&gpio_num),
         sizeof(gpio_num_t[sizeof(gpio_num) == sizeof(gpio_num_t) ? 1 : -1])); /* add gpio_num_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_gpio_num = 0;
}

void gpio_deep_sleep_wakeup_disable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE));
  CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_deep_sleep_wakeup_disable_CallInstance = CMock_Guts_MemChain(Mock.gpio_deep_sleep_wakeup_disable_CallInstance, cmock_guts_index);
  Mock.gpio_deep_sleep_wakeup_disable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.gpio_deep_sleep_wakeup_disable_IgnoreBool = (char)1;
}

void gpio_deep_sleep_wakeup_disable_CMockStopIgnore(void)
{
  if(Mock.gpio_deep_sleep_wakeup_disable_IgnoreBool)
    Mock.gpio_deep_sleep_wakeup_disable_CallInstance = CMock_Guts_MemNext(Mock.gpio_deep_sleep_wakeup_disable_CallInstance);
  Mock.gpio_deep_sleep_wakeup_disable_IgnoreBool = (char)0;
}

void gpio_deep_sleep_wakeup_disable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, gpio_num_t gpio_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE));
  CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.gpio_deep_sleep_wakeup_disable_CallInstance = CMock_Guts_MemChain(Mock.gpio_deep_sleep_wakeup_disable_CallInstance, cmock_guts_index);
  Mock.gpio_deep_sleep_wakeup_disable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_gpio_deep_sleep_wakeup_disable(cmock_call_instance, gpio_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void gpio_deep_sleep_wakeup_disable_AddCallback(CMOCK_gpio_deep_sleep_wakeup_disable_CALLBACK Callback)
{
  Mock.gpio_deep_sleep_wakeup_disable_IgnoreBool = (char)0;
  Mock.gpio_deep_sleep_wakeup_disable_CallbackBool = (char)1;
  Mock.gpio_deep_sleep_wakeup_disable_CallbackFunctionPointer = Callback;
}

void gpio_deep_sleep_wakeup_disable_Stub(CMOCK_gpio_deep_sleep_wakeup_disable_CALLBACK Callback)
{
  Mock.gpio_deep_sleep_wakeup_disable_IgnoreBool = (char)0;
  Mock.gpio_deep_sleep_wakeup_disable_CallbackBool = (char)0;
  Mock.gpio_deep_sleep_wakeup_disable_CallbackFunctionPointer = Callback;
}

void gpio_deep_sleep_wakeup_disable_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE* cmock_call_instance = (CMOCK_gpio_deep_sleep_wakeup_disable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.gpio_deep_sleep_wakeup_disable_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

