/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "mock_ledc.h"

static const char* CMockString_arg = "arg";
static const char* CMockString_cbs = "cbs";
static const char* CMockString_channel = "channel";
static const char* CMockString_clk_src = "clk_src";
static const char* CMockString_clock_divider = "clock_divider";
static const char* CMockString_cycle_num = "cycle_num";
static const char* CMockString_duty = "duty";
static const char* CMockString_duty_cycle_num = "duty_cycle_num";
static const char* CMockString_duty_resolution = "duty_resolution";
static const char* CMockString_duty_scale = "duty_scale";
static const char* CMockString_fade_direction = "fade_direction";
static const char* CMockString_fade_mode = "fade_mode";
static const char* CMockString_fn = "fn";
static const char* CMockString_freq_hz = "freq_hz";
static const char* CMockString_gpio_num = "gpio_num";
static const char* CMockString_handle = "handle";
static const char* CMockString_hpoint = "hpoint";
static const char* CMockString_idle_level = "idle_level";
static const char* CMockString_intr_alloc_flags = "intr_alloc_flags";
static const char* CMockString_ledc_bind_channel_timer = "ledc_bind_channel_timer";
static const char* CMockString_ledc_cb_register = "ledc_cb_register";
static const char* CMockString_ledc_channel = "ledc_channel";
static const char* CMockString_ledc_channel_config = "ledc_channel_config";
static const char* CMockString_ledc_conf = "ledc_conf";
static const char* CMockString_ledc_fade_func_install = "ledc_fade_func_install";
static const char* CMockString_ledc_fade_func_uninstall = "ledc_fade_func_uninstall";
static const char* CMockString_ledc_fade_start = "ledc_fade_start";
static const char* CMockString_ledc_get_duty = "ledc_get_duty";
static const char* CMockString_ledc_get_freq = "ledc_get_freq";
static const char* CMockString_ledc_get_hpoint = "ledc_get_hpoint";
static const char* CMockString_ledc_isr_register = "ledc_isr_register";
static const char* CMockString_ledc_set_duty = "ledc_set_duty";
static const char* CMockString_ledc_set_duty_and_update = "ledc_set_duty_and_update";
static const char* CMockString_ledc_set_duty_with_hpoint = "ledc_set_duty_with_hpoint";
static const char* CMockString_ledc_set_fade = "ledc_set_fade";
static const char* CMockString_ledc_set_fade_step_and_start = "ledc_set_fade_step_and_start";
static const char* CMockString_ledc_set_fade_time_and_start = "ledc_set_fade_time_and_start";
static const char* CMockString_ledc_set_fade_with_step = "ledc_set_fade_with_step";
static const char* CMockString_ledc_set_fade_with_time = "ledc_set_fade_with_time";
static const char* CMockString_ledc_set_freq = "ledc_set_freq";
static const char* CMockString_ledc_set_pin = "ledc_set_pin";
static const char* CMockString_ledc_stop = "ledc_stop";
static const char* CMockString_ledc_timer_config = "ledc_timer_config";
static const char* CMockString_ledc_timer_pause = "ledc_timer_pause";
static const char* CMockString_ledc_timer_resume = "ledc_timer_resume";
static const char* CMockString_ledc_timer_rst = "ledc_timer_rst";
static const char* CMockString_ledc_timer_set = "ledc_timer_set";
static const char* CMockString_ledc_update_duty = "ledc_update_duty";
static const char* CMockString_max_fade_time_ms = "max_fade_time_ms";
static const char* CMockString_scale = "scale";
static const char* CMockString_speed_mode = "speed_mode";
static const char* CMockString_step_num = "step_num";
static const char* CMockString_target_duty = "target_duty";
static const char* CMockString_timer_conf = "timer_conf";
static const char* CMockString_timer_num = "timer_num";
static const char* CMockString_timer_sel = "timer_sel";
static const char* CMockString_user_arg = "user_arg";

typedef struct _CMOCK_ledc_channel_config_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  const ledc_channel_config_t* Expected_ledc_conf;
  int Expected_ledc_conf_Depth;
  char IgnoreArg_ledc_conf;

} CMOCK_ledc_channel_config_CALL_INSTANCE;

typedef struct _CMOCK_ledc_timer_config_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  const ledc_timer_config_t* Expected_timer_conf;
  int Expected_timer_conf_Depth;
  char IgnoreArg_timer_conf;

} CMOCK_ledc_timer_config_CALL_INSTANCE;

typedef struct _CMOCK_ledc_update_duty_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;

} CMOCK_ledc_update_duty_CALL_INSTANCE;

typedef struct _CMOCK_ledc_set_pin_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  int Expected_gpio_num;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_ledc_channel;
  char IgnoreArg_gpio_num;
  char IgnoreArg_speed_mode;
  char IgnoreArg_ledc_channel;

} CMOCK_ledc_set_pin_CALL_INSTANCE;

typedef struct _CMOCK_ledc_stop_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  uint32_t Expected_idle_level;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_idle_level;

} CMOCK_ledc_stop_CALL_INSTANCE;

typedef struct _CMOCK_ledc_set_freq_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_timer_t Expected_timer_num;
  uint32_t Expected_freq_hz;
  char IgnoreArg_speed_mode;
  char IgnoreArg_timer_num;
  char IgnoreArg_freq_hz;

} CMOCK_ledc_set_freq_CALL_INSTANCE;

typedef struct _CMOCK_ledc_get_freq_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_timer_t Expected_timer_num;
  char IgnoreArg_speed_mode;
  char IgnoreArg_timer_num;

} CMOCK_ledc_get_freq_CALL_INSTANCE;

typedef struct _CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  uint32_t Expected_duty;
  uint32_t Expected_hpoint;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_duty;
  char IgnoreArg_hpoint;

} CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE;

typedef struct _CMOCK_ledc_get_hpoint_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;

} CMOCK_ledc_get_hpoint_CALL_INSTANCE;

typedef struct _CMOCK_ledc_set_duty_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  uint32_t Expected_duty;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_duty;

} CMOCK_ledc_set_duty_CALL_INSTANCE;

typedef struct _CMOCK_ledc_get_duty_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;

} CMOCK_ledc_get_duty_CALL_INSTANCE;

typedef struct _CMOCK_ledc_set_fade_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  uint32_t Expected_duty;
  ledc_duty_direction_t Expected_fade_direction;
  uint32_t Expected_step_num;
  uint32_t Expected_duty_cycle_num;
  uint32_t Expected_duty_scale;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_duty;
  char IgnoreArg_fade_direction;
  char IgnoreArg_step_num;
  char IgnoreArg_duty_cycle_num;
  char IgnoreArg_duty_scale;

} CMOCK_ledc_set_fade_CALL_INSTANCE;

typedef struct _CMOCK_ledc_isr_register_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  cmock_ledc_func_ptr1 Expected_fn;
  void* Expected_arg;
  int Expected_intr_alloc_flags;
  ledc_isr_handle_t* Expected_handle;
  int Expected_arg_Depth;
  int Expected_handle_Depth;
  char ReturnThruPtr_arg_Used;
  void* ReturnThruPtr_arg_Val;
  size_t ReturnThruPtr_arg_Size;
  char ReturnThruPtr_handle_Used;
  ledc_isr_handle_t* ReturnThruPtr_handle_Val;
  size_t ReturnThruPtr_handle_Size;
  char IgnoreArg_fn;
  char IgnoreArg_arg;
  char IgnoreArg_intr_alloc_flags;
  char IgnoreArg_handle;

} CMOCK_ledc_isr_register_CALL_INSTANCE;

typedef struct _CMOCK_ledc_timer_set_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_timer_t Expected_timer_sel;
  uint32_t Expected_clock_divider;
  uint32_t Expected_duty_resolution;
  ledc_clk_src_t Expected_clk_src;
  char IgnoreArg_speed_mode;
  char IgnoreArg_timer_sel;
  char IgnoreArg_clock_divider;
  char IgnoreArg_duty_resolution;
  char IgnoreArg_clk_src;

} CMOCK_ledc_timer_set_CALL_INSTANCE;

typedef struct _CMOCK_ledc_timer_rst_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_timer_t Expected_timer_sel;
  char IgnoreArg_speed_mode;
  char IgnoreArg_timer_sel;

} CMOCK_ledc_timer_rst_CALL_INSTANCE;

typedef struct _CMOCK_ledc_timer_pause_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_timer_t Expected_timer_sel;
  char IgnoreArg_speed_mode;
  char IgnoreArg_timer_sel;

} CMOCK_ledc_timer_pause_CALL_INSTANCE;

typedef struct _CMOCK_ledc_timer_resume_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_timer_t Expected_timer_sel;
  char IgnoreArg_speed_mode;
  char IgnoreArg_timer_sel;

} CMOCK_ledc_timer_resume_CALL_INSTANCE;

typedef struct _CMOCK_ledc_bind_channel_timer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  ledc_timer_t Expected_timer_sel;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_timer_sel;

} CMOCK_ledc_bind_channel_timer_CALL_INSTANCE;

typedef struct _CMOCK_ledc_set_fade_with_step_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  uint32_t Expected_target_duty;
  uint32_t Expected_scale;
  uint32_t Expected_cycle_num;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_target_duty;
  char IgnoreArg_scale;
  char IgnoreArg_cycle_num;

} CMOCK_ledc_set_fade_with_step_CALL_INSTANCE;

typedef struct _CMOCK_ledc_set_fade_with_time_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  uint32_t Expected_target_duty;
  int Expected_max_fade_time_ms;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_target_duty;
  char IgnoreArg_max_fade_time_ms;

} CMOCK_ledc_set_fade_with_time_CALL_INSTANCE;

typedef struct _CMOCK_ledc_fade_func_install_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  int Expected_intr_alloc_flags;
  char IgnoreArg_intr_alloc_flags;

} CMOCK_ledc_fade_func_install_CALL_INSTANCE;

typedef struct _CMOCK_ledc_fade_func_uninstall_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_ledc_fade_func_uninstall_CALL_INSTANCE;

typedef struct _CMOCK_ledc_fade_start_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  ledc_fade_mode_t Expected_fade_mode;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_fade_mode;

} CMOCK_ledc_fade_start_CALL_INSTANCE;

typedef struct _CMOCK_ledc_set_duty_and_update_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  uint32_t Expected_duty;
  uint32_t Expected_hpoint;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_duty;
  char IgnoreArg_hpoint;

} CMOCK_ledc_set_duty_and_update_CALL_INSTANCE;

typedef struct _CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  uint32_t Expected_target_duty;
  uint32_t Expected_max_fade_time_ms;
  ledc_fade_mode_t Expected_fade_mode;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_target_duty;
  char IgnoreArg_max_fade_time_ms;
  char IgnoreArg_fade_mode;

} CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE;

typedef struct _CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  uint32_t Expected_target_duty;
  uint32_t Expected_scale;
  uint32_t Expected_cycle_num;
  ledc_fade_mode_t Expected_fade_mode;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_target_duty;
  char IgnoreArg_scale;
  char IgnoreArg_cycle_num;
  char IgnoreArg_fade_mode;

} CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE;

typedef struct _CMOCK_ledc_cb_register_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int CallOrder;
  ledc_mode_t Expected_speed_mode;
  ledc_channel_t Expected_channel;
  ledc_cbs_t* Expected_cbs;
  void* Expected_user_arg;
  int Expected_cbs_Depth;
  int Expected_user_arg_Depth;
  char ReturnThruPtr_cbs_Used;
  ledc_cbs_t* ReturnThruPtr_cbs_Val;
  size_t ReturnThruPtr_cbs_Size;
  char ReturnThruPtr_user_arg_Used;
  void* ReturnThruPtr_user_arg_Val;
  size_t ReturnThruPtr_user_arg_Size;
  char IgnoreArg_speed_mode;
  char IgnoreArg_channel;
  char IgnoreArg_cbs;
  char IgnoreArg_user_arg;

} CMOCK_ledc_cb_register_CALL_INSTANCE;

static struct mock_ledcInstance
{
  char ledc_channel_config_IgnoreBool;
  esp_err_t ledc_channel_config_FinalReturn;
  char ledc_channel_config_CallbackBool;
  CMOCK_ledc_channel_config_CALLBACK ledc_channel_config_CallbackFunctionPointer;
  int ledc_channel_config_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_channel_config_CallInstance;
  char ledc_timer_config_IgnoreBool;
  esp_err_t ledc_timer_config_FinalReturn;
  char ledc_timer_config_CallbackBool;
  CMOCK_ledc_timer_config_CALLBACK ledc_timer_config_CallbackFunctionPointer;
  int ledc_timer_config_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_timer_config_CallInstance;
  char ledc_update_duty_IgnoreBool;
  esp_err_t ledc_update_duty_FinalReturn;
  char ledc_update_duty_CallbackBool;
  CMOCK_ledc_update_duty_CALLBACK ledc_update_duty_CallbackFunctionPointer;
  int ledc_update_duty_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_update_duty_CallInstance;
  char ledc_set_pin_IgnoreBool;
  esp_err_t ledc_set_pin_FinalReturn;
  char ledc_set_pin_CallbackBool;
  CMOCK_ledc_set_pin_CALLBACK ledc_set_pin_CallbackFunctionPointer;
  int ledc_set_pin_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_set_pin_CallInstance;
  char ledc_stop_IgnoreBool;
  esp_err_t ledc_stop_FinalReturn;
  char ledc_stop_CallbackBool;
  CMOCK_ledc_stop_CALLBACK ledc_stop_CallbackFunctionPointer;
  int ledc_stop_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_stop_CallInstance;
  char ledc_set_freq_IgnoreBool;
  esp_err_t ledc_set_freq_FinalReturn;
  char ledc_set_freq_CallbackBool;
  CMOCK_ledc_set_freq_CALLBACK ledc_set_freq_CallbackFunctionPointer;
  int ledc_set_freq_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_set_freq_CallInstance;
  char ledc_get_freq_IgnoreBool;
  uint32_t ledc_get_freq_FinalReturn;
  char ledc_get_freq_CallbackBool;
  CMOCK_ledc_get_freq_CALLBACK ledc_get_freq_CallbackFunctionPointer;
  int ledc_get_freq_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_get_freq_CallInstance;
  char ledc_set_duty_with_hpoint_IgnoreBool;
  esp_err_t ledc_set_duty_with_hpoint_FinalReturn;
  char ledc_set_duty_with_hpoint_CallbackBool;
  CMOCK_ledc_set_duty_with_hpoint_CALLBACK ledc_set_duty_with_hpoint_CallbackFunctionPointer;
  int ledc_set_duty_with_hpoint_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_set_duty_with_hpoint_CallInstance;
  char ledc_get_hpoint_IgnoreBool;
  int ledc_get_hpoint_FinalReturn;
  char ledc_get_hpoint_CallbackBool;
  CMOCK_ledc_get_hpoint_CALLBACK ledc_get_hpoint_CallbackFunctionPointer;
  int ledc_get_hpoint_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_get_hpoint_CallInstance;
  char ledc_set_duty_IgnoreBool;
  esp_err_t ledc_set_duty_FinalReturn;
  char ledc_set_duty_CallbackBool;
  CMOCK_ledc_set_duty_CALLBACK ledc_set_duty_CallbackFunctionPointer;
  int ledc_set_duty_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_set_duty_CallInstance;
  char ledc_get_duty_IgnoreBool;
  uint32_t ledc_get_duty_FinalReturn;
  char ledc_get_duty_CallbackBool;
  CMOCK_ledc_get_duty_CALLBACK ledc_get_duty_CallbackFunctionPointer;
  int ledc_get_duty_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_get_duty_CallInstance;
  char ledc_set_fade_IgnoreBool;
  esp_err_t ledc_set_fade_FinalReturn;
  char ledc_set_fade_CallbackBool;
  CMOCK_ledc_set_fade_CALLBACK ledc_set_fade_CallbackFunctionPointer;
  int ledc_set_fade_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_set_fade_CallInstance;
  char ledc_isr_register_IgnoreBool;
  esp_err_t ledc_isr_register_FinalReturn;
  char ledc_isr_register_CallbackBool;
  CMOCK_ledc_isr_register_CALLBACK ledc_isr_register_CallbackFunctionPointer;
  int ledc_isr_register_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_isr_register_CallInstance;
  char ledc_timer_set_IgnoreBool;
  esp_err_t ledc_timer_set_FinalReturn;
  char ledc_timer_set_CallbackBool;
  CMOCK_ledc_timer_set_CALLBACK ledc_timer_set_CallbackFunctionPointer;
  int ledc_timer_set_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_timer_set_CallInstance;
  char ledc_timer_rst_IgnoreBool;
  esp_err_t ledc_timer_rst_FinalReturn;
  char ledc_timer_rst_CallbackBool;
  CMOCK_ledc_timer_rst_CALLBACK ledc_timer_rst_CallbackFunctionPointer;
  int ledc_timer_rst_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_timer_rst_CallInstance;
  char ledc_timer_pause_IgnoreBool;
  esp_err_t ledc_timer_pause_FinalReturn;
  char ledc_timer_pause_CallbackBool;
  CMOCK_ledc_timer_pause_CALLBACK ledc_timer_pause_CallbackFunctionPointer;
  int ledc_timer_pause_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_timer_pause_CallInstance;
  char ledc_timer_resume_IgnoreBool;
  esp_err_t ledc_timer_resume_FinalReturn;
  char ledc_timer_resume_CallbackBool;
  CMOCK_ledc_timer_resume_CALLBACK ledc_timer_resume_CallbackFunctionPointer;
  int ledc_timer_resume_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_timer_resume_CallInstance;
  char ledc_bind_channel_timer_IgnoreBool;
  esp_err_t ledc_bind_channel_timer_FinalReturn;
  char ledc_bind_channel_timer_CallbackBool;
  CMOCK_ledc_bind_channel_timer_CALLBACK ledc_bind_channel_timer_CallbackFunctionPointer;
  int ledc_bind_channel_timer_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_bind_channel_timer_CallInstance;
  char ledc_set_fade_with_step_IgnoreBool;
  esp_err_t ledc_set_fade_with_step_FinalReturn;
  char ledc_set_fade_with_step_CallbackBool;
  CMOCK_ledc_set_fade_with_step_CALLBACK ledc_set_fade_with_step_CallbackFunctionPointer;
  int ledc_set_fade_with_step_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_set_fade_with_step_CallInstance;
  char ledc_set_fade_with_time_IgnoreBool;
  esp_err_t ledc_set_fade_with_time_FinalReturn;
  char ledc_set_fade_with_time_CallbackBool;
  CMOCK_ledc_set_fade_with_time_CALLBACK ledc_set_fade_with_time_CallbackFunctionPointer;
  int ledc_set_fade_with_time_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_set_fade_with_time_CallInstance;
  char ledc_fade_func_install_IgnoreBool;
  esp_err_t ledc_fade_func_install_FinalReturn;
  char ledc_fade_func_install_CallbackBool;
  CMOCK_ledc_fade_func_install_CALLBACK ledc_fade_func_install_CallbackFunctionPointer;
  int ledc_fade_func_install_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_fade_func_install_CallInstance;
  char ledc_fade_func_uninstall_IgnoreBool;
  char ledc_fade_func_uninstall_CallbackBool;
  CMOCK_ledc_fade_func_uninstall_CALLBACK ledc_fade_func_uninstall_CallbackFunctionPointer;
  int ledc_fade_func_uninstall_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_fade_func_uninstall_CallInstance;
  char ledc_fade_start_IgnoreBool;
  esp_err_t ledc_fade_start_FinalReturn;
  char ledc_fade_start_CallbackBool;
  CMOCK_ledc_fade_start_CALLBACK ledc_fade_start_CallbackFunctionPointer;
  int ledc_fade_start_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_fade_start_CallInstance;
  char ledc_set_duty_and_update_IgnoreBool;
  esp_err_t ledc_set_duty_and_update_FinalReturn;
  char ledc_set_duty_and_update_CallbackBool;
  CMOCK_ledc_set_duty_and_update_CALLBACK ledc_set_duty_and_update_CallbackFunctionPointer;
  int ledc_set_duty_and_update_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_set_duty_and_update_CallInstance;
  char ledc_set_fade_time_and_start_IgnoreBool;
  esp_err_t ledc_set_fade_time_and_start_FinalReturn;
  char ledc_set_fade_time_and_start_CallbackBool;
  CMOCK_ledc_set_fade_time_and_start_CALLBACK ledc_set_fade_time_and_start_CallbackFunctionPointer;
  int ledc_set_fade_time_and_start_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_set_fade_time_and_start_CallInstance;
  char ledc_set_fade_step_and_start_IgnoreBool;
  esp_err_t ledc_set_fade_step_and_start_FinalReturn;
  char ledc_set_fade_step_and_start_CallbackBool;
  CMOCK_ledc_set_fade_step_and_start_CALLBACK ledc_set_fade_step_and_start_CallbackFunctionPointer;
  int ledc_set_fade_step_and_start_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_set_fade_step_and_start_CallInstance;
  char ledc_cb_register_IgnoreBool;
  esp_err_t ledc_cb_register_FinalReturn;
  char ledc_cb_register_CallbackBool;
  CMOCK_ledc_cb_register_CALLBACK ledc_cb_register_CallbackFunctionPointer;
  int ledc_cb_register_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE ledc_cb_register_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_ledc_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.ledc_channel_config_CallInstance;
  if (Mock.ledc_channel_config_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_channel_config);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_channel_config_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_timer_config_CallInstance;
  if (Mock.ledc_timer_config_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_timer_config);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_timer_config_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_update_duty_CallInstance;
  if (Mock.ledc_update_duty_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_update_duty);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_update_duty_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_set_pin_CallInstance;
  if (Mock.ledc_set_pin_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_set_pin);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_set_pin_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_stop_CallInstance;
  if (Mock.ledc_stop_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_stop);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_stop_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_set_freq_CallInstance;
  if (Mock.ledc_set_freq_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_set_freq);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_set_freq_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_get_freq_CallInstance;
  if (Mock.ledc_get_freq_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_get_freq);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_get_freq_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_set_duty_with_hpoint_CallInstance;
  if (Mock.ledc_set_duty_with_hpoint_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_set_duty_with_hpoint);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_set_duty_with_hpoint_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_get_hpoint_CallInstance;
  if (Mock.ledc_get_hpoint_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_get_hpoint);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_get_hpoint_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_set_duty_CallInstance;
  if (Mock.ledc_set_duty_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_set_duty);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_set_duty_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_get_duty_CallInstance;
  if (Mock.ledc_get_duty_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_get_duty);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_get_duty_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_set_fade_CallInstance;
  if (Mock.ledc_set_fade_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_set_fade);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_set_fade_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_isr_register_CallInstance;
  if (Mock.ledc_isr_register_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_isr_register);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_isr_register_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_timer_set_CallInstance;
  if (Mock.ledc_timer_set_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_timer_set);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_timer_set_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_timer_rst_CallInstance;
  if (Mock.ledc_timer_rst_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_timer_rst);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_timer_rst_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_timer_pause_CallInstance;
  if (Mock.ledc_timer_pause_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_timer_pause);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_timer_pause_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_timer_resume_CallInstance;
  if (Mock.ledc_timer_resume_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_timer_resume);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_timer_resume_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_bind_channel_timer_CallInstance;
  if (Mock.ledc_bind_channel_timer_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_bind_channel_timer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_bind_channel_timer_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_set_fade_with_step_CallInstance;
  if (Mock.ledc_set_fade_with_step_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_set_fade_with_step);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_set_fade_with_step_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_set_fade_with_time_CallInstance;
  if (Mock.ledc_set_fade_with_time_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_set_fade_with_time);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_set_fade_with_time_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_fade_func_install_CallInstance;
  if (Mock.ledc_fade_func_install_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_fade_func_install);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_fade_func_install_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_fade_func_uninstall_CallInstance;
  if (Mock.ledc_fade_func_uninstall_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_fade_func_uninstall);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_fade_func_uninstall_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_fade_start_CallInstance;
  if (Mock.ledc_fade_start_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_fade_start);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_fade_start_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_set_duty_and_update_CallInstance;
  if (Mock.ledc_set_duty_and_update_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_set_duty_and_update);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_set_duty_and_update_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_set_fade_time_and_start_CallInstance;
  if (Mock.ledc_set_fade_time_and_start_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_set_fade_time_and_start);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_set_fade_time_and_start_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_set_fade_step_and_start_CallInstance;
  if (Mock.ledc_set_fade_step_and_start_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_set_fade_step_and_start);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_set_fade_step_and_start_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
  call_instance = Mock.ledc_cb_register_CallInstance;
  if (Mock.ledc_cb_register_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_ledc_cb_register);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  if (Mock.ledc_cb_register_CallbackFunctionPointer != NULL)
  {
    call_instance = CMOCK_GUTS_NONE;
    (void)call_instance;
  }
}

void mock_ledc_Init(void)
{
  mock_ledc_Destroy();
}

void mock_ledc_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

esp_err_t ledc_channel_config(const ledc_channel_config_t* ledc_conf)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_channel_config_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_channel_config);
  cmock_call_instance = (CMOCK_ledc_channel_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_channel_config_CallInstance);
  Mock.ledc_channel_config_CallInstance = CMock_Guts_MemNext(Mock.ledc_channel_config_CallInstance);
  if (Mock.ledc_channel_config_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_channel_config_FinalReturn;
    memcpy((void*)(&Mock.ledc_channel_config_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_channel_config_CallbackBool &&
      Mock.ledc_channel_config_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_channel_config_CallbackFunctionPointer(ledc_conf, Mock.ledc_channel_config_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_ledc_conf)
  {
    UNITY_SET_DETAILS(CMockString_ledc_channel_config,CMockString_ledc_conf);
    if (cmock_call_instance->Expected_ledc_conf == NULL)
      { UNITY_TEST_ASSERT_NULL(ledc_conf, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_ledc_conf), (void*)(ledc_conf), sizeof(const ledc_channel_config_t), cmock_call_instance->Expected_ledc_conf_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.ledc_channel_config_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_channel_config_CallbackFunctionPointer(ledc_conf, Mock.ledc_channel_config_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_channel_config(CMOCK_ledc_channel_config_CALL_INSTANCE* cmock_call_instance, const ledc_channel_config_t* ledc_conf, int ledc_conf_Depth);
void CMockExpectParameters_ledc_channel_config(CMOCK_ledc_channel_config_CALL_INSTANCE* cmock_call_instance, const ledc_channel_config_t* ledc_conf, int ledc_conf_Depth)
{
  cmock_call_instance->Expected_ledc_conf = ledc_conf;
  cmock_call_instance->Expected_ledc_conf_Depth = ledc_conf_Depth;
  cmock_call_instance->IgnoreArg_ledc_conf = 0;
}

void ledc_channel_config_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_channel_config_CALL_INSTANCE));
  CMOCK_ledc_channel_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_channel_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_channel_config_CallInstance = CMock_Guts_MemChain(Mock.ledc_channel_config_CallInstance, cmock_guts_index);
  Mock.ledc_channel_config_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_channel_config_IgnoreBool = (char)1;
}

void ledc_channel_config_CMockStopIgnore(void)
{
  if(Mock.ledc_channel_config_IgnoreBool)
    Mock.ledc_channel_config_CallInstance = CMock_Guts_MemNext(Mock.ledc_channel_config_CallInstance);
  Mock.ledc_channel_config_IgnoreBool = (char)0;
}

void ledc_channel_config_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const ledc_channel_config_t* ledc_conf, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_channel_config_CALL_INSTANCE));
  CMOCK_ledc_channel_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_channel_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_channel_config_CallInstance = CMock_Guts_MemChain(Mock.ledc_channel_config_CallInstance, cmock_guts_index);
  Mock.ledc_channel_config_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_channel_config(cmock_call_instance, ledc_conf, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_channel_config_AddCallback(CMOCK_ledc_channel_config_CALLBACK Callback)
{
  Mock.ledc_channel_config_IgnoreBool = (char)0;
  Mock.ledc_channel_config_CallbackBool = (char)1;
  Mock.ledc_channel_config_CallbackFunctionPointer = Callback;
}

void ledc_channel_config_Stub(CMOCK_ledc_channel_config_CALLBACK Callback)
{
  Mock.ledc_channel_config_IgnoreBool = (char)0;
  Mock.ledc_channel_config_CallbackBool = (char)0;
  Mock.ledc_channel_config_CallbackFunctionPointer = Callback;
}

void ledc_channel_config_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const ledc_channel_config_t* ledc_conf, int ledc_conf_Depth, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_channel_config_CALL_INSTANCE));
  CMOCK_ledc_channel_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_channel_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_channel_config_CallInstance = CMock_Guts_MemChain(Mock.ledc_channel_config_CallInstance, cmock_guts_index);
  Mock.ledc_channel_config_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_channel_config(cmock_call_instance, ledc_conf, ledc_conf_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ledc_channel_config_CMockIgnoreArg_ledc_conf(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_channel_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_channel_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_channel_config_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ledc_conf = 1;
}

esp_err_t ledc_timer_config(const ledc_timer_config_t* timer_conf)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_timer_config_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_timer_config);
  cmock_call_instance = (CMOCK_ledc_timer_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_timer_config_CallInstance);
  Mock.ledc_timer_config_CallInstance = CMock_Guts_MemNext(Mock.ledc_timer_config_CallInstance);
  if (Mock.ledc_timer_config_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_timer_config_FinalReturn;
    memcpy((void*)(&Mock.ledc_timer_config_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_timer_config_CallbackBool &&
      Mock.ledc_timer_config_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_timer_config_CallbackFunctionPointer(timer_conf, Mock.ledc_timer_config_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_timer_conf)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_config,CMockString_timer_conf);
    if (cmock_call_instance->Expected_timer_conf == NULL)
      { UNITY_TEST_ASSERT_NULL(timer_conf, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_timer_conf), (void*)(timer_conf), sizeof(const ledc_timer_config_t), cmock_call_instance->Expected_timer_conf_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.ledc_timer_config_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_timer_config_CallbackFunctionPointer(timer_conf, Mock.ledc_timer_config_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_timer_config(CMOCK_ledc_timer_config_CALL_INSTANCE* cmock_call_instance, const ledc_timer_config_t* timer_conf, int timer_conf_Depth);
void CMockExpectParameters_ledc_timer_config(CMOCK_ledc_timer_config_CALL_INSTANCE* cmock_call_instance, const ledc_timer_config_t* timer_conf, int timer_conf_Depth)
{
  cmock_call_instance->Expected_timer_conf = timer_conf;
  cmock_call_instance->Expected_timer_conf_Depth = timer_conf_Depth;
  cmock_call_instance->IgnoreArg_timer_conf = 0;
}

void ledc_timer_config_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_timer_config_CALL_INSTANCE));
  CMOCK_ledc_timer_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_timer_config_CallInstance = CMock_Guts_MemChain(Mock.ledc_timer_config_CallInstance, cmock_guts_index);
  Mock.ledc_timer_config_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_timer_config_IgnoreBool = (char)1;
}

void ledc_timer_config_CMockStopIgnore(void)
{
  if(Mock.ledc_timer_config_IgnoreBool)
    Mock.ledc_timer_config_CallInstance = CMock_Guts_MemNext(Mock.ledc_timer_config_CallInstance);
  Mock.ledc_timer_config_IgnoreBool = (char)0;
}

void ledc_timer_config_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const ledc_timer_config_t* timer_conf, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_timer_config_CALL_INSTANCE));
  CMOCK_ledc_timer_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_timer_config_CallInstance = CMock_Guts_MemChain(Mock.ledc_timer_config_CallInstance, cmock_guts_index);
  Mock.ledc_timer_config_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_timer_config(cmock_call_instance, timer_conf, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_timer_config_AddCallback(CMOCK_ledc_timer_config_CALLBACK Callback)
{
  Mock.ledc_timer_config_IgnoreBool = (char)0;
  Mock.ledc_timer_config_CallbackBool = (char)1;
  Mock.ledc_timer_config_CallbackFunctionPointer = Callback;
}

void ledc_timer_config_Stub(CMOCK_ledc_timer_config_CALLBACK Callback)
{
  Mock.ledc_timer_config_IgnoreBool = (char)0;
  Mock.ledc_timer_config_CallbackBool = (char)0;
  Mock.ledc_timer_config_CallbackFunctionPointer = Callback;
}

void ledc_timer_config_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, const ledc_timer_config_t* timer_conf, int timer_conf_Depth, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_timer_config_CALL_INSTANCE));
  CMOCK_ledc_timer_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_timer_config_CallInstance = CMock_Guts_MemChain(Mock.ledc_timer_config_CallInstance, cmock_guts_index);
  Mock.ledc_timer_config_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_timer_config(cmock_call_instance, timer_conf, timer_conf_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ledc_timer_config_CMockIgnoreArg_timer_conf(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_config_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_config_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_config_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_timer_conf = 1;
}

esp_err_t ledc_update_duty(ledc_mode_t speed_mode, ledc_channel_t channel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_update_duty_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_update_duty);
  cmock_call_instance = (CMOCK_ledc_update_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_update_duty_CallInstance);
  Mock.ledc_update_duty_CallInstance = CMock_Guts_MemNext(Mock.ledc_update_duty_CallInstance);
  if (Mock.ledc_update_duty_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_update_duty_FinalReturn;
    memcpy((void*)(&Mock.ledc_update_duty_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_update_duty_CallbackBool &&
      Mock.ledc_update_duty_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_update_duty_CallbackFunctionPointer(speed_mode, channel, Mock.ledc_update_duty_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_update_duty,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_update_duty,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_update_duty_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_update_duty_CallbackFunctionPointer(speed_mode, channel, Mock.ledc_update_duty_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_update_duty(CMOCK_ledc_update_duty_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel);
void CMockExpectParameters_ledc_update_duty(CMOCK_ledc_update_duty_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
}

void ledc_update_duty_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_update_duty_CALL_INSTANCE));
  CMOCK_ledc_update_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_update_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_update_duty_CallInstance = CMock_Guts_MemChain(Mock.ledc_update_duty_CallInstance, cmock_guts_index);
  Mock.ledc_update_duty_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_update_duty_IgnoreBool = (char)1;
}

void ledc_update_duty_CMockStopIgnore(void)
{
  if(Mock.ledc_update_duty_IgnoreBool)
    Mock.ledc_update_duty_CallInstance = CMock_Guts_MemNext(Mock.ledc_update_duty_CallInstance);
  Mock.ledc_update_duty_IgnoreBool = (char)0;
}

void ledc_update_duty_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_update_duty_CALL_INSTANCE));
  CMOCK_ledc_update_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_update_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_update_duty_CallInstance = CMock_Guts_MemChain(Mock.ledc_update_duty_CallInstance, cmock_guts_index);
  Mock.ledc_update_duty_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_update_duty(cmock_call_instance, speed_mode, channel);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_update_duty_AddCallback(CMOCK_ledc_update_duty_CALLBACK Callback)
{
  Mock.ledc_update_duty_IgnoreBool = (char)0;
  Mock.ledc_update_duty_CallbackBool = (char)1;
  Mock.ledc_update_duty_CallbackFunctionPointer = Callback;
}

void ledc_update_duty_Stub(CMOCK_ledc_update_duty_CALLBACK Callback)
{
  Mock.ledc_update_duty_IgnoreBool = (char)0;
  Mock.ledc_update_duty_CallbackBool = (char)0;
  Mock.ledc_update_duty_CallbackFunctionPointer = Callback;
}

void ledc_update_duty_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_update_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_update_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_update_duty_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_update_duty_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_update_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_update_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_update_duty_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

esp_err_t ledc_set_pin(int gpio_num, ledc_mode_t speed_mode, ledc_channel_t ledc_channel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_set_pin_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_set_pin);
  cmock_call_instance = (CMOCK_ledc_set_pin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_set_pin_CallInstance);
  Mock.ledc_set_pin_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_pin_CallInstance);
  if (Mock.ledc_set_pin_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_set_pin_FinalReturn;
    memcpy((void*)(&Mock.ledc_set_pin_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_set_pin_CallbackBool &&
      Mock.ledc_set_pin_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_set_pin_CallbackFunctionPointer(gpio_num, speed_mode, ledc_channel, Mock.ledc_set_pin_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_gpio_num)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_pin,CMockString_gpio_num);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_gpio_num, gpio_num, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_pin,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_ledc_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_pin,CMockString_ledc_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_ledc_channel), (void*)(&ledc_channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_set_pin_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_set_pin_CallbackFunctionPointer(gpio_num, speed_mode, ledc_channel, Mock.ledc_set_pin_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_set_pin(CMOCK_ledc_set_pin_CALL_INSTANCE* cmock_call_instance, int gpio_num, ledc_mode_t speed_mode, ledc_channel_t ledc_channel);
void CMockExpectParameters_ledc_set_pin(CMOCK_ledc_set_pin_CALL_INSTANCE* cmock_call_instance, int gpio_num, ledc_mode_t speed_mode, ledc_channel_t ledc_channel)
{
  cmock_call_instance->Expected_gpio_num = gpio_num;
  cmock_call_instance->IgnoreArg_gpio_num = 0;
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_ledc_channel), (void*)(&ledc_channel),
         sizeof(ledc_channel_t[sizeof(ledc_channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_ledc_channel = 0;
}

void ledc_set_pin_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_pin_CALL_INSTANCE));
  CMOCK_ledc_set_pin_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_pin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_pin_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_pin_CallInstance, cmock_guts_index);
  Mock.ledc_set_pin_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_set_pin_IgnoreBool = (char)1;
}

void ledc_set_pin_CMockStopIgnore(void)
{
  if(Mock.ledc_set_pin_IgnoreBool)
    Mock.ledc_set_pin_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_pin_CallInstance);
  Mock.ledc_set_pin_IgnoreBool = (char)0;
}

void ledc_set_pin_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int gpio_num, ledc_mode_t speed_mode, ledc_channel_t ledc_channel, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_pin_CALL_INSTANCE));
  CMOCK_ledc_set_pin_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_pin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_pin_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_pin_CallInstance, cmock_guts_index);
  Mock.ledc_set_pin_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_set_pin(cmock_call_instance, gpio_num, speed_mode, ledc_channel);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_set_pin_AddCallback(CMOCK_ledc_set_pin_CALLBACK Callback)
{
  Mock.ledc_set_pin_IgnoreBool = (char)0;
  Mock.ledc_set_pin_CallbackBool = (char)1;
  Mock.ledc_set_pin_CallbackFunctionPointer = Callback;
}

void ledc_set_pin_Stub(CMOCK_ledc_set_pin_CALLBACK Callback)
{
  Mock.ledc_set_pin_IgnoreBool = (char)0;
  Mock.ledc_set_pin_CallbackBool = (char)0;
  Mock.ledc_set_pin_CallbackFunctionPointer = Callback;
}

void ledc_set_pin_CMockIgnoreArg_gpio_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_pin_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_pin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_pin_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_gpio_num = 1;
}

void ledc_set_pin_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_pin_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_pin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_pin_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_set_pin_CMockIgnoreArg_ledc_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_pin_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_pin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_pin_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_ledc_channel = 1;
}

esp_err_t ledc_stop(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t idle_level)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_stop_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_stop);
  cmock_call_instance = (CMOCK_ledc_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_stop_CallInstance);
  Mock.ledc_stop_CallInstance = CMock_Guts_MemNext(Mock.ledc_stop_CallInstance);
  if (Mock.ledc_stop_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_stop_FinalReturn;
    memcpy((void*)(&Mock.ledc_stop_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_stop_CallbackBool &&
      Mock.ledc_stop_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_stop_CallbackFunctionPointer(speed_mode, channel, idle_level, Mock.ledc_stop_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_stop,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_stop,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_idle_level)
  {
    UNITY_SET_DETAILS(CMockString_ledc_stop,CMockString_idle_level);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_idle_level, idle_level, cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_stop_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_stop_CallbackFunctionPointer(speed_mode, channel, idle_level, Mock.ledc_stop_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_stop(CMOCK_ledc_stop_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t idle_level);
void CMockExpectParameters_ledc_stop(CMOCK_ledc_stop_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t idle_level)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  cmock_call_instance->Expected_idle_level = idle_level;
  cmock_call_instance->IgnoreArg_idle_level = 0;
}

void ledc_stop_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_stop_CALL_INSTANCE));
  CMOCK_ledc_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_stop_CallInstance = CMock_Guts_MemChain(Mock.ledc_stop_CallInstance, cmock_guts_index);
  Mock.ledc_stop_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_stop_IgnoreBool = (char)1;
}

void ledc_stop_CMockStopIgnore(void)
{
  if(Mock.ledc_stop_IgnoreBool)
    Mock.ledc_stop_CallInstance = CMock_Guts_MemNext(Mock.ledc_stop_CallInstance);
  Mock.ledc_stop_IgnoreBool = (char)0;
}

void ledc_stop_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t idle_level, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_stop_CALL_INSTANCE));
  CMOCK_ledc_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_stop_CallInstance = CMock_Guts_MemChain(Mock.ledc_stop_CallInstance, cmock_guts_index);
  Mock.ledc_stop_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_stop(cmock_call_instance, speed_mode, channel, idle_level);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_stop_AddCallback(CMOCK_ledc_stop_CALLBACK Callback)
{
  Mock.ledc_stop_IgnoreBool = (char)0;
  Mock.ledc_stop_CallbackBool = (char)1;
  Mock.ledc_stop_CallbackFunctionPointer = Callback;
}

void ledc_stop_Stub(CMOCK_ledc_stop_CALLBACK Callback)
{
  Mock.ledc_stop_IgnoreBool = (char)0;
  Mock.ledc_stop_CallbackBool = (char)0;
  Mock.ledc_stop_CallbackFunctionPointer = Callback;
}

void ledc_stop_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_stop_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_stop_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_stop_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_stop_CMockIgnoreArg_idle_level(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_stop_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_stop_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_stop_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_idle_level = 1;
}

esp_err_t ledc_set_freq(ledc_mode_t speed_mode, ledc_timer_t timer_num, uint32_t freq_hz)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_set_freq_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_set_freq);
  cmock_call_instance = (CMOCK_ledc_set_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_set_freq_CallInstance);
  Mock.ledc_set_freq_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_freq_CallInstance);
  if (Mock.ledc_set_freq_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_set_freq_FinalReturn;
    memcpy((void*)(&Mock.ledc_set_freq_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_set_freq_CallbackBool &&
      Mock.ledc_set_freq_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_set_freq_CallbackFunctionPointer(speed_mode, timer_num, freq_hz, Mock.ledc_set_freq_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_freq,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_timer_num)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_freq,CMockString_timer_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_num), (void*)(&timer_num), sizeof(ledc_timer_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_freq_hz)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_freq,CMockString_freq_hz);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_freq_hz, freq_hz, cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_set_freq_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_set_freq_CallbackFunctionPointer(speed_mode, timer_num, freq_hz, Mock.ledc_set_freq_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_set_freq(CMOCK_ledc_set_freq_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_num, uint32_t freq_hz);
void CMockExpectParameters_ledc_set_freq(CMOCK_ledc_set_freq_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_num, uint32_t freq_hz)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_timer_num), (void*)(&timer_num),
         sizeof(ledc_timer_t[sizeof(timer_num) == sizeof(ledc_timer_t) ? 1 : -1])); /* add ledc_timer_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_timer_num = 0;
  cmock_call_instance->Expected_freq_hz = freq_hz;
  cmock_call_instance->IgnoreArg_freq_hz = 0;
}

void ledc_set_freq_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_freq_CALL_INSTANCE));
  CMOCK_ledc_set_freq_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_freq_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_freq_CallInstance, cmock_guts_index);
  Mock.ledc_set_freq_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_set_freq_IgnoreBool = (char)1;
}

void ledc_set_freq_CMockStopIgnore(void)
{
  if(Mock.ledc_set_freq_IgnoreBool)
    Mock.ledc_set_freq_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_freq_CallInstance);
  Mock.ledc_set_freq_IgnoreBool = (char)0;
}

void ledc_set_freq_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_timer_t timer_num, uint32_t freq_hz, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_freq_CALL_INSTANCE));
  CMOCK_ledc_set_freq_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_freq_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_freq_CallInstance, cmock_guts_index);
  Mock.ledc_set_freq_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_set_freq(cmock_call_instance, speed_mode, timer_num, freq_hz);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_set_freq_AddCallback(CMOCK_ledc_set_freq_CALLBACK Callback)
{
  Mock.ledc_set_freq_IgnoreBool = (char)0;
  Mock.ledc_set_freq_CallbackBool = (char)1;
  Mock.ledc_set_freq_CallbackFunctionPointer = Callback;
}

void ledc_set_freq_Stub(CMOCK_ledc_set_freq_CALLBACK Callback)
{
  Mock.ledc_set_freq_IgnoreBool = (char)0;
  Mock.ledc_set_freq_CallbackBool = (char)0;
  Mock.ledc_set_freq_CallbackFunctionPointer = Callback;
}

void ledc_set_freq_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_freq_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_freq_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_set_freq_CMockIgnoreArg_timer_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_freq_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_freq_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_timer_num = 1;
}

void ledc_set_freq_CMockIgnoreArg_freq_hz(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_freq_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_freq_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_freq_hz = 1;
}

uint32_t ledc_get_freq(ledc_mode_t speed_mode, ledc_timer_t timer_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_get_freq_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_get_freq);
  cmock_call_instance = (CMOCK_ledc_get_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_get_freq_CallInstance);
  Mock.ledc_get_freq_CallInstance = CMock_Guts_MemNext(Mock.ledc_get_freq_CallInstance);
  if (Mock.ledc_get_freq_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_get_freq_FinalReturn;
    Mock.ledc_get_freq_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_get_freq_CallbackBool &&
      Mock.ledc_get_freq_CallbackFunctionPointer != NULL)
  {
    uint32_t cmock_cb_ret = Mock.ledc_get_freq_CallbackFunctionPointer(speed_mode, timer_num, Mock.ledc_get_freq_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_get_freq,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_timer_num)
  {
    UNITY_SET_DETAILS(CMockString_ledc_get_freq,CMockString_timer_num);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_num), (void*)(&timer_num), sizeof(ledc_timer_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_get_freq_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_get_freq_CallbackFunctionPointer(speed_mode, timer_num, Mock.ledc_get_freq_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_get_freq(CMOCK_ledc_get_freq_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_num);
void CMockExpectParameters_ledc_get_freq(CMOCK_ledc_get_freq_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_timer_num), (void*)(&timer_num),
         sizeof(ledc_timer_t[sizeof(timer_num) == sizeof(ledc_timer_t) ? 1 : -1])); /* add ledc_timer_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_timer_num = 0;
}

void ledc_get_freq_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_get_freq_CALL_INSTANCE));
  CMOCK_ledc_get_freq_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_get_freq_CallInstance = CMock_Guts_MemChain(Mock.ledc_get_freq_CallInstance, cmock_guts_index);
  Mock.ledc_get_freq_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_get_freq_IgnoreBool = (char)1;
}

void ledc_get_freq_CMockStopIgnore(void)
{
  if(Mock.ledc_get_freq_IgnoreBool)
    Mock.ledc_get_freq_CallInstance = CMock_Guts_MemNext(Mock.ledc_get_freq_CallInstance);
  Mock.ledc_get_freq_IgnoreBool = (char)0;
}

void ledc_get_freq_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_timer_t timer_num, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_get_freq_CALL_INSTANCE));
  CMOCK_ledc_get_freq_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_get_freq_CallInstance = CMock_Guts_MemChain(Mock.ledc_get_freq_CallInstance, cmock_guts_index);
  Mock.ledc_get_freq_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_get_freq(cmock_call_instance, speed_mode, timer_num);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ledc_get_freq_AddCallback(CMOCK_ledc_get_freq_CALLBACK Callback)
{
  Mock.ledc_get_freq_IgnoreBool = (char)0;
  Mock.ledc_get_freq_CallbackBool = (char)1;
  Mock.ledc_get_freq_CallbackFunctionPointer = Callback;
}

void ledc_get_freq_Stub(CMOCK_ledc_get_freq_CALLBACK Callback)
{
  Mock.ledc_get_freq_IgnoreBool = (char)0;
  Mock.ledc_get_freq_CallbackBool = (char)0;
  Mock.ledc_get_freq_CallbackFunctionPointer = Callback;
}

void ledc_get_freq_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_get_freq_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_get_freq_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_get_freq_CMockIgnoreArg_timer_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_get_freq_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_freq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_get_freq_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_timer_num = 1;
}

esp_err_t ledc_set_duty_with_hpoint(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, uint32_t hpoint)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_set_duty_with_hpoint);
  cmock_call_instance = (CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_set_duty_with_hpoint_CallInstance);
  Mock.ledc_set_duty_with_hpoint_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_duty_with_hpoint_CallInstance);
  if (Mock.ledc_set_duty_with_hpoint_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_set_duty_with_hpoint_FinalReturn;
    memcpy((void*)(&Mock.ledc_set_duty_with_hpoint_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_set_duty_with_hpoint_CallbackBool &&
      Mock.ledc_set_duty_with_hpoint_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_set_duty_with_hpoint_CallbackFunctionPointer(speed_mode, channel, duty, hpoint, Mock.ledc_set_duty_with_hpoint_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_duty_with_hpoint,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_duty_with_hpoint,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_duty)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_duty_with_hpoint,CMockString_duty);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_duty, duty, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_hpoint)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_duty_with_hpoint,CMockString_hpoint);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_hpoint, hpoint, cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_set_duty_with_hpoint_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_set_duty_with_hpoint_CallbackFunctionPointer(speed_mode, channel, duty, hpoint, Mock.ledc_set_duty_with_hpoint_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_set_duty_with_hpoint(CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, uint32_t hpoint);
void CMockExpectParameters_ledc_set_duty_with_hpoint(CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, uint32_t hpoint)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  cmock_call_instance->Expected_duty = duty;
  cmock_call_instance->IgnoreArg_duty = 0;
  cmock_call_instance->Expected_hpoint = hpoint;
  cmock_call_instance->IgnoreArg_hpoint = 0;
}

void ledc_set_duty_with_hpoint_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE));
  CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_duty_with_hpoint_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_duty_with_hpoint_CallInstance, cmock_guts_index);
  Mock.ledc_set_duty_with_hpoint_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_set_duty_with_hpoint_IgnoreBool = (char)1;
}

void ledc_set_duty_with_hpoint_CMockStopIgnore(void)
{
  if(Mock.ledc_set_duty_with_hpoint_IgnoreBool)
    Mock.ledc_set_duty_with_hpoint_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_duty_with_hpoint_CallInstance);
  Mock.ledc_set_duty_with_hpoint_IgnoreBool = (char)0;
}

void ledc_set_duty_with_hpoint_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, uint32_t hpoint, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE));
  CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_duty_with_hpoint_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_duty_with_hpoint_CallInstance, cmock_guts_index);
  Mock.ledc_set_duty_with_hpoint_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_set_duty_with_hpoint(cmock_call_instance, speed_mode, channel, duty, hpoint);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_set_duty_with_hpoint_AddCallback(CMOCK_ledc_set_duty_with_hpoint_CALLBACK Callback)
{
  Mock.ledc_set_duty_with_hpoint_IgnoreBool = (char)0;
  Mock.ledc_set_duty_with_hpoint_CallbackBool = (char)1;
  Mock.ledc_set_duty_with_hpoint_CallbackFunctionPointer = Callback;
}

void ledc_set_duty_with_hpoint_Stub(CMOCK_ledc_set_duty_with_hpoint_CALLBACK Callback)
{
  Mock.ledc_set_duty_with_hpoint_IgnoreBool = (char)0;
  Mock.ledc_set_duty_with_hpoint_CallbackBool = (char)0;
  Mock.ledc_set_duty_with_hpoint_CallbackFunctionPointer = Callback;
}

void ledc_set_duty_with_hpoint_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_duty_with_hpoint_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_set_duty_with_hpoint_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_duty_with_hpoint_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_set_duty_with_hpoint_CMockIgnoreArg_duty(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_duty_with_hpoint_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_duty = 1;
}

void ledc_set_duty_with_hpoint_CMockIgnoreArg_hpoint(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_with_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_duty_with_hpoint_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_hpoint = 1;
}

int ledc_get_hpoint(ledc_mode_t speed_mode, ledc_channel_t channel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_get_hpoint_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_get_hpoint);
  cmock_call_instance = (CMOCK_ledc_get_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_get_hpoint_CallInstance);
  Mock.ledc_get_hpoint_CallInstance = CMock_Guts_MemNext(Mock.ledc_get_hpoint_CallInstance);
  if (Mock.ledc_get_hpoint_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_get_hpoint_FinalReturn;
    Mock.ledc_get_hpoint_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_get_hpoint_CallbackBool &&
      Mock.ledc_get_hpoint_CallbackFunctionPointer != NULL)
  {
    int cmock_cb_ret = Mock.ledc_get_hpoint_CallbackFunctionPointer(speed_mode, channel, Mock.ledc_get_hpoint_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_get_hpoint,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_get_hpoint,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_get_hpoint_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_get_hpoint_CallbackFunctionPointer(speed_mode, channel, Mock.ledc_get_hpoint_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_get_hpoint(CMOCK_ledc_get_hpoint_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel);
void CMockExpectParameters_ledc_get_hpoint(CMOCK_ledc_get_hpoint_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
}

void ledc_get_hpoint_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_get_hpoint_CALL_INSTANCE));
  CMOCK_ledc_get_hpoint_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_get_hpoint_CallInstance = CMock_Guts_MemChain(Mock.ledc_get_hpoint_CallInstance, cmock_guts_index);
  Mock.ledc_get_hpoint_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_get_hpoint_IgnoreBool = (char)1;
}

void ledc_get_hpoint_CMockStopIgnore(void)
{
  if(Mock.ledc_get_hpoint_IgnoreBool)
    Mock.ledc_get_hpoint_CallInstance = CMock_Guts_MemNext(Mock.ledc_get_hpoint_CallInstance);
  Mock.ledc_get_hpoint_IgnoreBool = (char)0;
}

void ledc_get_hpoint_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_get_hpoint_CALL_INSTANCE));
  CMOCK_ledc_get_hpoint_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_get_hpoint_CallInstance = CMock_Guts_MemChain(Mock.ledc_get_hpoint_CallInstance, cmock_guts_index);
  Mock.ledc_get_hpoint_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_get_hpoint(cmock_call_instance, speed_mode, channel);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ledc_get_hpoint_AddCallback(CMOCK_ledc_get_hpoint_CALLBACK Callback)
{
  Mock.ledc_get_hpoint_IgnoreBool = (char)0;
  Mock.ledc_get_hpoint_CallbackBool = (char)1;
  Mock.ledc_get_hpoint_CallbackFunctionPointer = Callback;
}

void ledc_get_hpoint_Stub(CMOCK_ledc_get_hpoint_CALLBACK Callback)
{
  Mock.ledc_get_hpoint_IgnoreBool = (char)0;
  Mock.ledc_get_hpoint_CallbackBool = (char)0;
  Mock.ledc_get_hpoint_CallbackFunctionPointer = Callback;
}

void ledc_get_hpoint_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_get_hpoint_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_get_hpoint_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_get_hpoint_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_get_hpoint_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_hpoint_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_get_hpoint_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

esp_err_t ledc_set_duty(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_set_duty_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_set_duty);
  cmock_call_instance = (CMOCK_ledc_set_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_set_duty_CallInstance);
  Mock.ledc_set_duty_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_duty_CallInstance);
  if (Mock.ledc_set_duty_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_set_duty_FinalReturn;
    memcpy((void*)(&Mock.ledc_set_duty_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_set_duty_CallbackBool &&
      Mock.ledc_set_duty_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_set_duty_CallbackFunctionPointer(speed_mode, channel, duty, Mock.ledc_set_duty_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_duty,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_duty,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_duty)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_duty,CMockString_duty);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_duty, duty, cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_set_duty_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_set_duty_CallbackFunctionPointer(speed_mode, channel, duty, Mock.ledc_set_duty_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_set_duty(CMOCK_ledc_set_duty_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty);
void CMockExpectParameters_ledc_set_duty(CMOCK_ledc_set_duty_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  cmock_call_instance->Expected_duty = duty;
  cmock_call_instance->IgnoreArg_duty = 0;
}

void ledc_set_duty_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_duty_CALL_INSTANCE));
  CMOCK_ledc_set_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_duty_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_duty_CallInstance, cmock_guts_index);
  Mock.ledc_set_duty_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_set_duty_IgnoreBool = (char)1;
}

void ledc_set_duty_CMockStopIgnore(void)
{
  if(Mock.ledc_set_duty_IgnoreBool)
    Mock.ledc_set_duty_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_duty_CallInstance);
  Mock.ledc_set_duty_IgnoreBool = (char)0;
}

void ledc_set_duty_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_duty_CALL_INSTANCE));
  CMOCK_ledc_set_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_duty_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_duty_CallInstance, cmock_guts_index);
  Mock.ledc_set_duty_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_set_duty(cmock_call_instance, speed_mode, channel, duty);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_set_duty_AddCallback(CMOCK_ledc_set_duty_CALLBACK Callback)
{
  Mock.ledc_set_duty_IgnoreBool = (char)0;
  Mock.ledc_set_duty_CallbackBool = (char)1;
  Mock.ledc_set_duty_CallbackFunctionPointer = Callback;
}

void ledc_set_duty_Stub(CMOCK_ledc_set_duty_CALLBACK Callback)
{
  Mock.ledc_set_duty_IgnoreBool = (char)0;
  Mock.ledc_set_duty_CallbackBool = (char)0;
  Mock.ledc_set_duty_CallbackFunctionPointer = Callback;
}

void ledc_set_duty_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_duty_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_set_duty_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_duty_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_set_duty_CMockIgnoreArg_duty(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_duty_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_duty = 1;
}

uint32_t ledc_get_duty(ledc_mode_t speed_mode, ledc_channel_t channel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_get_duty_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_get_duty);
  cmock_call_instance = (CMOCK_ledc_get_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_get_duty_CallInstance);
  Mock.ledc_get_duty_CallInstance = CMock_Guts_MemNext(Mock.ledc_get_duty_CallInstance);
  if (Mock.ledc_get_duty_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_get_duty_FinalReturn;
    Mock.ledc_get_duty_FinalReturn = cmock_call_instance->ReturnVal;
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_get_duty_CallbackBool &&
      Mock.ledc_get_duty_CallbackFunctionPointer != NULL)
  {
    uint32_t cmock_cb_ret = Mock.ledc_get_duty_CallbackFunctionPointer(speed_mode, channel, Mock.ledc_get_duty_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_get_duty,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_get_duty,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_get_duty_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_get_duty_CallbackFunctionPointer(speed_mode, channel, Mock.ledc_get_duty_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_get_duty(CMOCK_ledc_get_duty_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel);
void CMockExpectParameters_ledc_get_duty(CMOCK_ledc_get_duty_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
}

void ledc_get_duty_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_get_duty_CALL_INSTANCE));
  CMOCK_ledc_get_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_get_duty_CallInstance = CMock_Guts_MemChain(Mock.ledc_get_duty_CallInstance, cmock_guts_index);
  Mock.ledc_get_duty_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_get_duty_IgnoreBool = (char)1;
}

void ledc_get_duty_CMockStopIgnore(void)
{
  if(Mock.ledc_get_duty_IgnoreBool)
    Mock.ledc_get_duty_CallInstance = CMock_Guts_MemNext(Mock.ledc_get_duty_CallInstance);
  Mock.ledc_get_duty_IgnoreBool = (char)0;
}

void ledc_get_duty_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_get_duty_CALL_INSTANCE));
  CMOCK_ledc_get_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_get_duty_CallInstance = CMock_Guts_MemChain(Mock.ledc_get_duty_CallInstance, cmock_guts_index);
  Mock.ledc_get_duty_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_get_duty(cmock_call_instance, speed_mode, channel);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ledc_get_duty_AddCallback(CMOCK_ledc_get_duty_CALLBACK Callback)
{
  Mock.ledc_get_duty_IgnoreBool = (char)0;
  Mock.ledc_get_duty_CallbackBool = (char)1;
  Mock.ledc_get_duty_CallbackFunctionPointer = Callback;
}

void ledc_get_duty_Stub(CMOCK_ledc_get_duty_CALLBACK Callback)
{
  Mock.ledc_get_duty_IgnoreBool = (char)0;
  Mock.ledc_get_duty_CallbackBool = (char)0;
  Mock.ledc_get_duty_CallbackFunctionPointer = Callback;
}

void ledc_get_duty_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_get_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_get_duty_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_get_duty_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_get_duty_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_get_duty_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_get_duty_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

esp_err_t ledc_set_fade(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, ledc_duty_direction_t fade_direction, uint32_t step_num, uint32_t duty_cycle_num, uint32_t duty_scale)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_set_fade);
  cmock_call_instance = (CMOCK_ledc_set_fade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_set_fade_CallInstance);
  Mock.ledc_set_fade_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_fade_CallInstance);
  if (Mock.ledc_set_fade_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_set_fade_FinalReturn;
    memcpy((void*)(&Mock.ledc_set_fade_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_set_fade_CallbackBool &&
      Mock.ledc_set_fade_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_set_fade_CallbackFunctionPointer(speed_mode, channel, duty, fade_direction, step_num, duty_cycle_num, duty_scale, Mock.ledc_set_fade_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_duty)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade,CMockString_duty);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_duty, duty, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fade_direction)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade,CMockString_fade_direction);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_fade_direction), (void*)(&fade_direction), sizeof(ledc_duty_direction_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_step_num)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade,CMockString_step_num);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_step_num, step_num, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_duty_cycle_num)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade,CMockString_duty_cycle_num);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_duty_cycle_num, duty_cycle_num, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_duty_scale)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade,CMockString_duty_scale);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_duty_scale, duty_scale, cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_set_fade_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_set_fade_CallbackFunctionPointer(speed_mode, channel, duty, fade_direction, step_num, duty_cycle_num, duty_scale, Mock.ledc_set_fade_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_set_fade(CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, ledc_duty_direction_t fade_direction, uint32_t step_num, uint32_t duty_cycle_num, uint32_t duty_scale);
void CMockExpectParameters_ledc_set_fade(CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, ledc_duty_direction_t fade_direction, uint32_t step_num, uint32_t duty_cycle_num, uint32_t duty_scale)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  cmock_call_instance->Expected_duty = duty;
  cmock_call_instance->IgnoreArg_duty = 0;
  memcpy((void*)(&cmock_call_instance->Expected_fade_direction), (void*)(&fade_direction),
         sizeof(ledc_duty_direction_t[sizeof(fade_direction) == sizeof(ledc_duty_direction_t) ? 1 : -1])); /* add ledc_duty_direction_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_fade_direction = 0;
  cmock_call_instance->Expected_step_num = step_num;
  cmock_call_instance->IgnoreArg_step_num = 0;
  cmock_call_instance->Expected_duty_cycle_num = duty_cycle_num;
  cmock_call_instance->IgnoreArg_duty_cycle_num = 0;
  cmock_call_instance->Expected_duty_scale = duty_scale;
  cmock_call_instance->IgnoreArg_duty_scale = 0;
}

void ledc_set_fade_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_fade_CALL_INSTANCE));
  CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_fade_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_fade_CallInstance, cmock_guts_index);
  Mock.ledc_set_fade_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_set_fade_IgnoreBool = (char)1;
}

void ledc_set_fade_CMockStopIgnore(void)
{
  if(Mock.ledc_set_fade_IgnoreBool)
    Mock.ledc_set_fade_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_fade_CallInstance);
  Mock.ledc_set_fade_IgnoreBool = (char)0;
}

void ledc_set_fade_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, ledc_duty_direction_t fade_direction, uint32_t step_num, uint32_t duty_cycle_num, uint32_t duty_scale, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_fade_CALL_INSTANCE));
  CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_fade_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_fade_CallInstance, cmock_guts_index);
  Mock.ledc_set_fade_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_set_fade(cmock_call_instance, speed_mode, channel, duty, fade_direction, step_num, duty_cycle_num, duty_scale);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_set_fade_AddCallback(CMOCK_ledc_set_fade_CALLBACK Callback)
{
  Mock.ledc_set_fade_IgnoreBool = (char)0;
  Mock.ledc_set_fade_CallbackBool = (char)1;
  Mock.ledc_set_fade_CallbackFunctionPointer = Callback;
}

void ledc_set_fade_Stub(CMOCK_ledc_set_fade_CALLBACK Callback)
{
  Mock.ledc_set_fade_IgnoreBool = (char)0;
  Mock.ledc_set_fade_CallbackBool = (char)0;
  Mock.ledc_set_fade_CallbackFunctionPointer = Callback;
}

void ledc_set_fade_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_set_fade_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_set_fade_CMockIgnoreArg_duty(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_duty = 1;
}

void ledc_set_fade_CMockIgnoreArg_fade_direction(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fade_direction = 1;
}

void ledc_set_fade_CMockIgnoreArg_step_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_step_num = 1;
}

void ledc_set_fade_CMockIgnoreArg_duty_cycle_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_duty_cycle_num = 1;
}

void ledc_set_fade_CMockIgnoreArg_duty_scale(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_duty_scale = 1;
}

esp_err_t ledc_isr_register(cmock_ledc_func_ptr1 fn, void* arg, int intr_alloc_flags, ledc_isr_handle_t* handle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_isr_register);
  cmock_call_instance = (CMOCK_ledc_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_isr_register_CallInstance);
  Mock.ledc_isr_register_CallInstance = CMock_Guts_MemNext(Mock.ledc_isr_register_CallInstance);
  if (Mock.ledc_isr_register_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_isr_register_FinalReturn;
    memcpy((void*)(&Mock.ledc_isr_register_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_isr_register_CallbackBool &&
      Mock.ledc_isr_register_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_isr_register_CallbackFunctionPointer(fn, arg, intr_alloc_flags, handle, Mock.ledc_isr_register_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_fn)
  {
    UNITY_SET_DETAILS(CMockString_ledc_isr_register,CMockString_fn);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_fn, fn, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_arg)
  {
    UNITY_SET_DETAILS(CMockString_ledc_isr_register,CMockString_arg);
    if (cmock_call_instance->Expected_arg == NULL)
      { UNITY_TEST_ASSERT_NULL(arg, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_arg, arg, cmock_call_instance->Expected_arg_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_intr_alloc_flags)
  {
    UNITY_SET_DETAILS(CMockString_ledc_isr_register,CMockString_intr_alloc_flags);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_intr_alloc_flags, intr_alloc_flags, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_handle)
  {
    UNITY_SET_DETAILS(CMockString_ledc_isr_register,CMockString_handle);
    if (cmock_call_instance->Expected_handle == NULL)
      { UNITY_TEST_ASSERT_NULL(handle, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_handle), (void*)(handle), sizeof(ledc_isr_handle_t), cmock_call_instance->Expected_handle_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.ledc_isr_register_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_isr_register_CallbackFunctionPointer(fn, arg, intr_alloc_flags, handle, Mock.ledc_isr_register_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_arg_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(arg, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)arg, (void*)cmock_call_instance->ReturnThruPtr_arg_Val,
      cmock_call_instance->ReturnThruPtr_arg_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_handle_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(handle, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)handle, (void*)cmock_call_instance->ReturnThruPtr_handle_Val,
      cmock_call_instance->ReturnThruPtr_handle_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_isr_register(CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance, cmock_ledc_func_ptr1 fn, void* arg, int arg_Depth, int intr_alloc_flags, ledc_isr_handle_t* handle, int handle_Depth);
void CMockExpectParameters_ledc_isr_register(CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance, cmock_ledc_func_ptr1 fn, void* arg, int arg_Depth, int intr_alloc_flags, ledc_isr_handle_t* handle, int handle_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_fn), (void*)(&fn),
         sizeof(cmock_ledc_func_ptr1[sizeof(fn) == sizeof(cmock_ledc_func_ptr1) ? 1 : -1])); /* add cmock_ledc_func_ptr1 to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_fn = 0;
  cmock_call_instance->Expected_arg = arg;
  cmock_call_instance->Expected_arg_Depth = arg_Depth;
  cmock_call_instance->IgnoreArg_arg = 0;
  cmock_call_instance->ReturnThruPtr_arg_Used = 0;
  cmock_call_instance->Expected_intr_alloc_flags = intr_alloc_flags;
  cmock_call_instance->IgnoreArg_intr_alloc_flags = 0;
  cmock_call_instance->Expected_handle = handle;
  cmock_call_instance->Expected_handle_Depth = handle_Depth;
  cmock_call_instance->IgnoreArg_handle = 0;
  cmock_call_instance->ReturnThruPtr_handle_Used = 0;
}

void ledc_isr_register_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_isr_register_CALL_INSTANCE));
  CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_isr_register_CallInstance = CMock_Guts_MemChain(Mock.ledc_isr_register_CallInstance, cmock_guts_index);
  Mock.ledc_isr_register_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_isr_register_IgnoreBool = (char)1;
}

void ledc_isr_register_CMockStopIgnore(void)
{
  if(Mock.ledc_isr_register_IgnoreBool)
    Mock.ledc_isr_register_CallInstance = CMock_Guts_MemNext(Mock.ledc_isr_register_CallInstance);
  Mock.ledc_isr_register_IgnoreBool = (char)0;
}

void ledc_isr_register_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, cmock_ledc_func_ptr1 fn, void* arg, int intr_alloc_flags, ledc_isr_handle_t* handle, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_isr_register_CALL_INSTANCE));
  CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_isr_register_CallInstance = CMock_Guts_MemChain(Mock.ledc_isr_register_CallInstance, cmock_guts_index);
  Mock.ledc_isr_register_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_isr_register(cmock_call_instance, fn, arg, 1, intr_alloc_flags, handle, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_isr_register_AddCallback(CMOCK_ledc_isr_register_CALLBACK Callback)
{
  Mock.ledc_isr_register_IgnoreBool = (char)0;
  Mock.ledc_isr_register_CallbackBool = (char)1;
  Mock.ledc_isr_register_CallbackFunctionPointer = Callback;
}

void ledc_isr_register_Stub(CMOCK_ledc_isr_register_CALLBACK Callback)
{
  Mock.ledc_isr_register_IgnoreBool = (char)0;
  Mock.ledc_isr_register_CallbackBool = (char)0;
  Mock.ledc_isr_register_CallbackFunctionPointer = Callback;
}

void ledc_isr_register_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, cmock_ledc_func_ptr1 fn, void* arg, int arg_Depth, int intr_alloc_flags, ledc_isr_handle_t* handle, int handle_Depth, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_isr_register_CALL_INSTANCE));
  CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_isr_register_CallInstance = CMock_Guts_MemChain(Mock.ledc_isr_register_CallInstance, cmock_guts_index);
  Mock.ledc_isr_register_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_isr_register(cmock_call_instance, fn, arg, arg_Depth, intr_alloc_flags, handle, handle_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ledc_isr_register_CMockReturnMemThruPtr_arg(UNITY_LINE_TYPE cmock_line, void* arg, size_t cmock_size)
{
  CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_arg_Used = 1;
  cmock_call_instance->ReturnThruPtr_arg_Val = arg;
  cmock_call_instance->ReturnThruPtr_arg_Size = cmock_size;
}

void ledc_isr_register_CMockReturnMemThruPtr_handle(UNITY_LINE_TYPE cmock_line, ledc_isr_handle_t* handle, size_t cmock_size)
{
  CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_handle_Used = 1;
  cmock_call_instance->ReturnThruPtr_handle_Val = handle;
  cmock_call_instance->ReturnThruPtr_handle_Size = cmock_size;
}

void ledc_isr_register_CMockIgnoreArg_fn(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fn = 1;
}

void ledc_isr_register_CMockIgnoreArg_arg(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_arg = 1;
}

void ledc_isr_register_CMockIgnoreArg_intr_alloc_flags(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_intr_alloc_flags = 1;
}

void ledc_isr_register_CMockIgnoreArg_handle(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_isr_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_isr_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_isr_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_handle = 1;
}

esp_err_t ledc_timer_set(ledc_mode_t speed_mode, ledc_timer_t timer_sel, uint32_t clock_divider, uint32_t duty_resolution, ledc_clk_src_t clk_src)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_timer_set_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_timer_set);
  cmock_call_instance = (CMOCK_ledc_timer_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_timer_set_CallInstance);
  Mock.ledc_timer_set_CallInstance = CMock_Guts_MemNext(Mock.ledc_timer_set_CallInstance);
  if (Mock.ledc_timer_set_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_timer_set_FinalReturn;
    memcpy((void*)(&Mock.ledc_timer_set_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_timer_set_CallbackBool &&
      Mock.ledc_timer_set_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_timer_set_CallbackFunctionPointer(speed_mode, timer_sel, clock_divider, duty_resolution, clk_src, Mock.ledc_timer_set_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_set,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_timer_sel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_set,CMockString_timer_sel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_sel), (void*)(&timer_sel), sizeof(ledc_timer_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_clock_divider)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_set,CMockString_clock_divider);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_clock_divider, clock_divider, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_duty_resolution)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_set,CMockString_duty_resolution);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_duty_resolution, duty_resolution, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_clk_src)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_set,CMockString_clk_src);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_clk_src), (void*)(&clk_src), sizeof(ledc_clk_src_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_timer_set_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_timer_set_CallbackFunctionPointer(speed_mode, timer_sel, clock_divider, duty_resolution, clk_src, Mock.ledc_timer_set_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_timer_set(CMOCK_ledc_timer_set_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_sel, uint32_t clock_divider, uint32_t duty_resolution, ledc_clk_src_t clk_src);
void CMockExpectParameters_ledc_timer_set(CMOCK_ledc_timer_set_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_sel, uint32_t clock_divider, uint32_t duty_resolution, ledc_clk_src_t clk_src)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_timer_sel), (void*)(&timer_sel),
         sizeof(ledc_timer_t[sizeof(timer_sel) == sizeof(ledc_timer_t) ? 1 : -1])); /* add ledc_timer_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_timer_sel = 0;
  cmock_call_instance->Expected_clock_divider = clock_divider;
  cmock_call_instance->IgnoreArg_clock_divider = 0;
  cmock_call_instance->Expected_duty_resolution = duty_resolution;
  cmock_call_instance->IgnoreArg_duty_resolution = 0;
  memcpy((void*)(&cmock_call_instance->Expected_clk_src), (void*)(&clk_src),
         sizeof(ledc_clk_src_t[sizeof(clk_src) == sizeof(ledc_clk_src_t) ? 1 : -1])); /* add ledc_clk_src_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_clk_src = 0;
}

void ledc_timer_set_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_timer_set_CALL_INSTANCE));
  CMOCK_ledc_timer_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_timer_set_CallInstance = CMock_Guts_MemChain(Mock.ledc_timer_set_CallInstance, cmock_guts_index);
  Mock.ledc_timer_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_timer_set_IgnoreBool = (char)1;
}

void ledc_timer_set_CMockStopIgnore(void)
{
  if(Mock.ledc_timer_set_IgnoreBool)
    Mock.ledc_timer_set_CallInstance = CMock_Guts_MemNext(Mock.ledc_timer_set_CallInstance);
  Mock.ledc_timer_set_IgnoreBool = (char)0;
}

void ledc_timer_set_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_timer_t timer_sel, uint32_t clock_divider, uint32_t duty_resolution, ledc_clk_src_t clk_src, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_timer_set_CALL_INSTANCE));
  CMOCK_ledc_timer_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_timer_set_CallInstance = CMock_Guts_MemChain(Mock.ledc_timer_set_CallInstance, cmock_guts_index);
  Mock.ledc_timer_set_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_timer_set(cmock_call_instance, speed_mode, timer_sel, clock_divider, duty_resolution, clk_src);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_timer_set_AddCallback(CMOCK_ledc_timer_set_CALLBACK Callback)
{
  Mock.ledc_timer_set_IgnoreBool = (char)0;
  Mock.ledc_timer_set_CallbackBool = (char)1;
  Mock.ledc_timer_set_CallbackFunctionPointer = Callback;
}

void ledc_timer_set_Stub(CMOCK_ledc_timer_set_CALLBACK Callback)
{
  Mock.ledc_timer_set_IgnoreBool = (char)0;
  Mock.ledc_timer_set_CallbackBool = (char)0;
  Mock.ledc_timer_set_CallbackFunctionPointer = Callback;
}

void ledc_timer_set_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_set_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_timer_set_CMockIgnoreArg_timer_sel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_set_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_timer_sel = 1;
}

void ledc_timer_set_CMockIgnoreArg_clock_divider(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_set_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_clock_divider = 1;
}

void ledc_timer_set_CMockIgnoreArg_duty_resolution(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_set_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_duty_resolution = 1;
}

void ledc_timer_set_CMockIgnoreArg_clk_src(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_set_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_set_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_set_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_clk_src = 1;
}

esp_err_t ledc_timer_rst(ledc_mode_t speed_mode, ledc_timer_t timer_sel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_timer_rst_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_timer_rst);
  cmock_call_instance = (CMOCK_ledc_timer_rst_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_timer_rst_CallInstance);
  Mock.ledc_timer_rst_CallInstance = CMock_Guts_MemNext(Mock.ledc_timer_rst_CallInstance);
  if (Mock.ledc_timer_rst_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_timer_rst_FinalReturn;
    memcpy((void*)(&Mock.ledc_timer_rst_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_timer_rst_CallbackBool &&
      Mock.ledc_timer_rst_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_timer_rst_CallbackFunctionPointer(speed_mode, timer_sel, Mock.ledc_timer_rst_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_rst,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_timer_sel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_rst,CMockString_timer_sel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_sel), (void*)(&timer_sel), sizeof(ledc_timer_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_timer_rst_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_timer_rst_CallbackFunctionPointer(speed_mode, timer_sel, Mock.ledc_timer_rst_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_timer_rst(CMOCK_ledc_timer_rst_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_sel);
void CMockExpectParameters_ledc_timer_rst(CMOCK_ledc_timer_rst_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_sel)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_timer_sel), (void*)(&timer_sel),
         sizeof(ledc_timer_t[sizeof(timer_sel) == sizeof(ledc_timer_t) ? 1 : -1])); /* add ledc_timer_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_timer_sel = 0;
}

void ledc_timer_rst_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_timer_rst_CALL_INSTANCE));
  CMOCK_ledc_timer_rst_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_rst_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_timer_rst_CallInstance = CMock_Guts_MemChain(Mock.ledc_timer_rst_CallInstance, cmock_guts_index);
  Mock.ledc_timer_rst_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_timer_rst_IgnoreBool = (char)1;
}

void ledc_timer_rst_CMockStopIgnore(void)
{
  if(Mock.ledc_timer_rst_IgnoreBool)
    Mock.ledc_timer_rst_CallInstance = CMock_Guts_MemNext(Mock.ledc_timer_rst_CallInstance);
  Mock.ledc_timer_rst_IgnoreBool = (char)0;
}

void ledc_timer_rst_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_timer_t timer_sel, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_timer_rst_CALL_INSTANCE));
  CMOCK_ledc_timer_rst_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_rst_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_timer_rst_CallInstance = CMock_Guts_MemChain(Mock.ledc_timer_rst_CallInstance, cmock_guts_index);
  Mock.ledc_timer_rst_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_timer_rst(cmock_call_instance, speed_mode, timer_sel);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_timer_rst_AddCallback(CMOCK_ledc_timer_rst_CALLBACK Callback)
{
  Mock.ledc_timer_rst_IgnoreBool = (char)0;
  Mock.ledc_timer_rst_CallbackBool = (char)1;
  Mock.ledc_timer_rst_CallbackFunctionPointer = Callback;
}

void ledc_timer_rst_Stub(CMOCK_ledc_timer_rst_CALLBACK Callback)
{
  Mock.ledc_timer_rst_IgnoreBool = (char)0;
  Mock.ledc_timer_rst_CallbackBool = (char)0;
  Mock.ledc_timer_rst_CallbackFunctionPointer = Callback;
}

void ledc_timer_rst_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_rst_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_rst_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_rst_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_timer_rst_CMockIgnoreArg_timer_sel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_rst_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_rst_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_rst_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_timer_sel = 1;
}

esp_err_t ledc_timer_pause(ledc_mode_t speed_mode, ledc_timer_t timer_sel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_timer_pause_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_timer_pause);
  cmock_call_instance = (CMOCK_ledc_timer_pause_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_timer_pause_CallInstance);
  Mock.ledc_timer_pause_CallInstance = CMock_Guts_MemNext(Mock.ledc_timer_pause_CallInstance);
  if (Mock.ledc_timer_pause_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_timer_pause_FinalReturn;
    memcpy((void*)(&Mock.ledc_timer_pause_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_timer_pause_CallbackBool &&
      Mock.ledc_timer_pause_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_timer_pause_CallbackFunctionPointer(speed_mode, timer_sel, Mock.ledc_timer_pause_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_pause,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_timer_sel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_pause,CMockString_timer_sel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_sel), (void*)(&timer_sel), sizeof(ledc_timer_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_timer_pause_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_timer_pause_CallbackFunctionPointer(speed_mode, timer_sel, Mock.ledc_timer_pause_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_timer_pause(CMOCK_ledc_timer_pause_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_sel);
void CMockExpectParameters_ledc_timer_pause(CMOCK_ledc_timer_pause_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_sel)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_timer_sel), (void*)(&timer_sel),
         sizeof(ledc_timer_t[sizeof(timer_sel) == sizeof(ledc_timer_t) ? 1 : -1])); /* add ledc_timer_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_timer_sel = 0;
}

void ledc_timer_pause_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_timer_pause_CALL_INSTANCE));
  CMOCK_ledc_timer_pause_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_pause_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_timer_pause_CallInstance = CMock_Guts_MemChain(Mock.ledc_timer_pause_CallInstance, cmock_guts_index);
  Mock.ledc_timer_pause_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_timer_pause_IgnoreBool = (char)1;
}

void ledc_timer_pause_CMockStopIgnore(void)
{
  if(Mock.ledc_timer_pause_IgnoreBool)
    Mock.ledc_timer_pause_CallInstance = CMock_Guts_MemNext(Mock.ledc_timer_pause_CallInstance);
  Mock.ledc_timer_pause_IgnoreBool = (char)0;
}

void ledc_timer_pause_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_timer_t timer_sel, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_timer_pause_CALL_INSTANCE));
  CMOCK_ledc_timer_pause_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_pause_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_timer_pause_CallInstance = CMock_Guts_MemChain(Mock.ledc_timer_pause_CallInstance, cmock_guts_index);
  Mock.ledc_timer_pause_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_timer_pause(cmock_call_instance, speed_mode, timer_sel);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_timer_pause_AddCallback(CMOCK_ledc_timer_pause_CALLBACK Callback)
{
  Mock.ledc_timer_pause_IgnoreBool = (char)0;
  Mock.ledc_timer_pause_CallbackBool = (char)1;
  Mock.ledc_timer_pause_CallbackFunctionPointer = Callback;
}

void ledc_timer_pause_Stub(CMOCK_ledc_timer_pause_CALLBACK Callback)
{
  Mock.ledc_timer_pause_IgnoreBool = (char)0;
  Mock.ledc_timer_pause_CallbackBool = (char)0;
  Mock.ledc_timer_pause_CallbackFunctionPointer = Callback;
}

void ledc_timer_pause_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_pause_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_pause_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_pause_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_timer_pause_CMockIgnoreArg_timer_sel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_pause_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_pause_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_pause_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_timer_sel = 1;
}

esp_err_t ledc_timer_resume(ledc_mode_t speed_mode, ledc_timer_t timer_sel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_timer_resume_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_timer_resume);
  cmock_call_instance = (CMOCK_ledc_timer_resume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_timer_resume_CallInstance);
  Mock.ledc_timer_resume_CallInstance = CMock_Guts_MemNext(Mock.ledc_timer_resume_CallInstance);
  if (Mock.ledc_timer_resume_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_timer_resume_FinalReturn;
    memcpy((void*)(&Mock.ledc_timer_resume_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_timer_resume_CallbackBool &&
      Mock.ledc_timer_resume_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_timer_resume_CallbackFunctionPointer(speed_mode, timer_sel, Mock.ledc_timer_resume_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_resume,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_timer_sel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_timer_resume,CMockString_timer_sel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_sel), (void*)(&timer_sel), sizeof(ledc_timer_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_timer_resume_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_timer_resume_CallbackFunctionPointer(speed_mode, timer_sel, Mock.ledc_timer_resume_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_timer_resume(CMOCK_ledc_timer_resume_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_sel);
void CMockExpectParameters_ledc_timer_resume(CMOCK_ledc_timer_resume_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_timer_t timer_sel)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_timer_sel), (void*)(&timer_sel),
         sizeof(ledc_timer_t[sizeof(timer_sel) == sizeof(ledc_timer_t) ? 1 : -1])); /* add ledc_timer_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_timer_sel = 0;
}

void ledc_timer_resume_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_timer_resume_CALL_INSTANCE));
  CMOCK_ledc_timer_resume_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_resume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_timer_resume_CallInstance = CMock_Guts_MemChain(Mock.ledc_timer_resume_CallInstance, cmock_guts_index);
  Mock.ledc_timer_resume_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_timer_resume_IgnoreBool = (char)1;
}

void ledc_timer_resume_CMockStopIgnore(void)
{
  if(Mock.ledc_timer_resume_IgnoreBool)
    Mock.ledc_timer_resume_CallInstance = CMock_Guts_MemNext(Mock.ledc_timer_resume_CallInstance);
  Mock.ledc_timer_resume_IgnoreBool = (char)0;
}

void ledc_timer_resume_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_timer_t timer_sel, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_timer_resume_CALL_INSTANCE));
  CMOCK_ledc_timer_resume_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_resume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_timer_resume_CallInstance = CMock_Guts_MemChain(Mock.ledc_timer_resume_CallInstance, cmock_guts_index);
  Mock.ledc_timer_resume_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_timer_resume(cmock_call_instance, speed_mode, timer_sel);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_timer_resume_AddCallback(CMOCK_ledc_timer_resume_CALLBACK Callback)
{
  Mock.ledc_timer_resume_IgnoreBool = (char)0;
  Mock.ledc_timer_resume_CallbackBool = (char)1;
  Mock.ledc_timer_resume_CallbackFunctionPointer = Callback;
}

void ledc_timer_resume_Stub(CMOCK_ledc_timer_resume_CALLBACK Callback)
{
  Mock.ledc_timer_resume_IgnoreBool = (char)0;
  Mock.ledc_timer_resume_CallbackBool = (char)0;
  Mock.ledc_timer_resume_CallbackFunctionPointer = Callback;
}

void ledc_timer_resume_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_resume_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_resume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_resume_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_timer_resume_CMockIgnoreArg_timer_sel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_timer_resume_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_timer_resume_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_timer_resume_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_timer_sel = 1;
}

esp_err_t ledc_bind_channel_timer(ledc_mode_t speed_mode, ledc_channel_t channel, ledc_timer_t timer_sel)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_bind_channel_timer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_bind_channel_timer);
  cmock_call_instance = (CMOCK_ledc_bind_channel_timer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_bind_channel_timer_CallInstance);
  Mock.ledc_bind_channel_timer_CallInstance = CMock_Guts_MemNext(Mock.ledc_bind_channel_timer_CallInstance);
  if (Mock.ledc_bind_channel_timer_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_bind_channel_timer_FinalReturn;
    memcpy((void*)(&Mock.ledc_bind_channel_timer_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_bind_channel_timer_CallbackBool &&
      Mock.ledc_bind_channel_timer_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_bind_channel_timer_CallbackFunctionPointer(speed_mode, channel, timer_sel, Mock.ledc_bind_channel_timer_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_bind_channel_timer,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_bind_channel_timer,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_timer_sel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_bind_channel_timer,CMockString_timer_sel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_timer_sel), (void*)(&timer_sel), sizeof(ledc_timer_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_bind_channel_timer_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_bind_channel_timer_CallbackFunctionPointer(speed_mode, channel, timer_sel, Mock.ledc_bind_channel_timer_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_bind_channel_timer(CMOCK_ledc_bind_channel_timer_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, ledc_timer_t timer_sel);
void CMockExpectParameters_ledc_bind_channel_timer(CMOCK_ledc_bind_channel_timer_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, ledc_timer_t timer_sel)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  memcpy((void*)(&cmock_call_instance->Expected_timer_sel), (void*)(&timer_sel),
         sizeof(ledc_timer_t[sizeof(timer_sel) == sizeof(ledc_timer_t) ? 1 : -1])); /* add ledc_timer_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_timer_sel = 0;
}

void ledc_bind_channel_timer_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_bind_channel_timer_CALL_INSTANCE));
  CMOCK_ledc_bind_channel_timer_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_bind_channel_timer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_bind_channel_timer_CallInstance = CMock_Guts_MemChain(Mock.ledc_bind_channel_timer_CallInstance, cmock_guts_index);
  Mock.ledc_bind_channel_timer_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_bind_channel_timer_IgnoreBool = (char)1;
}

void ledc_bind_channel_timer_CMockStopIgnore(void)
{
  if(Mock.ledc_bind_channel_timer_IgnoreBool)
    Mock.ledc_bind_channel_timer_CallInstance = CMock_Guts_MemNext(Mock.ledc_bind_channel_timer_CallInstance);
  Mock.ledc_bind_channel_timer_IgnoreBool = (char)0;
}

void ledc_bind_channel_timer_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, ledc_timer_t timer_sel, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_bind_channel_timer_CALL_INSTANCE));
  CMOCK_ledc_bind_channel_timer_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_bind_channel_timer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_bind_channel_timer_CallInstance = CMock_Guts_MemChain(Mock.ledc_bind_channel_timer_CallInstance, cmock_guts_index);
  Mock.ledc_bind_channel_timer_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_bind_channel_timer(cmock_call_instance, speed_mode, channel, timer_sel);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_bind_channel_timer_AddCallback(CMOCK_ledc_bind_channel_timer_CALLBACK Callback)
{
  Mock.ledc_bind_channel_timer_IgnoreBool = (char)0;
  Mock.ledc_bind_channel_timer_CallbackBool = (char)1;
  Mock.ledc_bind_channel_timer_CallbackFunctionPointer = Callback;
}

void ledc_bind_channel_timer_Stub(CMOCK_ledc_bind_channel_timer_CALLBACK Callback)
{
  Mock.ledc_bind_channel_timer_IgnoreBool = (char)0;
  Mock.ledc_bind_channel_timer_CallbackBool = (char)0;
  Mock.ledc_bind_channel_timer_CallbackFunctionPointer = Callback;
}

void ledc_bind_channel_timer_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_bind_channel_timer_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_bind_channel_timer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_bind_channel_timer_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_bind_channel_timer_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_bind_channel_timer_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_bind_channel_timer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_bind_channel_timer_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_bind_channel_timer_CMockIgnoreArg_timer_sel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_bind_channel_timer_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_bind_channel_timer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_bind_channel_timer_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_timer_sel = 1;
}

esp_err_t ledc_set_fade_with_step(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t scale, uint32_t cycle_num)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_set_fade_with_step_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_set_fade_with_step);
  cmock_call_instance = (CMOCK_ledc_set_fade_with_step_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_set_fade_with_step_CallInstance);
  Mock.ledc_set_fade_with_step_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_fade_with_step_CallInstance);
  if (Mock.ledc_set_fade_with_step_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_set_fade_with_step_FinalReturn;
    memcpy((void*)(&Mock.ledc_set_fade_with_step_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_set_fade_with_step_CallbackBool &&
      Mock.ledc_set_fade_with_step_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_set_fade_with_step_CallbackFunctionPointer(speed_mode, channel, target_duty, scale, cycle_num, Mock.ledc_set_fade_with_step_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_with_step,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_with_step,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_target_duty)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_with_step,CMockString_target_duty);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_target_duty, target_duty, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_scale)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_with_step,CMockString_scale);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_scale, scale, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_cycle_num)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_with_step,CMockString_cycle_num);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_cycle_num, cycle_num, cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_set_fade_with_step_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_set_fade_with_step_CallbackFunctionPointer(speed_mode, channel, target_duty, scale, cycle_num, Mock.ledc_set_fade_with_step_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_set_fade_with_step(CMOCK_ledc_set_fade_with_step_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t scale, uint32_t cycle_num);
void CMockExpectParameters_ledc_set_fade_with_step(CMOCK_ledc_set_fade_with_step_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t scale, uint32_t cycle_num)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  cmock_call_instance->Expected_target_duty = target_duty;
  cmock_call_instance->IgnoreArg_target_duty = 0;
  cmock_call_instance->Expected_scale = scale;
  cmock_call_instance->IgnoreArg_scale = 0;
  cmock_call_instance->Expected_cycle_num = cycle_num;
  cmock_call_instance->IgnoreArg_cycle_num = 0;
}

void ledc_set_fade_with_step_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_fade_with_step_CALL_INSTANCE));
  CMOCK_ledc_set_fade_with_step_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_step_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_fade_with_step_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_fade_with_step_CallInstance, cmock_guts_index);
  Mock.ledc_set_fade_with_step_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_set_fade_with_step_IgnoreBool = (char)1;
}

void ledc_set_fade_with_step_CMockStopIgnore(void)
{
  if(Mock.ledc_set_fade_with_step_IgnoreBool)
    Mock.ledc_set_fade_with_step_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_fade_with_step_CallInstance);
  Mock.ledc_set_fade_with_step_IgnoreBool = (char)0;
}

void ledc_set_fade_with_step_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t scale, uint32_t cycle_num, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_fade_with_step_CALL_INSTANCE));
  CMOCK_ledc_set_fade_with_step_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_step_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_fade_with_step_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_fade_with_step_CallInstance, cmock_guts_index);
  Mock.ledc_set_fade_with_step_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_set_fade_with_step(cmock_call_instance, speed_mode, channel, target_duty, scale, cycle_num);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_set_fade_with_step_AddCallback(CMOCK_ledc_set_fade_with_step_CALLBACK Callback)
{
  Mock.ledc_set_fade_with_step_IgnoreBool = (char)0;
  Mock.ledc_set_fade_with_step_CallbackBool = (char)1;
  Mock.ledc_set_fade_with_step_CallbackFunctionPointer = Callback;
}

void ledc_set_fade_with_step_Stub(CMOCK_ledc_set_fade_with_step_CALLBACK Callback)
{
  Mock.ledc_set_fade_with_step_IgnoreBool = (char)0;
  Mock.ledc_set_fade_with_step_CallbackBool = (char)0;
  Mock.ledc_set_fade_with_step_CallbackFunctionPointer = Callback;
}

void ledc_set_fade_with_step_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_with_step_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_step_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_with_step_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_set_fade_with_step_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_with_step_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_step_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_with_step_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_set_fade_with_step_CMockIgnoreArg_target_duty(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_with_step_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_step_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_with_step_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_target_duty = 1;
}

void ledc_set_fade_with_step_CMockIgnoreArg_scale(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_with_step_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_step_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_with_step_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_scale = 1;
}

void ledc_set_fade_with_step_CMockIgnoreArg_cycle_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_with_step_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_step_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_with_step_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_cycle_num = 1;
}

esp_err_t ledc_set_fade_with_time(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, int max_fade_time_ms)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_set_fade_with_time_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_set_fade_with_time);
  cmock_call_instance = (CMOCK_ledc_set_fade_with_time_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_set_fade_with_time_CallInstance);
  Mock.ledc_set_fade_with_time_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_fade_with_time_CallInstance);
  if (Mock.ledc_set_fade_with_time_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_set_fade_with_time_FinalReturn;
    memcpy((void*)(&Mock.ledc_set_fade_with_time_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_set_fade_with_time_CallbackBool &&
      Mock.ledc_set_fade_with_time_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_set_fade_with_time_CallbackFunctionPointer(speed_mode, channel, target_duty, max_fade_time_ms, Mock.ledc_set_fade_with_time_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_with_time,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_with_time,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_target_duty)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_with_time,CMockString_target_duty);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_target_duty, target_duty, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_max_fade_time_ms)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_with_time,CMockString_max_fade_time_ms);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_max_fade_time_ms, max_fade_time_ms, cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_set_fade_with_time_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_set_fade_with_time_CallbackFunctionPointer(speed_mode, channel, target_duty, max_fade_time_ms, Mock.ledc_set_fade_with_time_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_set_fade_with_time(CMOCK_ledc_set_fade_with_time_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, int max_fade_time_ms);
void CMockExpectParameters_ledc_set_fade_with_time(CMOCK_ledc_set_fade_with_time_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, int max_fade_time_ms)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  cmock_call_instance->Expected_target_duty = target_duty;
  cmock_call_instance->IgnoreArg_target_duty = 0;
  cmock_call_instance->Expected_max_fade_time_ms = max_fade_time_ms;
  cmock_call_instance->IgnoreArg_max_fade_time_ms = 0;
}

void ledc_set_fade_with_time_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_fade_with_time_CALL_INSTANCE));
  CMOCK_ledc_set_fade_with_time_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_time_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_fade_with_time_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_fade_with_time_CallInstance, cmock_guts_index);
  Mock.ledc_set_fade_with_time_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_set_fade_with_time_IgnoreBool = (char)1;
}

void ledc_set_fade_with_time_CMockStopIgnore(void)
{
  if(Mock.ledc_set_fade_with_time_IgnoreBool)
    Mock.ledc_set_fade_with_time_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_fade_with_time_CallInstance);
  Mock.ledc_set_fade_with_time_IgnoreBool = (char)0;
}

void ledc_set_fade_with_time_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, int max_fade_time_ms, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_fade_with_time_CALL_INSTANCE));
  CMOCK_ledc_set_fade_with_time_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_time_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_fade_with_time_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_fade_with_time_CallInstance, cmock_guts_index);
  Mock.ledc_set_fade_with_time_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_set_fade_with_time(cmock_call_instance, speed_mode, channel, target_duty, max_fade_time_ms);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_set_fade_with_time_AddCallback(CMOCK_ledc_set_fade_with_time_CALLBACK Callback)
{
  Mock.ledc_set_fade_with_time_IgnoreBool = (char)0;
  Mock.ledc_set_fade_with_time_CallbackBool = (char)1;
  Mock.ledc_set_fade_with_time_CallbackFunctionPointer = Callback;
}

void ledc_set_fade_with_time_Stub(CMOCK_ledc_set_fade_with_time_CALLBACK Callback)
{
  Mock.ledc_set_fade_with_time_IgnoreBool = (char)0;
  Mock.ledc_set_fade_with_time_CallbackBool = (char)0;
  Mock.ledc_set_fade_with_time_CallbackFunctionPointer = Callback;
}

void ledc_set_fade_with_time_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_with_time_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_time_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_with_time_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_set_fade_with_time_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_with_time_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_time_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_with_time_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_set_fade_with_time_CMockIgnoreArg_target_duty(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_with_time_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_time_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_with_time_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_target_duty = 1;
}

void ledc_set_fade_with_time_CMockIgnoreArg_max_fade_time_ms(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_with_time_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_with_time_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_with_time_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_max_fade_time_ms = 1;
}

esp_err_t ledc_fade_func_install(int intr_alloc_flags)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_fade_func_install_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_fade_func_install);
  cmock_call_instance = (CMOCK_ledc_fade_func_install_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_fade_func_install_CallInstance);
  Mock.ledc_fade_func_install_CallInstance = CMock_Guts_MemNext(Mock.ledc_fade_func_install_CallInstance);
  if (Mock.ledc_fade_func_install_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_fade_func_install_FinalReturn;
    memcpy((void*)(&Mock.ledc_fade_func_install_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_fade_func_install_CallbackBool &&
      Mock.ledc_fade_func_install_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_fade_func_install_CallbackFunctionPointer(intr_alloc_flags, Mock.ledc_fade_func_install_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_intr_alloc_flags)
  {
    UNITY_SET_DETAILS(CMockString_ledc_fade_func_install,CMockString_intr_alloc_flags);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_intr_alloc_flags, intr_alloc_flags, cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_fade_func_install_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_fade_func_install_CallbackFunctionPointer(intr_alloc_flags, Mock.ledc_fade_func_install_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_fade_func_install(CMOCK_ledc_fade_func_install_CALL_INSTANCE* cmock_call_instance, int intr_alloc_flags);
void CMockExpectParameters_ledc_fade_func_install(CMOCK_ledc_fade_func_install_CALL_INSTANCE* cmock_call_instance, int intr_alloc_flags)
{
  cmock_call_instance->Expected_intr_alloc_flags = intr_alloc_flags;
  cmock_call_instance->IgnoreArg_intr_alloc_flags = 0;
}

void ledc_fade_func_install_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_fade_func_install_CALL_INSTANCE));
  CMOCK_ledc_fade_func_install_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_fade_func_install_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_fade_func_install_CallInstance = CMock_Guts_MemChain(Mock.ledc_fade_func_install_CallInstance, cmock_guts_index);
  Mock.ledc_fade_func_install_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_fade_func_install_IgnoreBool = (char)1;
}

void ledc_fade_func_install_CMockStopIgnore(void)
{
  if(Mock.ledc_fade_func_install_IgnoreBool)
    Mock.ledc_fade_func_install_CallInstance = CMock_Guts_MemNext(Mock.ledc_fade_func_install_CallInstance);
  Mock.ledc_fade_func_install_IgnoreBool = (char)0;
}

void ledc_fade_func_install_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int intr_alloc_flags, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_fade_func_install_CALL_INSTANCE));
  CMOCK_ledc_fade_func_install_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_fade_func_install_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_fade_func_install_CallInstance = CMock_Guts_MemChain(Mock.ledc_fade_func_install_CallInstance, cmock_guts_index);
  Mock.ledc_fade_func_install_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_fade_func_install(cmock_call_instance, intr_alloc_flags);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_fade_func_install_AddCallback(CMOCK_ledc_fade_func_install_CALLBACK Callback)
{
  Mock.ledc_fade_func_install_IgnoreBool = (char)0;
  Mock.ledc_fade_func_install_CallbackBool = (char)1;
  Mock.ledc_fade_func_install_CallbackFunctionPointer = Callback;
}

void ledc_fade_func_install_Stub(CMOCK_ledc_fade_func_install_CALLBACK Callback)
{
  Mock.ledc_fade_func_install_IgnoreBool = (char)0;
  Mock.ledc_fade_func_install_CallbackBool = (char)0;
  Mock.ledc_fade_func_install_CallbackFunctionPointer = Callback;
}

void ledc_fade_func_install_CMockIgnoreArg_intr_alloc_flags(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_fade_func_install_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_fade_func_install_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_fade_func_install_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_intr_alloc_flags = 1;
}

void ledc_fade_func_uninstall(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_fade_func_uninstall_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_fade_func_uninstall);
  cmock_call_instance = (CMOCK_ledc_fade_func_uninstall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_fade_func_uninstall_CallInstance);
  Mock.ledc_fade_func_uninstall_CallInstance = CMock_Guts_MemNext(Mock.ledc_fade_func_uninstall_CallInstance);
  if (Mock.ledc_fade_func_uninstall_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  if (!Mock.ledc_fade_func_uninstall_CallbackBool &&
      Mock.ledc_fade_func_uninstall_CallbackFunctionPointer != NULL)
  {
    Mock.ledc_fade_func_uninstall_CallbackFunctionPointer(Mock.ledc_fade_func_uninstall_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (Mock.ledc_fade_func_uninstall_CallbackFunctionPointer != NULL)
  {
    Mock.ledc_fade_func_uninstall_CallbackFunctionPointer(Mock.ledc_fade_func_uninstall_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
}

void ledc_fade_func_uninstall_CMockIgnore(void)
{
  Mock.ledc_fade_func_uninstall_IgnoreBool = (char)1;
}

void ledc_fade_func_uninstall_CMockStopIgnore(void)
{
  Mock.ledc_fade_func_uninstall_IgnoreBool = (char)0;
}

void ledc_fade_func_uninstall_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_fade_func_uninstall_CALL_INSTANCE));
  CMOCK_ledc_fade_func_uninstall_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_fade_func_uninstall_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_fade_func_uninstall_CallInstance = CMock_Guts_MemChain(Mock.ledc_fade_func_uninstall_CallInstance, cmock_guts_index);
  Mock.ledc_fade_func_uninstall_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void ledc_fade_func_uninstall_AddCallback(CMOCK_ledc_fade_func_uninstall_CALLBACK Callback)
{
  Mock.ledc_fade_func_uninstall_IgnoreBool = (char)0;
  Mock.ledc_fade_func_uninstall_CallbackBool = (char)1;
  Mock.ledc_fade_func_uninstall_CallbackFunctionPointer = Callback;
}

void ledc_fade_func_uninstall_Stub(CMOCK_ledc_fade_func_uninstall_CALLBACK Callback)
{
  Mock.ledc_fade_func_uninstall_IgnoreBool = (char)0;
  Mock.ledc_fade_func_uninstall_CallbackBool = (char)0;
  Mock.ledc_fade_func_uninstall_CallbackFunctionPointer = Callback;
}

esp_err_t ledc_fade_start(ledc_mode_t speed_mode, ledc_channel_t channel, ledc_fade_mode_t fade_mode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_fade_start_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_fade_start);
  cmock_call_instance = (CMOCK_ledc_fade_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_fade_start_CallInstance);
  Mock.ledc_fade_start_CallInstance = CMock_Guts_MemNext(Mock.ledc_fade_start_CallInstance);
  if (Mock.ledc_fade_start_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_fade_start_FinalReturn;
    memcpy((void*)(&Mock.ledc_fade_start_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_fade_start_CallbackBool &&
      Mock.ledc_fade_start_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_fade_start_CallbackFunctionPointer(speed_mode, channel, fade_mode, Mock.ledc_fade_start_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_fade_start,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_fade_start,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fade_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_fade_start,CMockString_fade_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_fade_mode), (void*)(&fade_mode), sizeof(ledc_fade_mode_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_fade_start_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_fade_start_CallbackFunctionPointer(speed_mode, channel, fade_mode, Mock.ledc_fade_start_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_fade_start(CMOCK_ledc_fade_start_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, ledc_fade_mode_t fade_mode);
void CMockExpectParameters_ledc_fade_start(CMOCK_ledc_fade_start_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, ledc_fade_mode_t fade_mode)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  memcpy((void*)(&cmock_call_instance->Expected_fade_mode), (void*)(&fade_mode),
         sizeof(ledc_fade_mode_t[sizeof(fade_mode) == sizeof(ledc_fade_mode_t) ? 1 : -1])); /* add ledc_fade_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_fade_mode = 0;
}

void ledc_fade_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_fade_start_CALL_INSTANCE));
  CMOCK_ledc_fade_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_fade_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_fade_start_CallInstance = CMock_Guts_MemChain(Mock.ledc_fade_start_CallInstance, cmock_guts_index);
  Mock.ledc_fade_start_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_fade_start_IgnoreBool = (char)1;
}

void ledc_fade_start_CMockStopIgnore(void)
{
  if(Mock.ledc_fade_start_IgnoreBool)
    Mock.ledc_fade_start_CallInstance = CMock_Guts_MemNext(Mock.ledc_fade_start_CallInstance);
  Mock.ledc_fade_start_IgnoreBool = (char)0;
}

void ledc_fade_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, ledc_fade_mode_t fade_mode, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_fade_start_CALL_INSTANCE));
  CMOCK_ledc_fade_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_fade_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_fade_start_CallInstance = CMock_Guts_MemChain(Mock.ledc_fade_start_CallInstance, cmock_guts_index);
  Mock.ledc_fade_start_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_fade_start(cmock_call_instance, speed_mode, channel, fade_mode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_fade_start_AddCallback(CMOCK_ledc_fade_start_CALLBACK Callback)
{
  Mock.ledc_fade_start_IgnoreBool = (char)0;
  Mock.ledc_fade_start_CallbackBool = (char)1;
  Mock.ledc_fade_start_CallbackFunctionPointer = Callback;
}

void ledc_fade_start_Stub(CMOCK_ledc_fade_start_CALLBACK Callback)
{
  Mock.ledc_fade_start_IgnoreBool = (char)0;
  Mock.ledc_fade_start_CallbackBool = (char)0;
  Mock.ledc_fade_start_CallbackFunctionPointer = Callback;
}

void ledc_fade_start_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_fade_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_fade_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_fade_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_fade_start_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_fade_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_fade_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_fade_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_fade_start_CMockIgnoreArg_fade_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_fade_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_fade_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_fade_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fade_mode = 1;
}

esp_err_t ledc_set_duty_and_update(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, uint32_t hpoint)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_set_duty_and_update_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_set_duty_and_update);
  cmock_call_instance = (CMOCK_ledc_set_duty_and_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_set_duty_and_update_CallInstance);
  Mock.ledc_set_duty_and_update_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_duty_and_update_CallInstance);
  if (Mock.ledc_set_duty_and_update_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_set_duty_and_update_FinalReturn;
    memcpy((void*)(&Mock.ledc_set_duty_and_update_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_set_duty_and_update_CallbackBool &&
      Mock.ledc_set_duty_and_update_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_set_duty_and_update_CallbackFunctionPointer(speed_mode, channel, duty, hpoint, Mock.ledc_set_duty_and_update_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_duty_and_update,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_duty_and_update,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_duty)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_duty_and_update,CMockString_duty);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_duty, duty, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_hpoint)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_duty_and_update,CMockString_hpoint);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_hpoint, hpoint, cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_set_duty_and_update_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_set_duty_and_update_CallbackFunctionPointer(speed_mode, channel, duty, hpoint, Mock.ledc_set_duty_and_update_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_set_duty_and_update(CMOCK_ledc_set_duty_and_update_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, uint32_t hpoint);
void CMockExpectParameters_ledc_set_duty_and_update(CMOCK_ledc_set_duty_and_update_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, uint32_t hpoint)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  cmock_call_instance->Expected_duty = duty;
  cmock_call_instance->IgnoreArg_duty = 0;
  cmock_call_instance->Expected_hpoint = hpoint;
  cmock_call_instance->IgnoreArg_hpoint = 0;
}

void ledc_set_duty_and_update_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_duty_and_update_CALL_INSTANCE));
  CMOCK_ledc_set_duty_and_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_and_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_duty_and_update_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_duty_and_update_CallInstance, cmock_guts_index);
  Mock.ledc_set_duty_and_update_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_set_duty_and_update_IgnoreBool = (char)1;
}

void ledc_set_duty_and_update_CMockStopIgnore(void)
{
  if(Mock.ledc_set_duty_and_update_IgnoreBool)
    Mock.ledc_set_duty_and_update_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_duty_and_update_CallInstance);
  Mock.ledc_set_duty_and_update_IgnoreBool = (char)0;
}

void ledc_set_duty_and_update_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t duty, uint32_t hpoint, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_duty_and_update_CALL_INSTANCE));
  CMOCK_ledc_set_duty_and_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_and_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_duty_and_update_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_duty_and_update_CallInstance, cmock_guts_index);
  Mock.ledc_set_duty_and_update_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_set_duty_and_update(cmock_call_instance, speed_mode, channel, duty, hpoint);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_set_duty_and_update_AddCallback(CMOCK_ledc_set_duty_and_update_CALLBACK Callback)
{
  Mock.ledc_set_duty_and_update_IgnoreBool = (char)0;
  Mock.ledc_set_duty_and_update_CallbackBool = (char)1;
  Mock.ledc_set_duty_and_update_CallbackFunctionPointer = Callback;
}

void ledc_set_duty_and_update_Stub(CMOCK_ledc_set_duty_and_update_CALLBACK Callback)
{
  Mock.ledc_set_duty_and_update_IgnoreBool = (char)0;
  Mock.ledc_set_duty_and_update_CallbackBool = (char)0;
  Mock.ledc_set_duty_and_update_CallbackFunctionPointer = Callback;
}

void ledc_set_duty_and_update_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_duty_and_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_and_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_duty_and_update_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_set_duty_and_update_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_duty_and_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_and_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_duty_and_update_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_set_duty_and_update_CMockIgnoreArg_duty(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_duty_and_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_and_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_duty_and_update_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_duty = 1;
}

void ledc_set_duty_and_update_CMockIgnoreArg_hpoint(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_duty_and_update_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_duty_and_update_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_duty_and_update_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_hpoint = 1;
}

esp_err_t ledc_set_fade_time_and_start(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t max_fade_time_ms, ledc_fade_mode_t fade_mode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_set_fade_time_and_start);
  cmock_call_instance = (CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_set_fade_time_and_start_CallInstance);
  Mock.ledc_set_fade_time_and_start_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_fade_time_and_start_CallInstance);
  if (Mock.ledc_set_fade_time_and_start_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_set_fade_time_and_start_FinalReturn;
    memcpy((void*)(&Mock.ledc_set_fade_time_and_start_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_set_fade_time_and_start_CallbackBool &&
      Mock.ledc_set_fade_time_and_start_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_set_fade_time_and_start_CallbackFunctionPointer(speed_mode, channel, target_duty, max_fade_time_ms, fade_mode, Mock.ledc_set_fade_time_and_start_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_time_and_start,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_time_and_start,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_target_duty)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_time_and_start,CMockString_target_duty);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_target_duty, target_duty, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_max_fade_time_ms)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_time_and_start,CMockString_max_fade_time_ms);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_max_fade_time_ms, max_fade_time_ms, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fade_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_time_and_start,CMockString_fade_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_fade_mode), (void*)(&fade_mode), sizeof(ledc_fade_mode_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_set_fade_time_and_start_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_set_fade_time_and_start_CallbackFunctionPointer(speed_mode, channel, target_duty, max_fade_time_ms, fade_mode, Mock.ledc_set_fade_time_and_start_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_set_fade_time_and_start(CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t max_fade_time_ms, ledc_fade_mode_t fade_mode);
void CMockExpectParameters_ledc_set_fade_time_and_start(CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t max_fade_time_ms, ledc_fade_mode_t fade_mode)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  cmock_call_instance->Expected_target_duty = target_duty;
  cmock_call_instance->IgnoreArg_target_duty = 0;
  cmock_call_instance->Expected_max_fade_time_ms = max_fade_time_ms;
  cmock_call_instance->IgnoreArg_max_fade_time_ms = 0;
  memcpy((void*)(&cmock_call_instance->Expected_fade_mode), (void*)(&fade_mode),
         sizeof(ledc_fade_mode_t[sizeof(fade_mode) == sizeof(ledc_fade_mode_t) ? 1 : -1])); /* add ledc_fade_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_fade_mode = 0;
}

void ledc_set_fade_time_and_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE));
  CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_fade_time_and_start_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_fade_time_and_start_CallInstance, cmock_guts_index);
  Mock.ledc_set_fade_time_and_start_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_set_fade_time_and_start_IgnoreBool = (char)1;
}

void ledc_set_fade_time_and_start_CMockStopIgnore(void)
{
  if(Mock.ledc_set_fade_time_and_start_IgnoreBool)
    Mock.ledc_set_fade_time_and_start_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_fade_time_and_start_CallInstance);
  Mock.ledc_set_fade_time_and_start_IgnoreBool = (char)0;
}

void ledc_set_fade_time_and_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t max_fade_time_ms, ledc_fade_mode_t fade_mode, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE));
  CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_fade_time_and_start_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_fade_time_and_start_CallInstance, cmock_guts_index);
  Mock.ledc_set_fade_time_and_start_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_set_fade_time_and_start(cmock_call_instance, speed_mode, channel, target_duty, max_fade_time_ms, fade_mode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_set_fade_time_and_start_AddCallback(CMOCK_ledc_set_fade_time_and_start_CALLBACK Callback)
{
  Mock.ledc_set_fade_time_and_start_IgnoreBool = (char)0;
  Mock.ledc_set_fade_time_and_start_CallbackBool = (char)1;
  Mock.ledc_set_fade_time_and_start_CallbackFunctionPointer = Callback;
}

void ledc_set_fade_time_and_start_Stub(CMOCK_ledc_set_fade_time_and_start_CALLBACK Callback)
{
  Mock.ledc_set_fade_time_and_start_IgnoreBool = (char)0;
  Mock.ledc_set_fade_time_and_start_CallbackBool = (char)0;
  Mock.ledc_set_fade_time_and_start_CallbackFunctionPointer = Callback;
}

void ledc_set_fade_time_and_start_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_time_and_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_set_fade_time_and_start_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_time_and_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_set_fade_time_and_start_CMockIgnoreArg_target_duty(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_time_and_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_target_duty = 1;
}

void ledc_set_fade_time_and_start_CMockIgnoreArg_max_fade_time_ms(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_time_and_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_max_fade_time_ms = 1;
}

void ledc_set_fade_time_and_start_CMockIgnoreArg_fade_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_time_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_time_and_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fade_mode = 1;
}

esp_err_t ledc_set_fade_step_and_start(ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t scale, uint32_t cycle_num, ledc_fade_mode_t fade_mode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_set_fade_step_and_start);
  cmock_call_instance = (CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_set_fade_step_and_start_CallInstance);
  Mock.ledc_set_fade_step_and_start_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_fade_step_and_start_CallInstance);
  if (Mock.ledc_set_fade_step_and_start_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_set_fade_step_and_start_FinalReturn;
    memcpy((void*)(&Mock.ledc_set_fade_step_and_start_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_set_fade_step_and_start_CallbackBool &&
      Mock.ledc_set_fade_step_and_start_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_set_fade_step_and_start_CallbackFunctionPointer(speed_mode, channel, target_duty, scale, cycle_num, fade_mode, Mock.ledc_set_fade_step_and_start_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_step_and_start,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_step_and_start,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_target_duty)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_step_and_start,CMockString_target_duty);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_target_duty, target_duty, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_scale)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_step_and_start,CMockString_scale);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_scale, scale, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_cycle_num)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_step_and_start,CMockString_cycle_num);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_cycle_num, cycle_num, cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_fade_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_set_fade_step_and_start,CMockString_fade_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_fade_mode), (void*)(&fade_mode), sizeof(ledc_fade_mode_t), cmock_line, CMockStringMismatch);
  }
  if (Mock.ledc_set_fade_step_and_start_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_set_fade_step_and_start_CallbackFunctionPointer(speed_mode, channel, target_duty, scale, cycle_num, fade_mode, Mock.ledc_set_fade_step_and_start_CallbackCalls++);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_set_fade_step_and_start(CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t scale, uint32_t cycle_num, ledc_fade_mode_t fade_mode);
void CMockExpectParameters_ledc_set_fade_step_and_start(CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t scale, uint32_t cycle_num, ledc_fade_mode_t fade_mode)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  cmock_call_instance->Expected_target_duty = target_duty;
  cmock_call_instance->IgnoreArg_target_duty = 0;
  cmock_call_instance->Expected_scale = scale;
  cmock_call_instance->IgnoreArg_scale = 0;
  cmock_call_instance->Expected_cycle_num = cycle_num;
  cmock_call_instance->IgnoreArg_cycle_num = 0;
  memcpy((void*)(&cmock_call_instance->Expected_fade_mode), (void*)(&fade_mode),
         sizeof(ledc_fade_mode_t[sizeof(fade_mode) == sizeof(ledc_fade_mode_t) ? 1 : -1])); /* add ledc_fade_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_fade_mode = 0;
}

void ledc_set_fade_step_and_start_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE));
  CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_fade_step_and_start_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_fade_step_and_start_CallInstance, cmock_guts_index);
  Mock.ledc_set_fade_step_and_start_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_set_fade_step_and_start_IgnoreBool = (char)1;
}

void ledc_set_fade_step_and_start_CMockStopIgnore(void)
{
  if(Mock.ledc_set_fade_step_and_start_IgnoreBool)
    Mock.ledc_set_fade_step_and_start_CallInstance = CMock_Guts_MemNext(Mock.ledc_set_fade_step_and_start_CallInstance);
  Mock.ledc_set_fade_step_and_start_IgnoreBool = (char)0;
}

void ledc_set_fade_step_and_start_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, uint32_t target_duty, uint32_t scale, uint32_t cycle_num, ledc_fade_mode_t fade_mode, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE));
  CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_set_fade_step_and_start_CallInstance = CMock_Guts_MemChain(Mock.ledc_set_fade_step_and_start_CallInstance, cmock_guts_index);
  Mock.ledc_set_fade_step_and_start_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_set_fade_step_and_start(cmock_call_instance, speed_mode, channel, target_duty, scale, cycle_num, fade_mode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_set_fade_step_and_start_AddCallback(CMOCK_ledc_set_fade_step_and_start_CALLBACK Callback)
{
  Mock.ledc_set_fade_step_and_start_IgnoreBool = (char)0;
  Mock.ledc_set_fade_step_and_start_CallbackBool = (char)1;
  Mock.ledc_set_fade_step_and_start_CallbackFunctionPointer = Callback;
}

void ledc_set_fade_step_and_start_Stub(CMOCK_ledc_set_fade_step_and_start_CALLBACK Callback)
{
  Mock.ledc_set_fade_step_and_start_IgnoreBool = (char)0;
  Mock.ledc_set_fade_step_and_start_CallbackBool = (char)0;
  Mock.ledc_set_fade_step_and_start_CallbackFunctionPointer = Callback;
}

void ledc_set_fade_step_and_start_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_step_and_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_set_fade_step_and_start_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_step_and_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_set_fade_step_and_start_CMockIgnoreArg_target_duty(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_step_and_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_target_duty = 1;
}

void ledc_set_fade_step_and_start_CMockIgnoreArg_scale(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_step_and_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_scale = 1;
}

void ledc_set_fade_step_and_start_CMockIgnoreArg_cycle_num(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_step_and_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_cycle_num = 1;
}

void ledc_set_fade_step_and_start_CMockIgnoreArg_fade_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_set_fade_step_and_start_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_set_fade_step_and_start_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_fade_mode = 1;
}

esp_err_t ledc_cb_register(ledc_mode_t speed_mode, ledc_channel_t channel, ledc_cbs_t* cbs, void* user_arg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_ledc_cb_register);
  cmock_call_instance = (CMOCK_ledc_cb_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.ledc_cb_register_CallInstance);
  Mock.ledc_cb_register_CallInstance = CMock_Guts_MemNext(Mock.ledc_cb_register_CallInstance);
  if (Mock.ledc_cb_register_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.ledc_cb_register_FinalReturn;
    memcpy((void*)(&Mock.ledc_cb_register_FinalReturn), (void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  if (!Mock.ledc_cb_register_CallbackBool &&
      Mock.ledc_cb_register_CallbackFunctionPointer != NULL)
  {
    esp_err_t cmock_cb_ret = Mock.ledc_cb_register_CallbackFunctionPointer(speed_mode, channel, cbs, user_arg, Mock.ledc_cb_register_CallbackCalls++);
    UNITY_CLR_DETAILS();
    return cmock_cb_ret;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledEarly);
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLate);
  if (!cmock_call_instance->IgnoreArg_speed_mode)
  {
    UNITY_SET_DETAILS(CMockString_ledc_cb_register,CMockString_speed_mode);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode), sizeof(ledc_mode_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_channel)
  {
    UNITY_SET_DETAILS(CMockString_ledc_cb_register,CMockString_channel);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel), sizeof(ledc_channel_t), cmock_line, CMockStringMismatch);
  }
  if (!cmock_call_instance->IgnoreArg_cbs)
  {
    UNITY_SET_DETAILS(CMockString_ledc_cb_register,CMockString_cbs);
    if (cmock_call_instance->Expected_cbs == NULL)
      { UNITY_TEST_ASSERT_NULL(cbs, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_MEMORY_ARRAY((void*)(cmock_call_instance->Expected_cbs), (void*)(cbs), sizeof(ledc_cbs_t), cmock_call_instance->Expected_cbs_Depth, cmock_line, CMockStringMismatch); }
  }
  if (!cmock_call_instance->IgnoreArg_user_arg)
  {
    UNITY_SET_DETAILS(CMockString_ledc_cb_register,CMockString_user_arg);
    if (cmock_call_instance->Expected_user_arg == NULL)
      { UNITY_TEST_ASSERT_NULL(user_arg, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_user_arg, user_arg, cmock_call_instance->Expected_user_arg_Depth, cmock_line, CMockStringMismatch); }
  }
  if (Mock.ledc_cb_register_CallbackFunctionPointer != NULL)
  {
    cmock_call_instance->ReturnVal = Mock.ledc_cb_register_CallbackFunctionPointer(speed_mode, channel, cbs, user_arg, Mock.ledc_cb_register_CallbackCalls++);
  }
  if (cmock_call_instance->ReturnThruPtr_cbs_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(cbs, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)cbs, (void*)cmock_call_instance->ReturnThruPtr_cbs_Val,
      cmock_call_instance->ReturnThruPtr_cbs_Size);
  }
  if (cmock_call_instance->ReturnThruPtr_user_arg_Used)
  {
    UNITY_TEST_ASSERT_NOT_NULL(user_arg, cmock_line, CMockStringPtrIsNULL);
    memcpy((void*)user_arg, (void*)cmock_call_instance->ReturnThruPtr_user_arg_Val,
      cmock_call_instance->ReturnThruPtr_user_arg_Size);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_ledc_cb_register(CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, ledc_cbs_t* cbs, int cbs_Depth, void* user_arg, int user_arg_Depth);
void CMockExpectParameters_ledc_cb_register(CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance, ledc_mode_t speed_mode, ledc_channel_t channel, ledc_cbs_t* cbs, int cbs_Depth, void* user_arg, int user_arg_Depth)
{
  memcpy((void*)(&cmock_call_instance->Expected_speed_mode), (void*)(&speed_mode),
         sizeof(ledc_mode_t[sizeof(speed_mode) == sizeof(ledc_mode_t) ? 1 : -1])); /* add ledc_mode_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_speed_mode = 0;
  memcpy((void*)(&cmock_call_instance->Expected_channel), (void*)(&channel),
         sizeof(ledc_channel_t[sizeof(channel) == sizeof(ledc_channel_t) ? 1 : -1])); /* add ledc_channel_t to :treat_as_array if this causes an error */
  cmock_call_instance->IgnoreArg_channel = 0;
  cmock_call_instance->Expected_cbs = cbs;
  cmock_call_instance->Expected_cbs_Depth = cbs_Depth;
  cmock_call_instance->IgnoreArg_cbs = 0;
  cmock_call_instance->ReturnThruPtr_cbs_Used = 0;
  cmock_call_instance->Expected_user_arg = user_arg;
  cmock_call_instance->Expected_user_arg_Depth = user_arg_Depth;
  cmock_call_instance->IgnoreArg_user_arg = 0;
  cmock_call_instance->ReturnThruPtr_user_arg_Used = 0;
}

void ledc_cb_register_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_cb_register_CALL_INSTANCE));
  CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_cb_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_cb_register_CallInstance = CMock_Guts_MemChain(Mock.ledc_cb_register_CallInstance, cmock_guts_index);
  Mock.ledc_cb_register_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.ledc_cb_register_IgnoreBool = (char)1;
}

void ledc_cb_register_CMockStopIgnore(void)
{
  if(Mock.ledc_cb_register_IgnoreBool)
    Mock.ledc_cb_register_CallInstance = CMock_Guts_MemNext(Mock.ledc_cb_register_CallInstance);
  Mock.ledc_cb_register_IgnoreBool = (char)0;
}

void ledc_cb_register_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, ledc_cbs_t* cbs, void* user_arg, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_cb_register_CALL_INSTANCE));
  CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_cb_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_cb_register_CallInstance = CMock_Guts_MemChain(Mock.ledc_cb_register_CallInstance, cmock_guts_index);
  Mock.ledc_cb_register_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_cb_register(cmock_call_instance, speed_mode, channel, cbs, 1, user_arg, 1);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void ledc_cb_register_AddCallback(CMOCK_ledc_cb_register_CALLBACK Callback)
{
  Mock.ledc_cb_register_IgnoreBool = (char)0;
  Mock.ledc_cb_register_CallbackBool = (char)1;
  Mock.ledc_cb_register_CallbackFunctionPointer = Callback;
}

void ledc_cb_register_Stub(CMOCK_ledc_cb_register_CALLBACK Callback)
{
  Mock.ledc_cb_register_IgnoreBool = (char)0;
  Mock.ledc_cb_register_CallbackBool = (char)0;
  Mock.ledc_cb_register_CallbackFunctionPointer = Callback;
}

void ledc_cb_register_CMockExpectWithArrayAndReturn(UNITY_LINE_TYPE cmock_line, ledc_mode_t speed_mode, ledc_channel_t channel, ledc_cbs_t* cbs, int cbs_Depth, void* user_arg, int user_arg_Depth, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_ledc_cb_register_CALL_INSTANCE));
  CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_cb_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.ledc_cb_register_CallInstance = CMock_Guts_MemChain(Mock.ledc_cb_register_CallInstance, cmock_guts_index);
  Mock.ledc_cb_register_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  CMockExpectParameters_ledc_cb_register(cmock_call_instance, speed_mode, channel, cbs, cbs_Depth, user_arg, user_arg_Depth);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void ledc_cb_register_CMockReturnMemThruPtr_cbs(UNITY_LINE_TYPE cmock_line, ledc_cbs_t* cbs, size_t cmock_size)
{
  CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_cb_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_cb_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_cbs_Used = 1;
  cmock_call_instance->ReturnThruPtr_cbs_Val = cbs;
  cmock_call_instance->ReturnThruPtr_cbs_Size = cmock_size;
}

void ledc_cb_register_CMockReturnMemThruPtr_user_arg(UNITY_LINE_TYPE cmock_line, void* user_arg, size_t cmock_size)
{
  CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_cb_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_cb_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringPtrPreExp);
  cmock_call_instance->ReturnThruPtr_user_arg_Used = 1;
  cmock_call_instance->ReturnThruPtr_user_arg_Val = user_arg;
  cmock_call_instance->ReturnThruPtr_user_arg_Size = cmock_size;
}

void ledc_cb_register_CMockIgnoreArg_speed_mode(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_cb_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_cb_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_speed_mode = 1;
}

void ledc_cb_register_CMockIgnoreArg_channel(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_cb_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_cb_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_channel = 1;
}

void ledc_cb_register_CMockIgnoreArg_cbs(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_cb_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_cb_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_cbs = 1;
}

void ledc_cb_register_CMockIgnoreArg_user_arg(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_ledc_cb_register_CALL_INSTANCE* cmock_call_instance = (CMOCK_ledc_cb_register_CALL_INSTANCE*)CMock_Guts_GetAddressFor(CMock_Guts_MemEndOfChain(Mock.ledc_cb_register_CallInstance));
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringIgnPreExp);
  cmock_call_instance->IgnoreArg_user_arg = 1;
}

